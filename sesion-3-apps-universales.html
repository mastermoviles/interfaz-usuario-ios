
<!doctype html>
<html lang="es" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="sesion-2-controladores-avanzados.html">
      
      
        <link rel="next" href="sesion-4-multitouch.html">
      
      <link rel="icon" href="assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.2, mkdocs-material-9.1.21">
    
    
      
        <title>3- Diseño de aplicaciones universales - iOS avanzado (IUDM)</title>
      
    
    
      <link rel="stylesheet" href="assets/stylesheets/main.eebd395e.min.css">
      
        
        <link rel="stylesheet" href="assets/stylesheets/palette.ecc896b0.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL(".",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="Teal" data-md-color-accent="Teal">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#3-aplicaciones-universales" class="md-skip">
          Saltar a contenido
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Cabecera">
    <a href="." title="iOS avanzado (IUDM)" class="md-header__button md-logo" aria-label="iOS avanzado (IUDM)" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            iOS avanzado (IUDM)
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              3- Diseño de aplicaciones universales
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Búsqueda" placeholder="Búsqueda" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Buscar">
        
        <button type="reset" class="md-search__icon md-icon" title="Limpiar" aria-label="Limpiar" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Inicializando búsqueda
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
                
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" hidden>
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navegación" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="." title="iOS avanzado (IUDM)" class="md-nav__button md-logo" aria-label="iOS avanzado (IUDM)" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    iOS avanzado (IUDM)
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="README.md" class="md-nav__link">
        Presentación
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html" class="md-nav__link">
        1- Guías de estilo y personalizaciones avanzadas
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="sesion-2-controladores-avanzados.html" class="md-nav__link">
        2- Controladores avanzados
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          3- Diseño de aplicaciones universales
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="sesion-3-apps-universales.html" class="md-nav__link md-nav__link--active">
        3- Diseño de aplicaciones universales
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Tabla de contenidos">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Tabla de contenidos
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#diseno-de-apps-universales-en-xcode" class="md-nav__link">
    Diseño de apps universales en XCode
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vistas-dependientes-del-dispositivo" class="md-nav__link">
    Vistas dependientes del dispositivo
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#split-view" class="md-nav__link">
    Split View
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ejercicio-app-universal-con-uisplitviewcontroller" class="md-nav__link">
    Ejercicio: App universal con UISplitViewController
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ejercicio-peliculas" class="md-nav__link">
    Ejercicio Películas
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="sesion-4-multitouch.html" class="md-nav__link">
        4- Detección de gestos
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
                
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Tabla de contenidos">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Tabla de contenidos
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#diseno-de-apps-universales-en-xcode" class="md-nav__link">
    Diseño de apps universales en XCode
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vistas-dependientes-del-dispositivo" class="md-nav__link">
    Vistas dependientes del dispositivo
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#split-view" class="md-nav__link">
    Split View
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ejercicio-app-universal-con-uisplitviewcontroller" class="md-nav__link">
    Ejercicio: App universal con UISplitViewController
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#ejercicio-peliculas" class="md-nav__link">
    Ejercicio Películas
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="3-aplicaciones-universales">3- Aplicaciones universales</h1>
<p>En esta primera parte empezaremos explicando cómo programar una app universal cuya interfaz se adapte a modelos y tamaños diferentes de iPhone y iPad teniendo en cuenta si las vistas son compactas o regulares. A continuación haremos un ejercicio usando el componente <em>Split View</em> y adaptando las vistas a distintos dispositivos. </p>
<h2 id="diseno-de-apps-universales-en-xcode">Diseño de apps universales en XCode</h2>
<p>En este apartado veremos qué son las aplicaciones universales, qué ventajas e inconvenientes podemos encontrar a la hora de diseñarlas, cómo programarlas, y las recomendaciones de Apple para adaptar las vistas. </p>
<h3 id="introduccion">Introducción</h3>
<p>Normalmente se usa el término <strong>universal</strong> para denominar a todas aquellas aplicaciones adaptadas tanto al iPad como al iPhone. Los usuarios agradecen este tipo de aplicaciones ya que pueden usarlas en todos sus dispositivos. Además, cuanto más dispositivos compatibles tengamos más clientes potenciales podremos captar.</p>
<p>El desarrollo de una aplicación universal ahorra tiempo   respecto a implementar apps independientes para cada dispositivo, ya que evidentemente programaremos el código en un sólo proyecto en lugar de varios. También tiene ventajas para las actualizaciones, ya que tendremos que preocuparnos de implementar los cambios sólo en una aplicación.</p>
<h3 id="disenando-la-interfaz-de-una-aplicacion-universal">Diseñando la interfaz de una aplicación universal</h3>
<p>El primer paso para hacer una aplicación universal es tener en cuenta el diseño del interfaz para cada una de las vistas. En versiones anteriores de iOS se separaban las vistas de iPhone de las de iPad usando distintos ficheros <em>.xib</em>. Actualmente se debe hacer de forma conjunta usando los <em>storyboards</em> y <em>autolayout</em> en el caso de <code>UIKit</code> (que es la que estamos viendo en la asignatura), o bien directamente mediante <code>SwiftUI</code> en las últimas versiones.</p>
<p>Estos son algunos de los aspectos principales que debemos tener en cuenta para diseñar una interfaz universal:</p>
<ul>
<li><strong>Orientación.</strong> Con la información sobre la orientación del dispositivo podremos adaptar la interfaz para acomodarla al mismo.  </li>
<li><strong>Estructura de las vistas</strong>. La pantalla del iPad es más grande que la del iPhone, permitiendo al usuario acceder a más información en pantalla.</li>
<li><strong>Comportamiento de las API.</strong> Componentes como los <code>UIPopover</code>, por ejemplo, se comportan de forma distinta en un iPhone y en un iPad.</li>
<li><strong>Características Hardware.</strong> Los dispositivos iOS pueden tener distintas funcionalidades hardware, como el número de cámaras, la capacidad de gestionar <em>dynamic islands</em>, soporte para <em>Pencil</em>, etc., que hay que tener en cuenta cuando se implementa una aplicación universal.</li>
<li><strong>Gestos.</strong> En la pantalla del iPad a veces podemos realizar más gestos que en la del iPhone debido a su tamaño. Por ejemplo, se pueden usar cuatro dedos al mismo tiempo.</li>
<li><strong>Arte.</strong> Hay que tener en cuenta la resolución de los distintos dispositivos, almacenando las imágenes en los <em>Assets</em> usando  varias resoluciones. Una alternativa recomendada por Apple es usar archivos PDF en los Assets. </li>
</ul>
<p>Como acabamos de ver, para programar una aplicación universal en iOS debemos tener en cuenta las características del dispositivo. Para esto podemos usar código condicional. Por ejemplo, podemos detectar en cualquier momento si estamos ejecutando nuestra app con un iPhone o un iPad con la instrucción <code>UIDevice.currentDevice().userInterfaceIdiom</code> o su modelo con <code>UIDevice.currentDevice().model</code>.</p>
<h3 id="programando-una-aplicacion-universal">Programando una aplicación universal</h3>
<p>Vamos a implementar un ejemplo de app universal paso a paso.</p>
<!---
Si nombramos los ficheros de las vistas con el sufijo `~ipad` o `~iphone` (por ejemplo `MyViewController~ipad.xib` y `MyViewController~iphone.xib`), el compilador llama automáticamente a la vista del dispositivo correspondiente.
--->

<!---
A pesar de las recomendaciones de Apple, usar _xib_ para las vistas tiene ciertas ventajas, como la reutilización de código y la posibilidad de editar proyectos de forma compartida, que con el _storyboard_ se complica. Ya hemos visto en apartados anteriores cómo usar _xibs_, y a continuación veremos cómo hacer una aplicación universal con _storyboards_.
--->

<p>Comenzamos abriendo <em>XCode</em> y creando un nuevo proyecto de tipo <code>iOS &gt; App</code> al que llamaremos <code>ejercicio_prueba</code> Abrimos la vista principal del <em>storyboard</em>. </p>
<ul>
<li>Arrastra un <code>UILabel</code> a la vista principal del <em>storyboard</em> y suéltala por el centro de la vista.</li>
<li>Podemos ver cómo quedaría en distintos dispositivos sin llegar a ejecutar el simulador. En el <em>storyboard</em> pincha en la parte inferior, donde aparece el modelo (por ejemplo, iPhone14) y elige otro modelo, por ejemplo un iPad.
<img alt="Storyboard preview" src="gitbook/assets/universalpreview.png" title="Storyboard Preview" /></li>
<li>La etiqueta se desplazará a otro lugar. Si rotamos el dispositivo (en la parte inferior, con el icono de un cuadrado que tiene encima una flecha), es posible que hasta desaparezca de la pantalla. </li>
<li>Ajusta las opciones de <em>autolayout</em> para la etiqueta. Si no controlas todavía <em>autolayout</em>, puedes seleccionar el triángulo de la parte inferior  (<em>Resolve autolayout issues</em>) y elegir <em>Reset to suggested constraints</em>.</li>
<li>Si mueves el <code>UILabel</code> a otra posición, verás que las líneas azules de guía aparecen ahora de color naranja. Esto es porque todavía tenemos las <em>constraints</em> anteriores y son inconsistentes con la nueva posición. Para actualizar la vista pincha de nuevo en el triángulo y selecciona <em>Update constraint constants</em>.</li>
</ul>
<p>Puedes ampliar o reducir los <em>previews</em> haciendo zoom con los dedos en el <em>trackpad</em>, o usando los controles de la parte inferior.</p>
<p>En principio es sencillo, aunque a veces es complicado saber cómo ajustar las <em>constraints</em> y manejar <em>autolayout</em>. Las opciones de <em>autolayout</em> pueden parecer fáciles de interpretar, pero a la hora de la verdad no es fácil dejar una vista como queremos.</p>
<h2 id="vistas-dependientes-del-dispositivo">Vistas dependientes del dispositivo</h2>
<p>A veces interesa tener vistas diferentes para distintos tamaños para aprovechar mejor la pantalla. Como se ha mencionado anteriormente, se recomienda usar interfaces diferenciados, ya que simplemente escalar el tamaño de los componentes para pantallas más grandes no suele quedar bien.</p>
<p>Para el diseño del interfaz, en lugar de distinguir entre iPhone e iPad, Apple introdujo en XCode 7 el concepto de <em>size clases</em>. La idea es que el desarrollador piense el diseño sólo para dos tamaños:</p>
<ul>
<li><strong>Compact</strong>: Cuando tenemos un tamaño <em>Compact</em> debemos hacer un interfaz mínimo que muestre sólo la información más relevante de forma compacta.</li>
<li><strong>Regular</strong>: En un tamaño <em>Regular</em> podemos añadir más elementos y hacer un interfaz completo, ya que dispondremos de más espacio en la pantalla.</li>
</ul>
<p>Además, estos tamaños pueden venir dados para la anchura (<em>Width</em>) o la altura (<em>Height</em>). Por tanto, debemos tener en cuenta tres factores:</p>
<ul>
<li><strong>Dispositivo</strong>. iPhone o iPad.</li>
<li><strong>Orientación</strong>. Horizontal o vertical.</li>
<li><strong>Tamaño</strong>. Compacto o regular.</li>
</ul>
<p>Básicamente (aunque en realidad es algo más complicado), los dispositivos de Apple tienen los siguientes tamaños:</p>
<p><img alt="Size classes" src="gitbook/assets/size_classes2.png" title="Size classes" /></p>
<p>En la imagen, el iPhone que se ve en arriba en el centro es un iPhone 6s <strong>plus</strong>. Los modelos más grandes de iPhone tienen un tamaño regular cuando el móvil está apaisado. </p>
<p>Puedes ver un listado completo de los tamaños al final de <a href="https://developer.apple.com/design/human-interface-guidelines/foundations/layout/">este enlace</a>.</p>
<p><img alt="Tamaños" src="gitbook/assets/sizesios.png" title="Tamaños de dispositivos" /></p>
<blockquote>
<p>En realidad es más complicado porque hay que tener en cuenta que <strong>no debemos asumir que los tamaños de vista son siempre constantes</strong>, ya que por ejemplo nuestra app en un iPad podría mostrarse en una zona compacta de la pantalla en lugar de usar la pantalla completa. Por tanto, siempre debemos diseñar todas las vistas tanto en modo compacto como regular. </p>
</blockquote>
<p>En la ventana inferior de <em>XCode</em> podemos cambiar el tipo de dispositivo, su orientación, y en el caso del iPad, su adaptación. Independientemente de lo que seleccionemos, los cambios que hagamos aquí sobre la vista se aplicarán a <strong>todos</strong> los tamaños.</p>
<p>Es posible mostrar un componente (por ejemplo, un botón o una etiqueta) sólo para un tamaño determinado. Para esto, puedes seleccionarlo y pinchar en el símbolo <code>+</code> que aparece junto a <code>Installed</code> en las propiedades del  componente. </p>
<p><img alt="Tamaños" src="gitbook/assets/sizeTraitsLabel.png" title="Tamaños de dispositivos" /></p>
<p>Si por ejemplo elegimos <em>width Compact</em> y <em>height Regular</em> (<code>wC hR</code>) y desmarcamos <code>Installed</code>, la etiqueta desaparecerá para estos tamaños (pruébalo y verás que desaparece en un iPhone SE). </p>
<p>También se pueden cambiar las propiedades de los componentes en función del tamaño actual. Por ejemplo: </p>
<ul>
<li>Selecciona en la barra de abajo un iPhone SE (1st generation) en orientación apaisada (en este caso es <code>wC-hC</code>).</li>
<li>Pulsa sobre el botón <code>+</code> a la izquierda de la propiedad <em>Font</em> de la etiqueta, en el <em>Attributes Inspector</em>, y luego en <em>Add variation</em>, dejando <em>width=Compact</em> y <em>height=Compact</em>.</li>
<li>Fíjate en que aparece una nueva columna en la tabla de propiedades. Puedes cambiar la fuente a 15 puntos, y esto sólo se aplicará en los dispositivos <code>wC-hC</code>.</li>
<li>Como puedes ver, muchas propiedades tienen el botón <code>+</code> para hacer cambios sólo con ciertos tamaños. Si quieres eliminar la configuración de una propiedad, puedes pulsar sobre el botón <code>x</code> que aparece a su lado.</li>
</ul>
<!--
## Componentes para iPad

Debido a las diferencias evidentes de tamaño entre un iPhone y un iPad (al menos hasta el lanzamiento del _iPhone 6_), Apple desarrolló una API específica para iPad. La intención era que aquellas aplicaciones para iPad se beneficiaran de esta API para mejorar la experiencia de usuario y la usabilidad. Por ello aparecieron dos nuevos controladores enfocados a esta plataforma:

* **Popover**: Es una ventana emergente que puede aparecer en cualquier parte de la pantalla, normalmente junto a un botón al pulsarlo. Resulta muy útil para mostrar un listado de opciones o una tabla con información sin llegar a ocultar toda la pantalla.
* <a href="https://developer.apple.com/reference/uikit/uisplitviewcontroller">**Split View**</a> (Vista dividida): Está formado por dos vistas independientes, una situada en la parte izquierda y otra en la parte derecha. Se utiliza frecuentemente para mostrar en la izquierda un listado de opciones en forma de tabla, y en la derecha el detalle de lo seleccionado en la parte izquierda. El _Split View_ normalmente se usa en la primera pantalla de la aplicación (como controlador raíz). A pesar de que puede usarse en una vista intermedia no es recomendable hacerlo, y además Apple no permite incrustar este controlador en otro controlador contenedor como un `UINavigationController`. Cuando creamos un nuevo proyecto con la plantilla `Master Detail Application` se genera la estructura básica para una aplicación Universal (por defecto) usando el controlador `UISplitView Controller` como base.


> En versiones anteriores a iOS sólo estaba permitido usar _Split Views_ en iPad. Desde iOS 8.0 y coincidiendo con la aparición de los modelos con pantallas de mayor tamaño, se puede usar _Split Views_ en todos los dispositivos iOS, aunque la vista dividida sólo puede verse en _iPad_, _iPhone plus_ y _iPhone X_.

En este tema veremos cómo implementar _popovers_ y _Split Views_ para hacer apps universales.

## Popovers

### Introducción

Un _popover_ es una ventana secundaria (estilo _popup_) que aparece por encima de la ventana principal de la interfaz. Se puede programar para que desaparezca automáticamente cuando el usuario toca cualquier parte de la pantalla.

El tamaño del _popover_ se puede modificar y por supuesto puede contener casi cualquier vista que se desee, como por ejemplo un listado de opciones de configuración, un álbum de fotos del que el usuario pueda seleccionar una, un formulario simple para introducir un texto, etc. En un iPhone, un _popover_ de iPad puede corresponderse con cualquier vista que ocupe la pantalla completa.
-->
<!---
> Los _popover_ son de los pocos objetos en iOS que no se pueden crear usando el _Interface Builder_ de XCode. Hay que crearlos mediante código.

Si has usado XCode7 o superior para compilar el ejemplo anterior, habrás notado que sale un _warning_ de compilación indicando que `UIPopoverController` está _deprecated_.

> Los métodos y componentes _deprecated_ son aquellos que Apple recomienda no usar, porque de momento funcionan pero en futuras versiones de iOS puede que se cambien o eliminen. Hay métodos y propiedades _deprecated_ como `cell.textColor`, que se puso en este estado en iOS 3.0 pero pudo seguir usándose hasta iOS 9.0.

--->
<!--
En iOS 9 Apple cambió la forma de crear popovers debido a la inclusión de _multitasking_, que permite ejecutar dos aplicaciones simultáneas que comparten la pantalla. Por tanto, en lugar de usarse la antigua clase `UIPopoverController` ahora se utiliza `UIPopoverPresentationController`, que tiene bastantes ventajas respecto a la anterior.

Con el fin de aclarar la definición de _popover_ y ver cómo podemos utilizarlo en nuestras aplicaciones vamos a realizar un sencillo ejercicio para mostrar un _popover_ que contiene un pequeño listado de opciones.

## Ejercicio 1 - Popovers

Creamos un nuevo proyecto de tipo _Single View_ llamado `ejercicio_popover`. Para empezar nos iremos al storyboard y pondremos la vista principal dentro de un `UINavigationController` con _Editor->Embed in->Navigation controller_.

Añadimos un botón (`UIBarButtonItem`) en la parte derecha de nuestra barra de navegación del `View Controller`. Le daremos el título `Opciones`. La idea es que cuando se seleccione este botón aparezca un _popover_ que mostrará una tabla.

Crea una acción llamada `accionOpciones` en `ViewController.swift`, que se active cuando se pulse el botón. De momento dejaremos este método vacío, ya que todavía no tenemos la vista a mostrar.

### Creando el controlador a mostrar

Para la vista del popover vamos a crear un controlador pulsando en _File > New > File > Cocoa Touch Class_. Le daremos el nombre _TableViewController_, subclase de  `UITableViewController` con la opción _Also create XIB_ desmarcada.

Arrastra un componente `UITableViewController` al storyboard, e indica que su controlador va a ser nuestro recien creado `TableViewController`. Dale también un nombre al _Storyboard ID_ (llámalo _tablaStoryboard_) y marca la opción _Use Storyboard ID_,  como puede verse en la siguiente imagen. Esto lo hacemos para poder referenciar la vista desde cualquier punto de nuestro código.


![Configuración de la vista](gitbook/assets/popover.png "Configuración de la vista _popover_")

En la pestaña de _Attributes Inspector_ de la celda escribimos un identificador para ella: _TableViewCell_.

![Configuración de la celda](gitbook/assets/popover_identifier.png "Configuración de la celda")

Ahora vamos a configurar el controlador que se verá en el _popover_, es decir, la tabla a mostrar cuando se pulse el botón. Para ello editamos `TableViewController.swift` con el siguiente código:

<div class="highlight"><pre><span></span><code><span class="kd">protocol</span> <span class="nc">TableViewControllerDelegate</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">opcionSeleccionada</span><span class="p">(</span><span class="n">nombreOpcion</span> <span class="p">:</span> <span class="nb">String</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

Y añadimos dos variables en esta misma clase:

<div class="highlight"><pre><span></span><code><span class="kd">var</span> <span class="nv">opciones</span> <span class="p">:</span> <span class="p">[</span><span class="nb">String</span><span class="p">]?</span>
<span class="kd">var</span> <span class="nv">delegate</span><span class="p">:</span><span class="n">TableViewControllerDelegate</span><span class="p">?</span>
</code></pre></div>

Ahora modificamos el método `viewDidLoad`:

<div class="highlight"><pre><span></span><code><span class="kr">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
    <span class="kc">super</span><span class="p">.</span><span class="n">viewDidLoad</span><span class="p">()</span>

    <span class="kc">self</span><span class="p">.</span><span class="n">clearsSelectionOnViewWillAppear</span> <span class="p">=</span> <span class="kc">false</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">opciones</span> <span class="p">=</span> <span class="p">[</span><span class="s">&quot;Opción 1&quot;</span><span class="p">,</span> <span class="s">&quot;Opción 2&quot;</span><span class="p">,</span> <span class="s">&quot;Opción 3&quot;</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div>
Y los métodos delegados de la tabla:

<div class="highlight"><pre><span></span><code><span class="kr">override</span> <span class="kd">func</span> <span class="nf">numberOfSections</span><span class="p">(</span><span class="k">in</span> <span class="n">tableView</span><span class="p">:</span> <span class="bp">UITableView</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="kr">override</span> <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="kc">_</span> <span class="n">tableView</span><span class="p">:</span> <span class="bp">UITableView</span><span class="p">,</span> <span class="n">numberOfRowsInSection</span> <span class="n">section</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">self</span><span class="p">.</span><span class="n">opciones</span><span class="p">!.</span><span class="bp">count</span>
<span class="p">}</span>

<span class="kr">override</span> <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="kc">_</span> <span class="n">tableView</span><span class="p">:</span> <span class="bp">UITableView</span><span class="p">,</span> <span class="n">didSelectRowAt</span> <span class="n">indexPath</span><span class="p">:</span> <span class="n">IndexPath</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kc">self</span><span class="p">.</span><span class="n">delegate</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">opcion</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">opciones</span><span class="p">?[</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">]</span>

        <span class="c1">// Llamamos al método opcionSeleccionada del delegado cuando se selecciona una opción de la tabla.</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">delegate</span><span class="p">?.</span><span class="n">opcionSeleccionada</span><span class="p">(</span><span class="n">nombreOpcion</span><span class="p">:</span> <span class="n">opcion</span><span class="p">!)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kr">override</span> <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="kc">_</span> <span class="n">tableView</span><span class="p">:</span> <span class="bp">UITableView</span><span class="p">,</span> <span class="n">cellForRowAt</span> <span class="n">indexPath</span><span class="p">:</span> <span class="n">IndexPath</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="bp">UITableViewCell</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">cell</span> <span class="p">=</span> <span class="n">tableView</span><span class="p">.</span><span class="n">dequeueReusableCell</span><span class="p">(</span><span class="n">withIdentifier</span><span class="p">:</span> <span class="s">&quot;TableViewCell&quot;</span><span class="p">,</span> <span class="k">for</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">)</span>

    <span class="n">cell</span><span class="p">.</span><span class="n">textLabel</span><span class="p">?.</span><span class="n">text</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">opciones</span><span class="p">?[</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">cell</span>
<span class="p">}</span>
</code></pre></div>

Como puedes ver, se trata de un controlador de tabla que muestra tres opciones por pantalla. Cuando se seleccione una opción, se llamará al método `opcionSeleccionada` de la clase delegada, que será quien tome las decisiones necesarias con la opción elegida.

### Mostrando el popover

Una vez hemos programado la clase encargada de gestionar la selección de la opción, sólo nos queda mostrar esta tabla en un _popover_. Para ello abrimos `ViewController.swift` y hacemos que adopte los protocolos `UIPopoverPresentationController` (por ser un popover) y `TableViewControllerDelegate` (para poder hacer algo cuando se seleccione una opción de la tabla):

<div class="highlight"><pre><span></span><code><span class="kd">class</span> <span class="nc">ViewController</span><span class="p">:</span> <span class="bp">UIViewController</span><span class="p">,</span> <span class="bp">UIPopoverPresentationControllerDelegate</span><span class="p">,</span> <span class="n">TableViewControllerDelegate</span>
</code></pre></div>

Ahora tenemos que programar el método que se invocará cuando se pulse sobre el botón en `ViewController.swift`:

<div class="highlight"><pre><span></span><code><span class="kr">@IBAction</span> <span class="kd">func</span> <span class="nf">accionOpciones</span><span class="p">(</span><span class="kc">_</span> <span class="n">sender</span><span class="p">:</span> <span class="nb">Any</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">storyboard</span> <span class="p">=</span> <span class="bp">UIStoryboard</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="s">&quot;Main&quot;</span><span class="p">,</span> <span class="n">bundle</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">controller</span> <span class="p">=</span> <span class="n">storyboard</span><span class="p">.</span><span class="n">instantiateViewController</span><span class="p">(</span><span class="n">withIdentifier</span><span class="p">:</span> <span class="s">&quot;tablaStoryboard&quot;</span><span class="p">)</span> <span class="k">as</span><span class="p">!</span> <span class="n">TableViewController</span>

    <span class="n">controller</span><span class="p">.</span><span class="n">delegate</span> <span class="p">=</span> <span class="kc">self</span>

    <span class="c1">// Presentamos el controlador</span>
    <span class="c1">// - en iPad, será un Popover</span>
    <span class="c1">// - en iPhone, será un action sheet</span>
    <span class="n">controller</span><span class="p">.</span><span class="n">modalPresentationStyle</span> <span class="p">=</span> <span class="n">UIModalPresentationStyle</span><span class="p">.</span><span class="n">popover</span>

    <span class="kc">self</span><span class="p">.</span><span class="n">present</span><span class="p">(</span><span class="n">controller</span><span class="p">,</span> <span class="n">animated</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="n">completion</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>

    <span class="c1">// Configuramos el popover (sí, después de presentarlo, es tan ilógico como parece)</span>
    <span class="kd">let</span> <span class="nv">popController</span> <span class="p">=</span> <span class="n">controller</span><span class="p">.</span><span class="n">popoverPresentationController</span>

    <span class="c1">// Todo popover debe tener un botón de referencia o una posición en la pantalla desde la que sale (con barButtonItem o con sourceView):</span>
    <span class="n">popController</span><span class="p">?.</span><span class="n">barButtonItem</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">navigationItem</span><span class="p">.</span><span class="n">rightBarButtonItem</span>
    <span class="n">popController</span><span class="p">?.</span><span class="n">permittedArrowDirections</span> <span class="p">=</span> <span class="n">UIPopoverArrowDirection</span><span class="p">.</span><span class="n">any</span>
    <span class="n">popController</span><span class="p">?.</span><span class="n">delegate</span> <span class="p">=</span> <span class="kc">self</span>
<span class="p">}</span>
</code></pre></div>

Mira bien la lógica del método. Cuando se pulsa el botón en el método `accionOpciones`, cargamos el controlador de la tabla desde el _storyboard_. A continuación indicamos que la tabla delegará en nuestra clase para que nos avise de la selección mediante el método `opcionSeleccionada`. Después presentamos el controlador, y a continuación (es raro pero es así, se hace después) lo configuramos.

Tenemos que indicar desde qué botón parte el popover. En nuestro caso es el botón derecho de la barra de navigación, aunque también se puede indicar cualquier vista en lugar de un botón. Finalmente indicamos que el _popover_ delegará en nuestro controlador.

Ahora sólo nos queda implementar el método `opcionSeleccionada` en `ViewController.swift`:

<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">opcionSeleccionada</span><span class="p">(</span><span class="n">nombreOpcion</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Comprobamos que se recibe aquí la opción seleccionada. Aquí ya podríamos hacer lo que queramos con el valor recibido.</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Seleccionado </span><span class="si">\(</span><span class="n">nombreOpcion</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>

    <span class="c1">// Ocultamos el popover</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">dismiss</span><span class="p">(</span><span class="n">animated</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="n">completion</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

Compila y ejecuta el programa en un iPad. Cuando pulsamos fuera de la tabla, el popover desaparece, y si pulsamos en una opción podremos ver (por `print`) la opción pulsada. También verás que el popover es un poco grande para el contenido que muestra. Podemos cambiar su tamaño añadiendo la siguiente línea en `accionOpciones`, justo después de asignar `controller?.delegate = self`:

<div class="highlight"><pre><span></span><code><span class="n">controller</span><span class="p">.</span><span class="n">preferredContentSize</span> <span class="p">=</span> <span class="n">CGSize</span><span class="p">(</span><span class="n">width</span><span class="p">:</span> <span class="mi">250</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mi">135</span><span class="p">)</span>
</code></pre></div>

Vuelve a ejecutar el programa y verás como el tamaño del popover es más adecuado. Prueba también a ejecutar la aplicación en un _iphone 5S_. Verás que el comportamiento de la tabla es como el de un _action sheet_ a pantalla completa.

Como puedes ver, en la última línea del método `accionOpciones` hemos indicado que el delegado del popover (para el protocolo `UIPopoverPresentationControllerDelegate`) es nuestra clase. Sin embargo, no hemos implementado ningún método de este protocolo por lo que esta línea podríamos eliminarla y seguiría funcionando correctamente. No obstante, en caso de que quisiéramos realizar alguna acción cuando el popover desaparezca, tendríamos que usar el protocolo `UIPopoverPresentationControllerDelegate`, que tiene métodos para acciones de cancelación o de movimiento en pantalla del popover, como por ejemplo `popoverPresentationControllerDidDismissPopover` o `popoverPresentationControllerShouldDismissPopover`.
-->

<h2 id="split-view">Split View</h2>
<p>Un <strong>Split View</strong> o <em>Vista Divida</em> es una combinación de dos vistas, una maestra y una detalle.</p>
<p>En modo horizontal (<em>landscape</em>), la primera vista (maestra) es equivalente en anchura a una vista de iPhone en orientación vertical. La vista maestra se suele usar para la navegación principal dentro de un listado de opciones de la aplicación. </p>
<p>Por otro lado, la vista de la derecha (detalle), que corresponde a la porción más grande de la pantalla, mostrará la información en detalle del elemento que hayamos seleccionado en la vista de maestra. </p>
<p><img alt="Split View" src="gitbook/assets/splitview_landscape.png" title="Split View en modo horizontal" /></p>
<p>Por defecto, en modo vertical (<em>portrait mode</em>) un <em>Split View</em> cambia y puede verse como la vista detalle con un icono que muestra la vista maestra. Por tanto, sólo una de las vistas ocupará toda la pantalla de un iPad, como podemos ver en la siguiente imagen:</p>
<p><img alt="Split View vertical" src="gitbook/assets/splitview_portrait.png" title="Split View vertical" /></p>
<ul>
<li>Es muy recomendable que los <em>Split View Controllers</em>  sean sólo <em>root</em> controllers, por lo que sólo debemos usarlos en la primera pantalla.</li>
<li>No podemos añadir un <em>Split View Controller</em> dentro de un <em>Navigation Controller</em>. Esto implica que si lo programamos nosotros en lugar de usar la plantilla perderemos los botones de navegación. </li>
</ul>
<p>Incorporar un controlador <em>Split View</em> a nuestra aplicación es bastante sencillo aunque no es trivial. Vamos a explicarlo con una app de ejemplo que mostrará información sobre películas. En modo horizontal (<em>landscape</em>) tendremos un listado en forma de tabla con todas las películas en la parte izquierda del <em>Split View</em> y cuando seleccionemos una de ellas nos aparecerán sus detalles en la parte derecha. </p>
<!---
## Ejercicio 1 - SplitView

A pesar de que XCode nos da la opción de crear un proyecto de tipo _Master-Detail Application_ en el que tendremos un controlador `UISplitView` desde el inicio, nosotros vamos a crearlo desde cero, ya que es interesante (y a veces necesario) saber cómo incorporar un _Split View_ sin necesidad de usar plantillas.

Por tanto, vamos a empezar creando un proyecto usando la plantilla `Single View Application`, seleccionando en la lista de la familia de dispositivos _iPad_. Guardamos el proyecto con el nombre `ejercicio_splitview`. Si lo ejecutamos con el simulador de iPad, nos aparecerá una pantalla en blanco.

### Creando las clases de las vistas

Vamos a crear las dos vistas del _Split View_: por un lado una vista de tipo `UITableViewController`, que será la vista maestra, y por otro lado una de tipo `ViewController` para la vista detalle.

Comenzamos con la vista maestra, creando un nuevo fichero con _File > New > File > Cocoa Touch_. Lo llamaremos `MasterViewController`, subclase de `UITableViewController` y **marcaremos** _Also create Xib_.

Ahora abrimos el fichero `MasterViewController.swift` y modificamos algunos métodos de la clase: en  `numberOfSections` devolveremos `1`, y en el número de filas (_rows_) devolveremos `5`. De esta forma tendremos una tabla con cinco filas vacías para hacer una prueba rápida, más adelante introduciremos datos útiles. También necesitamos implementar el método `CellForRowAt`:

<div class="highlight"><pre><span></span><code><span class="kr">override</span> <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="kc">_</span> <span class="n">tableView</span><span class="p">:</span> <span class="bp">UITableView</span><span class="p">,</span> <span class="n">cellForRowAt</span> <span class="n">indexPath</span><span class="p">:</span> <span class="n">IndexPath</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="bp">UITableViewCell</span> <span class="p">{</span>
    <span class="c1">// Al no hacerlo desde el storyboard, tenemos que añadir esta línea:</span>
    <span class="n">tableView</span><span class="p">.</span><span class="n">register</span><span class="p">(</span><span class="bp">UITableViewCell</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">forCellReuseIdentifier</span><span class="p">:</span> <span class="s">&quot;TableViewCell&quot;</span><span class="p">)</span>

    <span class="kd">let</span> <span class="nv">cell</span> <span class="p">=</span> <span class="n">tableView</span><span class="p">.</span><span class="n">dequeueReusableCell</span><span class="p">(</span><span class="n">withIdentifier</span><span class="p">:</span> <span class="s">&quot;TableViewCell&quot;</span><span class="p">)</span><span class="o">!</span>

    <span class="n">cell</span><span class="p">.</span><span class="n">textLabel</span><span class="p">?.</span><span class="n">text</span> <span class="p">=</span> <span class="s">&quot;Fila </span><span class="si">\(</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="si">)</span><span class="s">&quot;</span>

    <span class="k">return</span> <span class="n">cell</span>
<span class="p">}</span>
</code></pre></div>

Ahora pasamos a crear la vista detalle, `DetailViewController`. Para ello hacemos click en _File > New > File > Cocoa Touch_ y le ponemos el nombre `DetailViewController`, subclase de `UIViewController` y **marcando** _Also create  Xib file_. Esta vista será la que corresponda a la parte derecha (detalle) del _Split View_.

Para probarla vamos a poner algo dentro de esta vista de detalle. Abrimos `DetailViewControler.xib`, arrastramos un _label_ y escribimos por ejemplo `Hola Mundo!`. Con esto ya tenemos las dos vistas creadas y listas para asignarlas a nuestro _Split View_.

> Para colocar la etiqueta selecciona en la barra de abajo, en `View as`, un iPad en lugar de un iPhone.

### Asignando las vistas

Una vez que tenemos creadas la vista _Master_ y la vista _Detail_ vamos a crear un objeto de tipo `UISplitViewController` para asignarle ambas vistas. Esto lo haremos reemplazando el siguiente método en `AppDelegate.swift`.

<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">application</span><span class="p">(</span><span class="kc">_</span> <span class="n">application</span><span class="p">:</span> <span class="bp">UIApplication</span><span class="p">,</span> <span class="n">didFinishLaunchingWithOptions</span>  <span class="n">launchOptions</span><span class="p">:</span> <span class="p">[</span><span class="n">UIApplicationLaunchOptionsKey</span><span class="p">:</span> <span class="nb">Any</span><span class="p">]?)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">master</span> <span class="p">=</span> <span class="n">MasterViewController</span><span class="p">(</span><span class="n">nibName</span><span class="p">:</span> <span class="s">&quot;MasterViewController&quot;</span><span class="p">,</span> <span class="n">bundle</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nv">detail</span> <span class="p">=</span> <span class="n">DetailViewController</span><span class="p">(</span><span class="n">nibName</span><span class="p">:</span> <span class="s">&quot;DetailViewController&quot;</span><span class="p">,</span> <span class="n">bundle</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span>

    <span class="kd">let</span> <span class="nv">splitViewController</span> <span class="p">=</span> <span class="bp">UISplitViewController</span><span class="p">()</span>
    <span class="n">splitViewController</span><span class="p">.</span><span class="n">viewControllers</span> <span class="p">=</span> <span class="p">[</span><span class="n">master</span><span class="p">,</span> <span class="n">detail</span><span class="p">]</span>

    <span class="kc">self</span><span class="p">.</span><span class="n">window</span><span class="p">?.</span><span class="n">rootViewController</span> <span class="p">=</span> <span class="n">splitViewController</span>

    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></div>

> Nota. La programación de un `Split View Controller` se puede realizar de muchas formas. Esta que estamos explicando es la más sencilla y clara. Otra manera sería añadiendo a la vista principal de la aplicación un objeto de tipo `Split View Controller` desde el Interface Builder, pero es más complicado.


Ahora ya podemos compilar y ejecutar el proyecto y ver los resultados. Si giramos el simulador podremos observar como se adapta el _Split View_ de forma automática.

Sin embargo, los botones de navegación que salen cuando creamos un proyecto con la plantilla `Master-View Controller` no aparecen en nuestro ejemplo. Hay que tener en cuenta dos aspectos importantes de los _Split View Controllers_:

* Es muy recomendable que los _Split View Controllers_  sean sólo root controllers, por lo que normalmente sólo debemos usarlos en la primera pantalla.
* No podemos añadir un _Split View Controller_ dentro de un _Navigation Controller_. Esto implica que si lo programamos nosotros en lugar de usar la plantilla perderemos los botones de navegación. Por tanto, tendremos que implementar nosotros la lógica de navegación, como vamos a hacer a continuación.

### Programando el modelo de datos

El siguiente paso es programar nuestro modelo de datos. Esto se podría hacer utilizando algún método de persistencia como _ficheros_, _SQLite_ o _Core Data_, pero por simplificar no usaremos ninguno de estos y crearemos los objetos en memoria directamente.

> Si quieres guardar datos de la aplicación, estos no ocupan mucho espacio (por ejemplo, las preferencias del usuario) y quieres hacerlo de forma sencilla, puedes usar el diccionario `NSUserDefaults` para almacenarlos. Este diccionario también puede sincronizarse con iCloud.

Vamos a programar la clase que representará cada tablet que queremos mostrar. Para ello hacemos click en _File > New > File > Swift File_ y guardamos el fichero con el nombre `Tablet`. Ahora abrimos el archivo creado y escribimos el siguiente código:

<div class="highlight"><pre><span></span><code><span class="kd">import</span> <span class="nc">UIKit</span>

<span class="kd">class</span> <span class="nc">Tablet</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">nombre</span><span class="p">,</span> <span class="n">procesador</span><span class="p">,</span> <span class="n">grafica</span><span class="p">,</span> <span class="n">memoria</span><span class="p">,</span> <span class="n">pantalla</span><span class="p">,</span> <span class="n">resolucion</span><span class="p">,</span> <span class="n">imagen</span> <span class="p">:</span> <span class="nb">String</span>

    <span class="kd">init</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">procesador</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">grafica</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">memoria</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">pantalla</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">resolucion</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">imagen</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">nombre</span> <span class="p">=</span> <span class="n">nombre</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">procesador</span> <span class="p">=</span> <span class="n">procesador</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">grafica</span> <span class="p">=</span> <span class="n">grafica</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">memoria</span> <span class="p">=</span> <span class="n">memoria</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">pantalla</span> <span class="p">=</span> <span class="n">pantalla</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">resolucion</span> <span class="p">=</span> <span class="n">resolucion</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">imagen</span> <span class="p">=</span> <span class="n">imagen</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

Ya tenemos el modelo de datos definido. Para continuar vamos a implementar la vista maestra del _Split View_.

### Programando la vista maestra

La parte izquierda del _Split View_ es una tabla donde aparecerán los nombres de los distintos modelos de tablets. Para implementar esto añadiremos una nueva variable a la clase `MasterViewController`, que será un _array_ de objetos `Tablet`. Abrimos `MasterViewController.swift` y escribimos lo siguiente:


<div class="highlight"><pre><span></span><code><span class="kd">var</span> <span class="nv">tablets</span> <span class="p">=</span> <span class="p">[</span><span class="n">Tablet</span><span class="p">]()</span>
</code></pre></div>

Ahora añadimos las siguientes líneas:

<div class="highlight"><pre><span></span><code><span class="c1">// En numberOfRows, cambia el 5 por lo siguiente:</span>
<span class="k">return</span> <span class="kc">self</span><span class="p">.</span><span class="n">tablets</span><span class="p">.</span><span class="bp">count</span>

<span class="c1">// En el constructor de la tabla, antes de return cell</span>
<span class="kd">let</span> <span class="nv">tablet</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">tablets</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">]</span>
<span class="n">cell</span><span class="p">.</span><span class="n">textLabel</span><span class="p">?.</span><span class="n">text</span> <span class="p">=</span> <span class="n">tablet</span><span class="p">.</span><span class="n">nombre</span>
</code></pre></div>

Con esto ya tenemos la vista maestra casi terminada. Sólo nos falta crear los objetos de tipo _Tablet_. Para ello abrimos `MasterViewController.swift` y añadimos el siguiente método privado:

<div class="highlight"><pre><span></span><code><span class="kd">private</span> <span class="kd">func</span> <span class="nf">crearListaTablets</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">ipad2</span> <span class="p">=</span> <span class="n">Tablet</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="s">&quot;iPad2&quot;</span><span class="p">,</span>
                <span class="n">procesador</span><span class="p">:</span> <span class="s">&quot;Apple A5 de doble núcleo a 1 GHz&quot;</span><span class="p">,</span>
                <span class="n">grafica</span><span class="p">:</span> <span class="s">&quot;PowerVR SGX543MP2&quot;</span><span class="p">,</span>
                <span class="n">memoria</span><span class="p">:</span> <span class="s">&quot;512 MB&quot;</span><span class="p">,</span>
                <span class="n">pantalla</span><span class="p">:</span> <span class="s">&quot;9,7 pulgadas&quot;</span><span class="p">,</span>
                <span class="n">resolucion</span><span class="p">:</span> <span class="s">&quot;1024 × 768 píxeles (132 ppp)&quot;</span><span class="p">,</span>
                <span class="n">imagen</span><span class="p">:</span> <span class="s">&quot;ipad2.jpg&quot;</span><span class="p">)</span>

    <span class="kd">let</span> <span class="nv">motorola</span> <span class="p">=</span> <span class="n">Tablet</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="s">&quot;Motorola Xoom&quot;</span><span class="p">,</span>
                <span class="n">procesador</span><span class="p">:</span> <span class="s">&quot;NVidia Tegra 2 de doble núcleo a 1 GHz&quot;</span><span class="p">,</span>
                <span class="n">grafica</span><span class="p">:</span> <span class="s">&quot;GeForce GPU 333&quot;</span><span class="p">,</span>
                <span class="n">memoria</span><span class="p">:</span> <span class="s">&quot;1 GB&quot;</span><span class="p">,</span> <span class="n">pantalla</span><span class="p">:</span> <span class="s">&quot;10,1 pulgadas&quot;</span><span class="p">,</span>
                <span class="n">resolucion</span><span class="p">:</span> <span class="s">&quot;1280 × 800 píxeles (150 ppp)&quot;</span><span class="p">,</span>
                <span class="n">imagen</span><span class="p">:</span> <span class="s">&quot;motorola.jpg&quot;</span><span class="p">)</span>

    <span class="kd">let</span> <span class="nv">hp</span> <span class="p">=</span> <span class="n">Tablet</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="s">&quot;HP TouchPad&quot;</span><span class="p">,</span>
                <span class="n">procesador</span><span class="p">:</span> <span class="s">&quot;Qualcomm Snapdragon de doble núcleo a 1,2 GHz&quot;</span><span class="p">,</span>
                <span class="n">grafica</span><span class="p">:</span> <span class="s">&quot;Adreno 220&quot;</span><span class="p">,</span>
                <span class="n">memoria</span><span class="p">:</span> <span class="s">&quot;1 GB&quot;</span><span class="p">,</span>
                <span class="n">pantalla</span><span class="p">:</span> <span class="s">&quot;9,7 pulgadas&quot;</span><span class="p">,</span>
                <span class="n">resolucion</span><span class="p">:</span> <span class="s">&quot;1024 × 768 píxeles (132 ppp)&quot;</span><span class="p">,</span>
                <span class="n">imagen</span><span class="p">:</span> <span class="s">&quot;hp.jpg&quot;</span><span class="p">)</span>

    <span class="kd">let</span> <span class="nv">blackBerry</span> <span class="p">=</span> <span class="n">Tablet</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="s">&quot;BlackBerry PlayBook&quot;</span><span class="p">,</span>
                <span class="n">procesador</span><span class="p">:</span> <span class="s">&quot;Procesador de doble núcleo a 1 GHz&quot;</span><span class="p">,</span>
                <span class="n">grafica</span><span class="p">:</span> <span class="s">&quot;Desconocido&quot;</span><span class="p">,</span>
                <span class="n">memoria</span><span class="p">:</span> <span class="s">&quot;1 GB&quot;</span><span class="p">,</span>
                <span class="n">pantalla</span><span class="p">:</span> <span class="s">&quot;7 pulgadas&quot;</span><span class="p">,</span>
                <span class="n">resolucion</span><span class="p">:</span> <span class="s">&quot;1024 × 600 píxeles&quot;</span><span class="p">,</span>
                <span class="n">imagen</span><span class="p">:</span> <span class="s">&quot;blackberry.jpg&quot;</span><span class="p">)</span>

    <span class="kc">self</span><span class="p">.</span><span class="n">tablets</span> <span class="p">=</span> <span class="p">[</span><span class="n">ipad2</span><span class="p">,</span> <span class="n">motorola</span><span class="p">,</span> <span class="n">hp</span><span class="p">,</span> <span class="n">blackBerry</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div>

Haremos la llamada a este método desde `viewDidLoad` de `MasterViewController` de forma que se inicialice el vector de tablets cuando creemos la vista:

<div class="highlight"><pre><span></span><code><span class="kc">self</span><span class="p">.</span><span class="n">crearListaTablets</span><span class="p">()</span>
</code></pre></div>

Las imágenes de las tablets las podemos descargar desde <a href="gitbook/assets/imagenes_tablets.zip">aquí</a>. Una vez descargadas, las descomprimimos y las arrastramos a los _Assets_.

Compilamos y ejecutamos. Como se puede ver, ya tenemos los nombres en la tabla (cuando el dispositivo está girado), pero al no haber barra de navegación el contenido de la tabla se superpone a la información de la barra superior (_status bar_).

Añade un `UINavigationBar` encima de la vista `MasterViewController.xib` con el título _Tablet models_ (cuesta "apuntar" pero debería poder hacerse), recompila y si todo ha ido bien nos debe aparecer lo siguiente:

![Split View v1](splitview_v1.png "Split View v1")



### Programando la vista detalle

Una vez programado el menu del _Split View_, vamos a diseñar y programar la parte derecha, es decir, la vista detalle. Abrimos el fichero `DetailViewController.xib`, borramos el `UILabel` creado anteriormente y diseñamos la vista de la forma que se muestra en la siguiente imagen:

![Estructura vista detalle Split View](splitview_detalle1.png "Estructura vista detalle Split View")

Como podemos ver, se deben añadir los siguientes componentes a la vista detalle:

* UIImageView  `imagen`
* UILabel `labelNombre`
* UILabel `labelProcesador`
* UILabel `labelGrafica`
* UILabel `labelMemoria`
* UILabel `labelPantalla`
* UILabel `labelResolucion`


Abrimos el fichero `DetailViewController.swift` y conectamos todos estos _outlets_.

> Cuando tenemos muchos _outlets_ similares (por ejemplo, muchos `UILabel`), podemos crear una colección de _outlets_ con el _Interface Builder_. Internamente esta colección se almacena como un array y podemos acceder a sus elementos. Desafortunadamente, el orden dentro de este array no se respeta (no se sigue el orden de asignación), por lo que las colecciones sólo se recomiendan cuando queramos acceder o cambiar los atributos de **todos** los _outlets_ de la colección (por ejemplo, para cambiarles el color a todos).

En `DetailViewController.swift`, añadimos una variable de la clase `Tablet`, que contendrá los datos de la tableta cuyo detalle queremos ver:

<div class="highlight"><pre><span></span><code><span class="kd">var</span> <span class="nv">tablet</span> <span class="p">:</span> <span class="n">Tablet</span><span class="p">?</span>
</code></pre></div>

### Enlazando las dos vistas

Existen muchas formas de programar la correspondencia entre la vista de la izquierda con la de la derecha. En nuestro caso, vamos a crear un objeto delegado que recibe una petición cuando se selecciona una fila en la tabla maestra.

Para ello vamos a definir un protocolo con un sólo método que llamaremos `selectedTabletChanged`. El controlador de la vista detalle se encargará de implementar dicho método, y el controlador maestro será el que realize la llamada mediante un delegado.

En el fichero `MasterViewController.swift`:

* Añadimos el protocolo `TabletSelectionDelegate`:

<div class="highlight"><pre><span></span><code><span class="kd">protocol</span> <span class="nc">TabletSelectionDelegate</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">tabletSelectionChanged</span><span class="p">(</span><span class="n">tablet</span> <span class="p">:</span> <span class="n">Tablet</span><span class="p">?)</span>
<span class="p">}</span>
</code></pre></div>

* Añadimos el objeto delegado:

<div class="highlight"><pre><span></span><code>  <span class="kd">var</span> <span class="nv">delegate</span><span class="p">:</span><span class="n">TabletSelectionDelegate</span><span class="p">?</span>
</code></pre></div>

* Finalmente añadimos el siguiente método que invoca a `tabletSelectionChanged` cuando se pulsa sobre una celda:

<div class="highlight"><pre><span></span><code><span class="kr">override</span> <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="kc">_</span> <span class="n">tableView</span><span class="p">:</span> <span class="bp">UITableView</span><span class="p">,</span> <span class="n">didSelectRowAt</span> <span class="n">indexPath</span><span class="p">:</span> <span class="n">IndexPath</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">tablet</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">tablets</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">]</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">delegate</span><span class="p">?.</span><span class="n">tabletSelectionChanged</span><span class="p">(</span><span class="n">tablet</span><span class="p">:</span> <span class="n">tablet</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

Ya queda menos. Vamos a modificar la clase detalle `DetailViewController.swift` para adoptar el protocolo anterior y también el del _split view_:


<div class="highlight"><pre><span></span><code><span class="kd">class</span> <span class="nc">DetailViewController</span><span class="p">:</span> <span class="bp">UIViewController</span><span class="p">,</span> <span class="n">TabletSelectionDelegate</span><span class="p">,</span> <span class="bp">UISplitViewControllerDelegate</span>
</code></pre></div>

En `DetailViewController.swift` editamos el método `viewDidLoad` para asignar el texto de las etiquetas y la imagen, y también añadiremos la implementación del método del protocolo:

<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">tabletToView</span><span class="p">()</span> <span class="p">{</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">labelNombre</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">tablet</span><span class="p">?.</span><span class="n">nombre</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">labelProcesador</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">tablet</span><span class="p">?.</span><span class="n">grafica</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">labelGrafica</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">tablet</span><span class="p">?.</span><span class="n">memoria</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">labelMemoria</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">tablet</span><span class="p">?.</span><span class="n">pantalla</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">labelPantalla</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">tablet</span><span class="p">?.</span><span class="n">procesador</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">labelResolucion</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">tablet</span><span class="p">?.</span><span class="n">resolucion</span>

    <span class="kc">self</span><span class="p">.</span><span class="n">imagen</span><span class="p">.</span><span class="n">image</span> <span class="p">=</span> <span class="bp">UIImage</span><span class="p">(</span><span class="n">named</span><span class="p">:(</span><span class="kc">self</span><span class="p">.</span><span class="n">tablet</span><span class="p">?.</span><span class="n">imagen</span><span class="p">)</span><span class="o">!</span><span class="p">)</span>
<span class="p">}</span>

<span class="kr">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
    <span class="kc">super</span><span class="p">.</span><span class="n">viewDidLoad</span><span class="p">()</span>

    <span class="k">if</span> <span class="kc">self</span><span class="p">.</span><span class="n">tablet</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">tabletToView</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">splitViewController</span><span class="p">?.</span><span class="n">delegate</span> <span class="p">=</span> <span class="kc">self</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">tabletSelectionChanged</span><span class="p">(</span><span class="n">tablet</span><span class="p">:</span> <span class="n">Tablet</span><span class="p">?)</span> <span class="p">{</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">tablet</span> <span class="p">=</span> <span class="n">tablet</span><span class="p">;</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">tabletToView</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>

Finalmente, al final del método `didFinishLaunchingWithOptions` de la clase `AppDelegate.swift` asignamos el delegado que acabamos de crear:

<div class="highlight"><pre><span></span><code>  <span class="n">master</span><span class="p">.</span><span class="n">delegate</span> <span class="p">=</span> <span class="n">detail</span>
</code></pre></div>

Si está todo bien, al compilar y ejecutar el proyecto el _Split View_ debe funcionar:

![Split View terminado](splitview_v2.png "Split View terminado")

Sin embargo, si giramos ahora el iPad veremos que desaparece el menú de la izquierda y no podemos acceder a la vista maestra cuando estamos en orientación _portrait_. Para evitar esto, debemos hacer uso de un _popover_. Hablaremos con más detalle de este componente en el siguiente apartado, pero ahora debemos utilizarlo para mostrar una ventana con la información de la vista maestra. La programación de esta parte es muy sencilla y siempre se hace de la misma forma, ¡vamos a implementarlo!

### Añadiendo un Popover al Split View

La solución que propone _Apple_ al problema comentando anteriormente es añadir un _Toolbar_ con un _Button_ en la vista detalle del _Split View_, de forma que al pulsar sobre este botón aparezca un _Popover_ con la vista maestra. Para implementar esto debemos primero añadir un `Toolbar` dentro de la vista detalle.

Abrimos `DetailViewController.xib`, arrastramos un componente `UIToolbar` en la parte superior de la vista, y borramos su botón izquierdo (`Item`). Para que el _Toolbar_ quede bien debemos configurar sus _constraints_ de la siguiente forma:

![ToolBar size](splitview_popover_toolbarsize.png "ToolBar size")

Ahora hacemos añadimos estas dos variables al fichero `DetailViewController.swift`:

<div class="highlight"><pre><span></span><code><span class="kd">var</span> <span class="nv">popover</span> <span class="p">:</span> <span class="bp">UIPopoverController</span><span class="p">?</span>
<span class="kr">@IBOutlet</span> <span class="kr">weak</span> <span class="kd">var</span> <span class="nv">toolbar</span> <span class="p">:</span> <span class="bp">UIToolbar</span><span class="p">!</span>
</code></pre></div>

Enlaza la variable `UIToolBar` con su vista correspondiente. También debemos añadir los siguientes métodos a `DetailViewController.swift`:

<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">splitViewController</span><span class="p">(</span><span class="kc">_</span> <span class="n">svc</span><span class="p">:</span> <span class="bp">UISplitViewController</span><span class="p">,</span> <span class="n">willHide</span> <span class="n">aViewController</span><span class="p">:</span> <span class="bp">UIViewController</span><span class="p">,</span> <span class="n">with</span> <span class="n">barButtonItem</span><span class="p">:</span> <span class="bp">UIBarButtonItem</span><span class="p">,</span> <span class="k">for</span> <span class="n">pc</span><span class="p">:</span> <span class="bp">UIPopoverController</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">barButtonItem</span><span class="p">.</span><span class="n">title</span> <span class="p">=</span> <span class="s">&quot;Tablets&quot;</span>
    <span class="kd">var</span> <span class="nv">items</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">toolbar</span><span class="p">.</span><span class="n">items</span>
    <span class="n">items</span><span class="p">?.</span><span class="bp">insert</span><span class="p">(</span><span class="n">barButtonItem</span><span class="p">,</span> <span class="n">at</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">toolbar</span><span class="p">.</span><span class="n">setItems</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">animated</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">popover</span> <span class="p">=</span> <span class="n">pc</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">splitViewController</span><span class="p">(</span><span class="kc">_</span> <span class="n">svc</span><span class="p">:</span> <span class="bp">UISplitViewController</span><span class="p">,</span> <span class="n">willShow</span> <span class="n">aViewController</span><span class="p">:</span> <span class="bp">UIViewController</span><span class="p">,</span> <span class="n">invalidating</span> <span class="n">barButtonItem</span><span class="p">:</span> <span class="bp">UIBarButtonItem</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">items</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">toolbar</span><span class="p">.</span><span class="n">items</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">items</span><span class="p">?.</span><span class="bp">count</span><span class="p">)</span><span class="o">!</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="n">items</span><span class="p">?.</span><span class="n">remove</span><span class="p">(</span><span class="n">at</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">toolbar</span> <span class="p">.</span><span class="n">setItems</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">animated</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

Al final de `tabletSelectionChanged` añadimos la siguiente línea:

<div class="highlight"><pre><span></span><code><span class="kc">self</span><span class="p">.</span><span class="n">popover</span><span class="p">?.</span><span class="n">dismiss</span><span class="p">(</span><span class="n">animated</span><span class="p">:</span> <span class="kc">true</span><span class="p">)</span>
</code></pre></div>

No te preocupes por el _Warning (deprecated)_ que aparece al compilar, más adelante veremos por qué se produce. Si ejecutamos ahora la aplicación, al girar el dispositivo y situarlo en posición vertical aparecerá en la barra superior un botón. Si lo pulsamos nos debe salir el listado de tablets.

![SplitView con popover en iPad](splitview_popoverhorizontal.png "Splitview con popover en iPad (vista horizontal)")

Cuando el dispositivo está en _landscape_ el botón se oculta. Como puedes ver, en _portrait_ automáticamente se hace una animación de "cortina" cuando pulsamos el botón. Normalmente los _popover_ se muestran con una animación distinta, pero en este caso, al usarlo dentro de un `UISplitView` iOS cambia su comportamiento. Veremos a continuación cómo usar un popover estándar.
-->

<h2 id="ejercicio-app-universal-con-uisplitviewcontroller">Ejercicio: App universal con <em>UISplitViewController</em></h2>
<p>Para empezar vamos a programar una app básica con <em>UISplitViewController</em> adaptada a distintos modelos y tamaños de dispositivo.</p>
<p>Crea un nuevo proyecto llamado <code>ejercicio_peliculas</code> con <em>iOS &gt; App</em> y <em>storyboard</em>. Selecciona un iPad en la barra de abajo para ir haciendo el diseño del <em>storyboard</em> en este dispositivo, y el mismo modelo en el simulador (en la barra superior) para ejecutar el programa. </p>
<p>Arrastra un <em>UISplitViewController</em> al <em>storyboard</em>. </p>
<p>Mueve la flecha de inicio de la aplicación para que el nuevo controlador sea el primero cuando arranque la app y borra el controlador antiguo del <em>storyboard</em> y su fichero <code>ViewController.swift</code>. El <em>storyboard</em> debería quedar así:</p>
<p><img alt="Split View inicial" src="gitbook/assets/splitViewInit_storyboard.png" title="Split View inicial" /></p>
<p>Como puedes ver, de nuestro <em>splitViewController</em> salen dos vistas: Una maestra (la tabla) que está controlada por un <em>navigation controller</em>, y una secundaria (detalle) enlazada al <em>splitViewController</em>. Si pinchas en los atributos de este controlador podrás ver algo como esto:</p>
<p><img alt="Split View atributos" src="gitbook/assets/splitviewcontroller_attributes.png" title="Split View atributos" /></p>
<p>Un atributo muy importante es el estilo (<em>style</em>). Los <em>splitview</em> pueden tener <strong>dos o tres</strong> columnas. Lo más común es dos, pero puedes hacer una app de tres columnas y que por tanto estará asociada a tres vistas para mostrar información de detalle de segundo nivel. </p>
<p>Puedes encontrar más información sobre <em>splitView</em> en <a href="https://developer.apple.com/documentation/uikit/uisplitviewcontroller">este enlace</a>.</p>
<p>Ya tenemos una tabla y una vista detalle, pero nos faltan los ficheros de código de los controladores. Para controlar la tabla crea un nuevo archivo con <code>File &gt; New &gt; File &gt; Cocoa touch &gt; UITableViewController</code> y llámalo <code>TableViewController</code>. Asigna el controlador a la vista:</p>
<p><img alt="Asignación Table View Controller" src="gitbook/assets/splitview_tvc.png" title="Asignación Table View Controller" /></p>
<p>Creamos otro controlador para la vista detalle, al que llamaremos <code>DetailViewController</code>, subclase de <code>UIViewController</code>, y al igual que el anterior lo asignamos en el <em>storyboard</em>.</p>
<p>Podemos ejecutar la aplicación. En un iPad veremos que en modo <em>Portrait</em> sólo se muestra la vista detalle. Pinchando en el icono superior se muestra también la maestra. Si rotamos se muestran ambas, aunque todavía están vacías. </p>
<p>Ahora vamos a añadir datos a la tabla. Para esto, inicializa  el siguiente array en <code>TableViewController</code>:</p>
<div class="highlight"><pre><span></span><code>    <span class="kd">let</span> <span class="nv">contenido</span> <span class="p">=</span> <span class="p">[</span><span class="s">&quot;Uno&quot;</span><span class="p">,</span><span class="s">&quot;dos&quot;</span><span class="p">,</span><span class="s">&quot;tres&quot;</span><span class="p">]</span>
</code></pre></div>
<p>Borra el método <code>numberOfSections</code> y modifica los siguientes métodos:</p>
<div class="highlight"><pre><span></span><code>    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="kc">_</span> <span class="n">tableView</span><span class="p">:</span> <span class="bp">UITableView</span><span class="p">,</span> <span class="n">numberOfRowsInSection</span> <span class="n">section</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">contenido</span><span class="p">.</span><span class="bp">count</span>
    <span class="p">}</span>

    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="kc">_</span> <span class="n">tableView</span><span class="p">:</span> <span class="bp">UITableView</span><span class="p">,</span> <span class="n">cellForRowAt</span> <span class="n">indexPath</span><span class="p">:</span> <span class="n">IndexPath</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="bp">UITableViewCell</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">cell</span> <span class="p">=</span> <span class="n">tableView</span><span class="p">.</span><span class="n">dequeueReusableCell</span><span class="p">(</span><span class="n">withIdentifier</span><span class="p">:</span> <span class="s">&quot;Cell&quot;</span><span class="p">,</span> <span class="k">for</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">)</span>

        <span class="c1">// Configure the cell...</span>
        <span class="n">cell</span><span class="p">.</span><span class="n">textLabel</span><span class="p">!.</span><span class="n">text</span> <span class="p">=</span> <span class="n">contenido</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">cell</span>
    <span class="p">}</span>
</code></pre></div>
<p>Recuerda que, al igual que en el ejercicio de la barra de búsqueda, debemos registrar el identificador de la celda en nuestro <code>TableViewCell</code>:</p>
<p><img alt="Identificador TableViewCell" src="gitbook/assets/splitview_tvcell.png" title="Identificador TableViewCell" /></p>
<p>De momento la vista detalle no tiene nada. Vamos a añadirle una etiqueta en el centro, ajustándola horizontalmente y verticalmente:</p>
<p><img alt="Vista detalle" src="gitbook/assets/splitView_dvc.png" title="Vista detalle" /></p>
<p>Conectamos la etiqueta con <code>IBOutlet</code> a nuestro controlador <code>DetailViewController</code>. Lo llamamos <code>etiqueta</code>:</p>
<div class="highlight"><pre><span></span><code>    <span class="kr">@IBOutlet</span> <span class="kr">weak</span> <span class="kd">var</span> <span class="nv">etiqueta</span><span class="p">:</span> <span class="bp">UILabel</span><span class="p">!</span>
</code></pre></div>
<p>Si ejecutamos la app veremos que se muestran ya elementos en la tabla y la vista detalle, aunque la idea es que esta  cambie cuando se seleccione una celda de la vista maestra. </p>
<p>Para esto tenemos que comunicar el controlador maestro con el detalle. Una forma sencilla de implementar esto es en el método <code>didSelectRowAt</code>:</p>
<div class="highlight"><pre><span></span><code>    <span class="kr">override</span> <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="kc">_</span> <span class="n">tableView</span><span class="p">:</span> <span class="bp">UITableView</span><span class="p">,</span> <span class="n">didSelectRowAt</span> <span class="n">indexPath</span><span class="p">:</span> <span class="n">IndexPath</span><span class="p">)</span> <span class="p">{</span>

        <span class="k">if</span> <span class="kd">let</span> <span class="nv">indexPath</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">tableView</span><span class="p">.</span><span class="n">indexPathForSelectedRow</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nv">object</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">contenido</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">]</span>

            <span class="c1">// Conexión con el controlador detalle</span>
            <span class="kd">let</span> <span class="nv">detailViewController</span> <span class="p">=</span> <span class="n">splitViewController</span><span class="p">!.</span><span class="n">viewController</span><span class="p">(</span><span class="k">for</span><span class="p">:</span> <span class="p">.</span><span class="n">secondary</span><span class="p">)</span> <span class="k">as</span><span class="p">?</span> <span class="n">DetailViewController</span>
            <span class="n">detailViewController</span><span class="p">?.</span><span class="n">etiqueta</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="n">object</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<p>Como puedes ver, hemos accedido al controlador <code>splitViewController</code>, y dentro de este al secundario (la vista detalle) que es de la clase <code>DetailViewController</code>. Ahora podemos acceder al <code>Outlet</code> que habíamos enlazado y ejecutar la app:</p>
<p><img alt="Primera versión SplitViewController iPad" src="gitbook/assets/splitview_firstversion_ipad.png" title="Primera versión splitview iPad" /></p>
<p>Como puedes ver, si rotas el dispositivo las dos vistas aparecen lado a lado. Ahora ejecuta el programa en un iPhone 14. Verás que el aspecto es distinto:</p>
<p><img alt="Primera versión SplitViewController iPhone" src="gitbook/assets/splitview_firstversion_iphone.png" title="Primera versión splitview iPhone" /></p>
<p>Sólo se muestra la vista maestra, y si pulsamos sobre una celda no se pasa a la vista detalle. El problema es que, aunque hemos cambiado la segunda vista internamente, esta no se ve.</p>
<p>Para que aparezca añadimos lo siguiente tras la conexión con el controlador detalle (en <code>didSelectRowAt</code>):</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Si el controlador detalle no está presentado lo mostramos</span>
<span class="k">if</span> <span class="o">!</span><span class="n">detailViewController</span><span class="p">!.</span><span class="n">isBeingPresented</span> <span class="p">{</span>
    <span class="n">splitViewController</span><span class="p">!.</span><span class="n">showDetailViewController</span><span class="p">(</span><span class="n">detailViewController</span><span class="p">!,</span> <span class="n">sender</span><span class="p">:</span> <span class="kc">self</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>Ejecuta ahora la app en iPhone e iPad, debería funcionar correctamente con ambos y en cualquier orientación y tamaño.</p>
<h2 id="ejercicio-peliculas">Ejercicio Películas</h2>
<p>Vamos a programar un ejemplo de aplicación completa usando  <em>SplitViewController</em> con algunas vistas comunes y otras diferenciadas en función del tamaño. Cuando tengamos la versión final del programa, en la vista maestra aparecerá un listado de títulos de películas y la vista detalle mostrará los detalles de la película seleccionada, con el título, un texto descriptivo, el año y una imagen.</p>
<h3 id="anadir-el-modelo-de-datos">Añadir el modelo de datos</h3>
<p>Partimos el proyecto anterior <code>ejercicio_peliculas</code> modificándolo para  guardar películas, por lo que vamos a implementar un modelo de datos. Para esto creamos una nueva clase <code>Pelicula</code> mediante <em>File &gt; New &gt; File &gt; Swift file</em>. Añadimos estos contenidos:</p>
<div class="highlight"><pre><span></span><code><span class="kd">import</span> <span class="nc">UIKit</span>

<span class="kd">class</span> <span class="nc">Pelicula</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">titulo</span> <span class="p">:</span> <span class="nb">String</span>
    <span class="kd">var</span> <span class="nv">caratula</span> <span class="p">:</span> <span class="nb">String</span>
    <span class="kd">var</span> <span class="nv">fecha</span> <span class="p">:</span> <span class="nb">String</span>
    <span class="kd">var</span> <span class="nv">descripcion</span> <span class="p">:</span> <span class="nb">String</span><span class="p">?</span>

    <span class="kd">init</span><span class="p">(</span><span class="n">titulo</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">caratula</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">fecha</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">descripcion</span><span class="p">:</span> <span class="nb">String</span><span class="p">?)</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">titulo</span> <span class="p">=</span> <span class="n">titulo</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">fecha</span> <span class="p">=</span> <span class="n">fecha</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">caratula</span> <span class="p">=</span> <span class="n">caratula</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">descripcion</span> <span class="p">=</span> <span class="n">descripcion</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>En <code>MasterViewController</code> sustituimos el array <code>contenido</code> que teníamos en el ejercicio de prueba por un array de Películas:</p>
<div class="highlight"><pre><span></span><code><span class="kd">var</span> <span class="nv">peliculas</span> <span class="p">=</span> <span class="p">[</span><span class="n">Pelicula</span><span class="p">]()</span>
</code></pre></div>
<p>Reemplazamos en este fichero todas las apariciones de <code>contenido</code> por <code>peliculas</code>, y de <code>object</code> por <code>pelicula</code>. </p>
<p>Vamos a añadir a la tabla una película de ejemplo. Para ello creamos el método <code>crearListaPeliculas</code> en la clase <code>MasterViewController</code>:</p>
<div class="highlight"><pre><span></span><code><span class="kd">func</span> <span class="nf">crearPeliculas</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">sentidoDeLaVida</span> <span class="p">=</span> <span class="n">Pelicula</span><span class="p">(</span><span class="n">titulo</span><span class="p">:</span> <span class="s">&quot;El sentido de la vida&quot;</span><span class="p">,</span> <span class="n">caratula</span><span class="p">:</span> <span class="s">&quot;sentido.jpg&quot;</span><span class="p">,</span> <span class="n">fecha</span><span class="p">:</span> <span class="s">&quot;1983&quot;</span><span class="p">,</span> <span class="n">descripcion</span><span class="p">:</span> <span class="s">&quot;Conjunto de episodios que muestran de forma disparatada los momentos más importantes del ciclo de la vida. Desde el nacimiento a la muerte, pasando por asuntos como la filosofía, la historia o la medicina, todo tratado con el inconfundible humor de los populares cómicos ingleses. El prólogo es un cortometraje independiente rodado por Terry Gilliam: Seguros permanentes Crimson.&quot;</span><span class="p">)</span>

    <span class="kc">self</span><span class="p">.</span><span class="n">peliculas</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">sentidoDeLaVida</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>
<p>Añadimos una llamada a este método al final de <code>viewDidLoad</code> para inicializar las películas.</p>
<!--- También necesitarás añadir <a href="gitbook/assets/sentido.jpg">esta imagen</a> a los `Assets`. -->

<p>Cambiamos también las siguientes lineas en el método <code>cellForRowAt</code> para mostrar en las celdas el título de la película:</p>
<div class="highlight"><pre><span></span><code><span class="n">cell</span><span class="p">.</span><span class="n">textLabel</span><span class="p">!.</span><span class="n">text</span> <span class="p">=</span> <span class="n">peliculas</span><span class="p">[</span><span class="n">indexPath</span><span class="p">.</span><span class="n">row</span><span class="p">].</span><span class="n">titulo</span>
</code></pre></div>
<p>A continuación modifica <code>didSelectRowAt</code> para usar los datos de las películas, de forma que la etiqueta de la vista detalle contenga siempre el título.</p>
<p>Ejecutamos el programa en un iPad, debería mostrar una película (sólo el título, ya que no hemos añadido la imagen ni otros datos) y funcionar correctamente.</p>
<h3 id="diseno-de-vista-y-controlador-detalle">Diseño de vista y controlador detalle</h3>
<p>Vamos a diseñar la vista detalle de manera independiente en función del tamaño del dispositivo, pero antes vamos a hacer un pequeño cambio. En el código que hemos visto anteriormente, cuando se selecciona una celda de la vista maestra se modifica directamente el contenido de la etiqueta de la vista detalle. Sin embargo, no es una buena política de diseño controlar una vista (en este caso, detalle) mediante el controlador de otra (maestra). </p>
<p>Para mejorar el diseño del código, en <code>DetailViewController</code> crea un método llamado <code>didChangePelicula</code> que reciba como parámetro una película y actualice la vista en función de los datos que tenga esta variable. De esta forma, desde  <code>TableViewController</code> podremos reemplazar la línea que asigna directamente la etiqueta por la llamada al método para que se haga dentro del controlador detalle:</p>
<div class="highlight"><pre><span></span><code><span class="c1">//  detailViewController?.etiqueta.text = pelicula</span>
<span class="n">detailViewController</span><span class="p">?.</span><span class="n">didChangePelicula</span><span class="p">(</span><span class="n">with</span><span class="p">:</span> <span class="n">pelicula</span><span class="p">)</span>
</code></pre></div>
<p>Selecciona la vista detalle en el <em>storyboard</em> y haz que sea como la que se muetra a continuación. Borra el <code>UILabel</code> que teníamos en el ejercicio de prueba (<code>etiqueta</code>) tanto de la vista como de las conexiones.</p>
<blockquote>
<p>Nota: Cuando borres algún elemento del interfaz que esté ya enlazado con el código con un <code>Outlet</code>, debes  eliminarlo también en el inspector de conexiones:
<img alt="Conexiones" src="gitbook/assets/peliculas_borrado_conexiones.png" title="conexiones" /></p>
</blockquote>
<p>Crea dos <code>UILabel</code> para el título y la fecha, y también añade un <code>UIImageView</code> y un <code>UITextView</code>:</p>
<p><img alt="Vista universal" src="gitbook/assets/movies_detail_first.png" title="Vista universal" /></p>
<p>Tras colocar los elementos, usa <em>Reset to suggested constraints</em> para que los <em>constraints</em> se ajusten de forma automática. Prueba también a visualizar la vista con otros dispositivos y orientaciones seleccionándolos en la barra inferior para ver que se adapten bien. </p>
<p>Ponemos el <code>UITextView</code> sólo como lectura para impedir que el usuario lo edite y salga un teclado cuando pulse sobre él. Para esto, desmarca <code>Editable</code> y <code>Selectable</code> en sus propiedades. </p>
<p><img alt="TextView properties" src="gitbook/assets/movies_textview.png" title="Propiedades textview" /></p>
<p>Conecta todos los elementos de la vista (<code>titulo</code>, <code>fecha</code>, <code>imagen</code> y <code>descripcion</code>) al controlador <code>DetailViewController</code> con <code>IBOutlets</code>. </p>
<p>Por último, descarga <a href="gitbook/assets/sentido.jpg">esta imagen</a> y arrástrala a los <em>Assets</em>. Modifica el método <code>didChangePelicula</code> para actualizar todos los <em>outlets</em>. En el caso de la imagen sería:</p>
<div class="highlight"><pre><span></span><code><span class="kc">self</span><span class="p">.</span><span class="n">imagen</span><span class="p">.</span><span class="n">image</span> <span class="p">=</span> <span class="bp">UIImage</span><span class="p">(</span><span class="n">named</span><span class="p">:</span> <span class="n">pelicula</span><span class="p">.</span><span class="n">caratula</span><span class="p">)</span>
</code></pre></div>
<p>Ejecuta el programa simulando distintos iPhone y iPad para ver los resultados. </p>
<p><img alt="Primera versión" src="gitbook/assets/movies_second.png" title="Primera versión" /></p>
<p>Seguro que en algunos casos no queda demasiado bien visualmente, pero de momento no es un problema. Vamos a ajustar mejor la vista en función del dispositivo. </p>
<h4 id="vista-compacta-y-stacks">Vista compacta y <em>stacks</em></h4>
<p>Empezaremos con el diseño para tamaños compactos. Si ejecutamos el programa en un iPhone SE en <em>landscape</em>, veremos que la imagen ocupa casi toda la pantalla y deja poco espacio para el texto. En apaisado y con tamaños compactos, lo ideal sería que la imagen estuviera a la izquierda y el texto a la derecha.</p>
<p>Existe una solución muy limpia para esto: usar <em>stacks</em> para agrupar las vistas y gestionar los giros.</p>
<p>Selecciona el <code>UIImageView</code> y el <code>UITextView</code>.  Ahora pulsa sobre el elemento <em>Stack</em>, el icono de la flecha hacia abajo en esta imagen, y selecciona <code>Stack View</code>:</p>
<p><img alt="Stack views" src="gitbook/assets/movies_stack.png" title="Stack views" /></p>
<p>Verás que las vistas se unen porque hemos creado un grupo con dos elementos. Como ves, un <em>stack</em> se usa para agrupar vistas y nos permite realizar ciertas acciones con ellas. Vamos a reajustar las <em>constraints</em> con este nuevo <em>Stack</em>, seleccionando <em>Reset to suggested constraints</em> para toda la vista detalle.  </p>
<p>Si ejecutamos el programa, el aspecto será más o menos como el que teníamos antes. Vamos a arreglar los problemas del giro, ya que cuando ponemos un iPhone en <em>landscape</em> la películano se visualiza bien. Para esto necesitamos conectar nuestro <em>Stack View</em> a <code>DetailViewController</code>. Llámalo <code>stackView</code>:</p>
<div class="highlight"><pre><span></span><code><span class="kr">@IBOutlet</span> <span class="kr">weak</span> <span class="kd">var</span> <span class="nv">stackView</span><span class="p">:</span> <span class="bp">UIStackView</span><span class="p">!</span>
</code></pre></div>
<p>Ahora vamos a añadir el siguiente método en <code>DetailViewController</code>:</p>
<div class="highlight"><pre><span></span><code><span class="kr">override</span> <span class="kd">func</span> <span class="nf">viewWillLayoutSubviews</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">view</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">&gt;=</span> <span class="n">view</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">stackView</span><span class="p">.</span><span class="n">axis</span> <span class="p">=</span> <span class="p">.</span><span class="n">horizontal</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="kc">self</span><span class="p">.</span><span class="n">stackView</span><span class="p">.</span><span class="n">axis</span> <span class="p">=</span> <span class="p">.</span><span class="n">vertical</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Este método se invoca cuando iOS detecta que hay que reajustar las vistas (por ejemplo cuando se realiza un giro). En el código indicamos que cuando tengamos más espacio horizontal que vertical nuestras vistas del <em>stack</em> deben reposicionarse. Además, lo harán con una animación. Prueba a ejecutar de nuevo el programa en un iPhone, debe verse así en <em>portrait</em>:</p>
<p><img alt="iPhone portrait stack" src="gitbook/assets/movies_detail_portrait.png" title="iPhone stack portrait" /></p>
<p>Y así en <em>landscape</em>:</p>
<p><img alt="iPhone landscape stack" src="gitbook/assets/movies_detail_landscape.png" title="iPhone stack landscape" /></p>
<p>Para saber más sobre lo que podemos hacer con la clase <code>UIStackView</code>, puedes consultar su referencia  <a href="https://developer.apple.com/reference/uikit/uistackview">en este enlace</a>.</p>
<h4 id="vista-regular">Vista regular</h4>
<p>Vamos a ajustar el <em>constraint</em> de la altura de la imagen para hacerla más grande en tamaños <code>wR-hR</code>, ya que en estos casos tenemos más espacio. Selecciona el <em>constraint</em> en la escena:</p>
<p><img alt="Constraints1" src="gitbook/assets/peliculas_heigh_constraint.png" title="Constraints (1/3)" /></p>
<p>Ahora pulsamos sobre el botón <code>+</code> de la altura, añadiendo una variación para <code>wR-hR</code>:</p>
<p><img alt="Constraints2" src="gitbook/assets/movies_constraint2.png" title="Constraints (2/3)" /></p>
<p>Y finalmente indicamos un valor más alto:</p>
<p><img alt="Constraints3" src="gitbook/assets/movies_constraint3.png" title="Constraints (3/3)" /></p>
<p>Ejecutamos el programa y vemos que funciona correctamente en iPad, en cualquier orientación. </p>
<p>Ahora vamos a cambiar el tipo de letra para <code>wR-hR</code>, de forma que se vea más grande en un iPad. Cambia sólo para tamaños <code>wR-hR</code> la fuente del texto a <em>System-20</em>, y la del título a <em>System-30</em> y en negrita:</p>
<p><img alt="Movies text" src="gitbook/assets/movies_text.png" title="Text size change" /></p>
<p>Finalmente vamos a dejar la fecha sólo en aquellos casos en los que tengamos suficiente espacio en anchura. Esto asumimos que ocurre en orientaciones <em>regular width</em> (<code>wR</code>), por lo que tenemos que desmarcarla para <em>compact widht</em> (<code>wC</code>) y cualquier altura (<code>h Any</code>):</p>
<p><img alt="Fecha" src="gitbook/assets/movies_fecha.png" title="Fecha sólo para wR" /></p>
<p>Esta etiqueta sólo se mostrará en los iPad cuando nuestra app esté a pantalla completa en cualquier orientación, o en en los iPhone grandes a pantalla completa y <em>landscape</em>.</p>
<!---
> **Muy importante:** En XCode 8, cuando está activado _Vary for traits_ **si se usa _Reset to Suggested constraints_ los cambios se aplicarán a las vistas de todos los tamaños, no sólo de los seleccionados**, a pesar de estar la barra en azul. Si cambiamos las _constraints_ como hemos visto antes sólo se aplicarán a las vistas del tamaño seleccionado. Asimismo, si **movemos** una vista o **cambiamos** uno de sus atributos directamente desde el Storyboard con la barra en azul, en XCode 8.0 se cambiará a **todos** los tamaños, no sólo para el actual. Esto último es un bug que está arreglado en XCode 8.1.
--->

<!--

Conectamos el `UILabel` al controlador y llamamos a la variable `fecha`. Añadimos lo siguiente a `configureView`:

<div class="highlight"><pre><span></span><code>  <span class="k">if</span> <span class="kd">let</span> <span class="nv">fecha</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">fecha</span> <span class="p">{</span>
          <span class="n">fecha</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="n">detail</span><span class="p">.</span><span class="n">fecha</span>
  <span class="p">}</span>
</code></pre></div>
-->
<!--
Vamos a poner un código condicional para la fecha, ya que sólo se mostrará en iPad. En el método `configureView` añadimos la siguiente línea:

<div class="highlight"><pre><span></span><code>            <span class="k">if</span> <span class="kc">self</span><span class="p">.</span><span class="n">traitCollection</span><span class="p">.</span><span class="n">userInterfaceIdiom</span> <span class="p">==</span> <span class="n">UIUserInterfaceIdiom</span><span class="p">.</span><span class="n">pad</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="kd">let</span> <span class="nv">fecha</span> <span class="p">=</span> <span class="kc">self</span><span class="p">.</span><span class="n">fecha</span> <span class="p">{</span>
                    <span class="n">fecha</span><span class="p">.</span><span class="n">text</span> <span class="p">=</span> <span class="n">detail</span><span class="p">.</span><span class="n">fecha</span>
                <span class="p">}</span>
            <span class="p">}</span>
</code></pre></div>
-->

<p>Ejecutamos el código en el simulador de iPad para ver los resultados. Deberíamos obtener algo parecido a esto:</p>
<p><img alt="Vista iPad portrait" src="gitbook/assets/movies_ipad_portrait.png" title="Vista iPad portrait" />
<img alt="Vista iPad landscape" src="gitbook/assets/movies_ipad_landscape.png" title="Vista iPad landscape" /></p>
<hr />
<p>El aspecto no está mal, pero sólo es una primera aproximación. Vamos a mejorar un poco el programa con los siguientes cambios: </p>
<ul>
<li>
<p>Completa el modelo añadiendo dos películas más (con sus imágenes) al proyecto, las que prefieras.</p>
</li>
<li>
<p>Vamos a mejorar la presentación visual. Para ello cambia el título de la barra de la vista detalle, de <em>Película</em> al título de la película seleccionada en la vista con el año entre paréntesis. Por ejemplo, en la barra superior debería salir <em>El sentido de la vida (1983)</em>. </p>
</li>
<li>
<p>Cambia el aspecto gráfico de las vistas para que queden lo mejor posible. Puedes mover los objetos, redimensionarlos o modificar sus propiedades, por ejemplo. </p>
</li>
<li>
<p>La primera vez que aparece la aplicación en <em>portrait</em> (sin llegar a seleccionar una película) sale la vista detalle con información vacía. Haz que en este caso se muestre sólo <code>Película</code> en el título, y que la descripción sea el mensaje <em>Selecciona una película</em>.</p>
</li>
</ul>
<!--
* (opcional) Por último, añade una lista de actores para cada película mediante un array. En los iPad debe poder verse esta información mediante un _popover_ mostrando un actor por cada opción del desplegable, aunque sin hacer ninguna acción cuando se pulse, sólo cerrar el _popover_. Para ello tendrás que crear un botón en la barra de navegación (ojo, debe ser un `UIBarButtonItem` en lugar de un botón normal), que muestre el popover cuando se pulse. En los iphone **no** debe mostrarse la información de los actores.
-->



  



                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": ".", "features": ["content.code.copy"], "search": "assets/javascripts/workers/search.74e28a9f.min.js", "translations": {"clipboard.copied": "Copiado al portapapeles", "clipboard.copy": "Copiar al portapapeles", "search.result.more.one": "1 m\u00e1s en esta p\u00e1gina", "search.result.more.other": "# m\u00e1s en esta p\u00e1gina", "search.result.none": "No se encontraron documentos", "search.result.one": "1 documento encontrado", "search.result.other": "# documentos encontrados", "search.result.placeholder": "Teclee para comenzar b\u00fasqueda", "search.result.term.missing": "Falta", "select.version": "Seleccionar versi\u00f3n"}}</script>
    
    
      <script src="assets/javascripts/bundle.220ee61c.min.js"></script>
      
    
  </body>
</html>