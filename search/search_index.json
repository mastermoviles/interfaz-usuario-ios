{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"SUMMARY.html","text":"Table of contents Presentaci\u00f3n Sesion 1 - Gu\u00edas de estilo y personalizaciones avanzadas Sesion 2 - Controladores avanzados Sesion 3 - Apps universales Sesion 4 - Gestos","title":"Table of contents"},{"location":"SUMMARY.html#table-of-contents","text":"Presentaci\u00f3n Sesion 1 - Gu\u00edas de estilo y personalizaciones avanzadas Sesion 2 - Controladores avanzados Sesion 3 - Apps universales Sesion 4 - Gestos","title":"Table of contents"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html","text":"En esta sesi\u00f3n hablaremos de los patrones de dise\u00f1o que Apple nos recomienda seguir para nuestras aplicaciones. En algunos casos es obligatorio cumplir estos patrones a la hora de dise\u00f1ar nuestras aplicaciones y el hecho de no hacerlo puede ser motivo de rechazo para publicar en el App Store . Comentaremos las distintas caracter\u00edsticas de cada dispositivo iOS. Por \u00faltimo detallaremos distintas t\u00e9cnicas que existen para personalizar los controladores y vistas m\u00e1s usadas y, de esta forma, conseguir un aspecto m\u00e1s atractivo para el usuario final. Gu\u00edas de estilo en iOS Tanto el iPhone como el iPad supusieron un revolucionario giro en cuanto a dise\u00f1o de interfaz. Para evitar el caos a la hora de dise\u00f1ar cualquier tipo de aplicaci\u00f3n, tras cada actualizaci\u00f3n de iOS Apple plantea una serie de gu\u00edas de estilo que todo desarrollador debe seguir en la medida de lo posible para dise\u00f1ar una app. Estas guias de estilo no se aplican, como es l\u00f3gico, a la hora de dise\u00f1ar la interfaz de un juego, pero son muy \u00fatiles para crear aplicaciones. En esta sesi\u00f3n vamos a aprender a dise\u00f1ar apps para iPhone / iPad que sean usables, accesibles y en las que el usuario perciba una buena experiencia de uso. Hay que tener en cuenta que un usuario de iOS est\u00e1 habituado a una serie de elementos y situaciones b\u00e1sicas, como la navegaci\u00f3n dentro de vistas mediante Navigation Controllers , navegaci\u00f3n por las opciones fundamentales mediante los Tab Bar Controllers , uso de botones, etc. Aqu\u00ed haremos un resumen de todo lo que Apple propone en sus guias de estilo . En esta asignatura nos centraremos en los aspectos principales de la gu\u00eda, aunque es recomendable leer por completo las gu\u00edas de estilo tras cada actualizaci\u00f3n de iOS, ya que las gu\u00edas cambian mucho de un a\u00f1o para otro. Adem\u00e1s de la gu\u00eda de estilo oficial, conviene consultar detalladamente este enlace: iOS Design do's and don'ts Veremos 3 puntos principales: Principios de dise\u00f1o Caracter\u00edsticas de la plataforma iOS Gu\u00edas de uso de las principales tecnolog\u00edas disponibles en iOS Principios de dise\u00f1o Apple recomienda dise\u00f1ar apps siguiendo estos principios: Claridad . En nuestras apps el texto debe poder ser legible a cualquier tama\u00f1o, los iconos deben ser precisos y claros, los adornos poco recargados y apropiados, y debemos centrarnos principalmente en la funcionalidad. Los espacios negativos, colores, fuentes, gr\u00e1ficos y elementos del interfaz deben resaltar el contenido que es importante y facilitar la interactividad. Amigabilidad . Un interfaz fluido, claro y visualmente atractivo ayuda a los usuarios a entender e interactuar con el contenido, que normalmente ocupa la pantalla completa. Es importante mantener el interfaz ligero y claro para que el contenido destaque mejor. Profundidad . Las distintas capas visuales y el movimiento realista deben facilitar la comprensi\u00f3n de la jerarqu\u00eda del interfaz e imprimir dinamismo. Tocar y descubrir mejora la sensaci\u00f3n de interacci\u00f3n y permite el acceso a funcionalidades y contenidos adicionales sin perder el contexto. Las transiciones proporcionan una sensaci\u00f3n de profundidad mientras se navega por el contenido. En general, lo principal que deben tener las aplicaciones es: Integridad est\u00e9tica: debemos integrar adecuadamente el aspecto visual con su funcionalidad. Consistencia: deben usarse elementos est\u00e1ndar a los que ya est\u00e1n habituados los usuarios de iOS y un dise\u00f1o uniforme durante toda la app. Adaptabilidad: es muy recomendable que el contenido de la pantalla cambie cuando se rota el dispositivo o se usan gestos. Las vistas deben adaptarse a cambios de orientaci\u00f3n de dispositivo, modo oscuro ( dark mode ) y tipos din\u00e1micos, dejando que los usuarios elijan las configuraciones que prefieran desde la configuraci\u00f3n general del dispositivo. Feedback : se deben confirmar las acciones y mostrar resultados para informar al usuario de que ha interactuado con nuestra app. Antes de comenzar a dise\u00f1ar una app tambi\u00e9n es muy importante conocer qui\u00e9nes son los usuarios a los que nos dirigimos, es decir, el p\u00fablico objetivo, y en funci\u00f3n de esto definir la interfaz gr\u00e1fica, los controles, terminolog\u00eda, etc. No es lo mismo dise\u00f1ar una app para ni\u00f1os que una de contabilidad, o una app para empresas. Se recomienda hacer un dise\u00f1o previo usando Mockups, o bien usando storyboards u otras herramientas antes de que la app sea funcional. Existen varios programas para Mockups, tales como mockup.io o Balsamiq . La aplicaci\u00f3n que dise\u00f1es debe estar totalmente adaptada a un dispositivo iOS, no a otro tipo ni a web. El usuario lo agradecer\u00e1 (y Apple, cuando lo revise, tambi\u00e9n). La inmensa mayoria de usuarios de iOS est\u00e1n acostumbrados al uso de botones, barras de navegaci\u00f3n, Tab Bars , etc. Debemos, en la medida de lo posible, hacer uso de toda esta serie de componentes que son dise\u00f1ados de forma espec\u00edfica para dispositivos iOS y con los que los usuarios est\u00e1n muy familiarizados. En este enlace se pueden ver todos los componentes que podemos usar en nuestras apps. Se dividen en: Contenido. Estos componentes sirven para mostrar gr\u00e1ficos, texto, im\u00e1genes, o contenidos web. Distribuci\u00f3n y organizaci\u00f3n. Elementos como las colecciones, tablas o etiquetas pueden usarse para organizar y mostrar los datos. Men\u00fas y acciones. Para interaccionar con el usuario disponemos de botones, men\u00fas o pop-ups, entre otros. Navegaci\u00f3n y b\u00fasqueda. El usuario puede moverse por nuestra app usando barras de navegaci\u00f3n, tab bars o usando campos de b\u00fasqueda, entre otros. Presentaci\u00f3n. Para presentar los datos podemos usar alertas, controles de p\u00e1gina, popovers, vistas de scroll, etc. Selecci\u00f3n y entradas. Entre otros, se pueden elegir valores de una lista con pickers , usando segmented controls , o emplear sliders para valores num\u00e9ricos. Estado. El estado de una tarea se puede medir con barras de progreso, anillos de actividad o medidores ( gauges ). Experiencias del sistema. El usuario puede recibir notificaciones, puede ver la barra de estado de la app, usar widgets , etc. Todos los componentes pueden consultarse con m\u00e1s detalle en la referencia del cat\u00e1logo de UIKit . Es importante que las aplicaciones funcionen correctamente en todos los dispositivos que puedan usarlas. Tambi\u00e9n hay que asegurarse antes de publicar en App Store de que no hay bugs , ya que si estos existen Apple puede rechazar la aplicaci\u00f3n, o si aparecen despu\u00e9s los usuarios podr\u00edan puntuarla mal o deje de usarla. Existen una serie de puntos a tener en cuenta en este caso: Hay que dise\u00f1ar cada aplicaci\u00f3n seg\u00fan el dispositivo en el que se use teniendo en cuenta especialmente las capas de vistas, ya que estas pueden cambiar bastante en funci\u00f3n del tama\u00f1o de pantalla disponible. Se debe de adaptar todo el arte (im\u00e1genes, videos, etc.) al dispositivo adecuado. Para esto se usan los Assets . En las \u00faltimas versiones de iOS, se recomienda usar ficheros PDF en los Assets , ya que se adaptar\u00e1n a cualquier tama\u00f1o. Las caracter\u00edsticas de la aplicaci\u00f3n deben conservarse a pesar del tipo de dispositivo que se use. Cuando sea posible, es conveniente dise\u00f1ar las apps para que funcionen en todos los dispositivos Apple (iOS, iPadOS, watchOS, tvOS y macOS). Caracter\u00edsticas principales de la plataforma iOS La pantalla Todo usuario que usa una aplicaci\u00f3n interact\u00faa mediante la pantalla. Existen distintas resoluciones de pantalla (a nivel de desarrollo de c\u00f3digo y a nivel f\u00edsico) seg\u00fan cada dispositivo. Se pueden consultar consejos de dise\u00f1o y la resoluci\u00f3n de todos los modelos de Apple en este enlace . Es importante resaltar que el tama\u00f1o en puntos no es el mismo que el tama\u00f1o en p\u00edxeles, que normalmente es un m\u00faltiplo (2x, 3x) de los puntos, como puede verse en el siguiente ejemplo: Detecci\u00f3n de contacto (touch events). El tama\u00f1o de la zona m\u00ednima para que el evento de contacto funcione correctamente debe de ser de al menos 44 x 44 puntos. Dada la diferencia de resoluci\u00f3n entre los distintos dispositivos de Apple, se recomienda usar siempre autolayout o SwiftUI en lugar de indicar expl\u00edcitamente coordenadas de la pantalla para colocar los componentes. SwiftUI es el nuevo sistema de Apple para el desarrollo de interfaces. Tiene como principal ventaja sobre el sistema tradicional (UIKit) que se ahorra c\u00f3digo (usa sintaxis declarativa) y facilita que la app funcione correctamente en todos los dispositivos mejorando el autolayout de UIKit. Sin embargo, en esta asignatura todav\u00eda no introduciremos este entorno porque es muy nuevo, todav\u00eda tiene bugs y est\u00e1 sujeto a bastantes cambios que pueden hacer que las apps no compilen correctamente en pocos meses. Si quieres m\u00e1s informaci\u00f3n sobre swiftUI puedes consultar este enlace . Orientaci\u00f3n del dispositivo Uno de los requisitos a la hora de publicar una aplicaci\u00f3n de iPhone/iPad en el App Store es la compatibilidad con las distintas orientaciones que puede adoptar el dispositivo iOS, tanto vertical ( portrait ) como horizontal ( landscape ). Cualquier aplicaci\u00f3n debe estar adaptada a ambas posiciones para mejorar la usabilidad. La programaci\u00f3n de la orientaci\u00f3n en una aplicaci\u00f3n iOS es relativamente sencilla (excepto en casos puntuales) y no implementarla puede suponer, como hemos comentado, el rechazo de su publicaci\u00f3n en el App Store . A continuaci\u00f3n puedes ver orientaciones de ejemplo para un iPhone y su layout: Y para el iPad: Storyboards Debemos dise\u00f1ar un Main.storyboard para nuestra app. Para la pantalla de inicio que se muestra brevemente al arrancar la aplicaci\u00f3n, a veces interesa hacer otro storyboard adicional ( LaunchScreen.storyboard ) cuando el proceso de carga de la app es lento. Las nuevas apps basadas en SwiftUI no necesitan storyboards . Gestos Llamamos gestos a los distintos movimientos que hace el usuario sobre la pantalla para realizar acciones. En la sesi\u00f3n sobre multitouch veremos en detalle c\u00f3mo gestionar los gestos. Ayuda Una aplicaci\u00f3n debe ser lo suficientemente simple e intuitiva para que el usuario sepa usarla. Hay que tener en cuenta que el usuario no tendr\u00e1 tiempo ni ganas de estar leyendo la ayuda la primera vez que usa la aplicaci\u00f3n. Por tanto, lo ideal es que no sea necesario ning\u00fan texto de ayuda, pero si existe debe ser lo m\u00e1s claro y compacto posible, y si se pueden utilizar im\u00e1genes o videos, mejor. Sonidos A veces nos interesa reproducir sonidos en nuestra app, bien porque sea necesario o para producir un efecto agradable en el usuario. Para evitar justamente lo contrario, hay que tener en cuenta que: Si el usuario activa el modo silencio en el dispositivo, este no debe de emitir ning\u00fan tipo de sonido. Hay apps que se saltan esto, y suele ser algo bastante molesto. Si nuestra app se basa completamente en el sonido (por ejemplo, un reproductor musical) puede que tengamos que hacer alguna acci\u00f3n (como por ejemplo pausar la m\u00fasica) cuando se silencie el m\u00f3vil. El tipo de sonido escogido para las distintas caracter\u00edsticas de la aplicaci\u00f3n es muy importante. Estos sonidos deben ser adecuados y se deben ajustar al tipo de acci\u00f3n que se est\u00e9 ejecutando. Hay que tener tambi\u00e9n en cuenta la gesti\u00f3n de las interrupciones de audio. Por ejemplo, puede producirse una llamada entrante, la aplicaci\u00f3n pasar a estado inactivo ( background ), etc. Si estamos desarrollando una aplicaci\u00f3n musical, para mejorar la experiencia de usuario tambi\u00e9n podemos usar el control remoto de Apple o el sistema AirPlay . Accesibilidad iOS ofrece funcionalidades de accesibilidad para usuarios con discapacidades visuales o auditivas. Con poco esfuerzo y usando los componentes de UIKit podemos adaptar nuestra app para que todos los usuarios puedan usarla. Para esto se recomienda: Proporcionar etiquetas de texto alternativas para im\u00e1genes, iconos y elementos del interfaz. Estas etiquetas alternativas no ser\u00e1n visibles en la pantalla, pero permitir\u00e1n al sistema de voz ( VoiceOver ) describir qu\u00e9 hay en la pantalla, ayudando a las personas con problemas visuales. Responder a las opciones de accesibilidad. Debemos permitir a UIKit implementar su interfaz de usuario, para que los elementos se adapten a las preferencias de accesibilidad como texto en negrita o m\u00e1s grande, o eliminar animaciones. Debemos usar la fuente de texto del sistema cuando sea posible. Probar la app en modo accesible, para ver c\u00f3mo queda. Usar suficiente contraste para que los iconos y el texto sean f\u00e1cilmente distinguibles. Carga Si usamos una pantalla est\u00e1tica mientras se est\u00e1 cargando contenido, puede parecer que la app se haya bloqueado. En lugar de esto, hay que dejar claro que la carga est\u00e1 en marcha, por ejemplo usando barras de progreso o animaciones. Preferencias Si la aplicaci\u00f3n utiliza preferencias propias, podemos hacer una vista para ellas dentro de nuestra aplicaci\u00f3n en el caso de que el usuario necesite cambiarlas con frecuencia, o bien a\u00f1adir un settings bundle si el cambio no es tan frecuente. Un settings bundle contiene ficheros (principalmente .plist ) que describen la estructura y estilo de presentaci\u00f3n de las preferencias, y es muy sencillo de implementar. La app Settings usa esta informaci\u00f3n para crear una entrada para nuestra aplicaci\u00f3n y mostrar las preferencias. Gu\u00edas de uso de las principales tecnolog\u00edas disponibles en iOS La API de iOS nos da acceso a m\u00faltiples tecnolog\u00edas nativas que se describen a continuaci\u00f3n: Multitarea Mediante la multitarea nuestro dispositivo puede ejecutar m\u00e1s de dos aplicaciones al mismo tiempo. Otras tareas que no est\u00e9n mostr\u00e1ndose en pantalla pueden estar guardadas en memoria (en background ) o tambi\u00e9n mostr\u00e1ndose simult\u00e1neamente en la pantalla. Apple recomienda que nuestra aplicaci\u00f3n tenga en cuenta dicha caracter\u00edstica ya que de esta forma el usuario puede estar realizando otras tareas al mismo tiempo sin necesidad de cerrarla. La aplicaci\u00f3n debe estar preparada para gestionar interrupciones de audio en cualquier momento, pararse y reiniciarse sin ninguna complicaci\u00f3n ni lag y de forma \"suave\", y debe comportarse de forma adecuada cuando se encuentra en background . La multitarea es una tecnolog\u00eda que se utiliza muy a menudo en iOS y es por ello que debemos tenerla presente cuando dise\u00f1amos nuestras aplicaciones. La gesti\u00f3n del paso de un estado activo a inactivo debe programarse cuando sea necesario. Por ejemplo, hay que tener en cuenta que nuestro juego Angry Birds puede interrumpirse por una llamada a mitad del lanzamiento de un p\u00e1jaro. Para determinar el comportamiento de nuestra aplicaci\u00f3n cuando entra en modo background podemos implementar m\u00e9todos que se ver\u00e1n en otras asignaturas del m\u00e1ster. Adem\u00e1s de tener que estar preparados para interrupciones, la multitarea implica que nuestra app puede ejecutarse s\u00f3lo en una zona de la pantalla, por lo que hay que tener en cuenta esto en la fase de dise\u00f1o. Notificaciones Las notificaciones push permiten avisar a los usuarios independientemente de si la aplicaci\u00f3n est\u00e1 funcionando en ese momento. Esto es muy \u00fatil en apps que usen un calendario, para avisar de eventos futuros, o para alg\u00fan tipo de recordatorio. Tambi\u00e9n se utiliza muy a menudo en juegos. Se pueden enviar notificaciones usando un servidor propio, o bien generarlas localmente desde nuestra app. En el caso de requerir un servidor tambi\u00e9n se pueden contratar servicios externos que realicen esa tarea de forma bastante econ\u00f3mica. Extensiones Con las extensiones los usuarios pueden usar un componente desarrollado por nosotros desde una app externa. Por ejemplo, mientras un usuario ve una p\u00e1gina web con Safari, podr\u00eda usar nuestras extensiones para enviar una imagen o un art\u00edculo a nuestra red social. O podr\u00eda tambi\u00e9n usar desde la aplicaci\u00f3n de fotos de Apple una extensi\u00f3n nuestra para editar la imagen. Las extensiones pueden ser de tipo widget , para realizar acciones desde el notification center, share para compartir contenido con terceros, action para ver contenido desde otra aplicaci\u00f3n, photo editing para editar im\u00e1genes, o custom keyboard para reemplazar el teclado de iOS por uno personalizado, entre otras posibilidades. B\u00e1sicamente estos son los conceptos principales de la gu\u00eda de estilo de Apple, aunque hay m\u00e1s tecnolog\u00edas que pueden verse en su gu\u00eda de estilo . Ejercicios A continuaci\u00f3n vamos a empezar programando ejemplos de personalizaci\u00f3n de controladores. Llamaremos personalizaciones a las modificaciones sobre el aspecto visual de los componentes est\u00e1ndar de Apple. Normalmente las personalizaciones no son recomendables para no confundir al usuario, pero a veces son necesarias para juegos o aplicaciones que requieran un aspecto diferente, como puede verse en el siguiente ejemplo: Ejercicio 1- Personalizaci\u00f3n de celdas La captura siguiente muestra un ejemplo de una tabla con las celdas totalmente personalizadas. A diferencia de la personalizaci\u00f3n de otros componentes, la personalizaci\u00f3n de celdas de una tabla es algo muy habitual en iOS. De esta forma podemos hacer que nuestras tablas se distingan del resto, mostrar datos de forma m\u00e1s adecuada, y ofrecer un aspecto caracter\u00edstico para nuestra app. \u00bfC\u00f3mo podemos hacer este tipo de celdas? Es muy sencillo, a continuaci\u00f3n veremos mediante un ejemplo paso a paso el dise\u00f1o y programaci\u00f3n de celdas personalizadas mediante XCode. Creando el proyecto y las clases b\u00e1sicas Al terminar este ejemplo tendremos una aplicaci\u00f3n que solo contiene una vista de tabla UITableView con celdas personalizadas. Estas celdas tendr\u00e1n una imagen en el lado izquierdo, un texto en negrita en la parte superior y otro texto peque\u00f1o en la parte inferior. Las celdas tendr\u00e1n un tama\u00f1o algo mayor al que viene por defecto y, para finalizar, la tabla tendr\u00e1 estilo zebra , es decir, el fondo de las celdas tendr\u00e1 colores intercalados para cada fila. Comenzaremos creando el proyecto. Para ello, abrimos XCode y creamos un nuevo proyecto para iOS de tipo App . Lo guardaremos con el nombre ejercicio_celdas , y debemos elegir el interfaz Storyboard: Para empezar vamos a a\u00f1adir al storyboard principal ( Main ) un nuevo controlador de tipo Table View Controller (usando el bot\u00f3n + en la parte superior del interfaz de XCode). Ahora haremos que nuestra tabla sea lo primero que aparezca cuando se lance la app. Esto se puede hacer, por ejemplo, arrastrando la flecha horizontal que apunta al primer controlador (la vista vac\u00eda) hacia nuestro nuevo Table View Controller . Ya podemos borrar la vista vac\u00eda del storyboard, que ahora comenzar\u00e1 con nuestra tabla. Podemos tambi\u00e9n borrar el fichero ViewController.swift , ya que estaba asociado a la vista que hemos borrado. Ya tenemos la vista de la tabla, pero vamos a crear tambi\u00e9n un fichero de c\u00f3digo como controlador para poder programar los elementos de la celda. Seleccionamos File > New > File > Cocoa Touch Class , y le damos el nombre TableViewController , subclase de UITableViewController , dejando sin marcar \" Also create XIB file \". Ahora tenemos que asignar la vista al controlador. Para ello, seleccionamos el controlador en el storyboard, y desde el Identity Inspector le asignamos la clase que hemos creado TableViewController , como se muestra en la imagen: Por \u00faltimo, para nuestra vista personalizada vamos a crear un nuevo fichero subclase de UITableViewCell . Hacemos click en File > New > File > Cocoa Touch Class , y seleccionamos Subclass of UITableViewCell , dejando sin marcar \" Also create XIB file \". Lo guardamos con el nombre TableViewCell . Dise\u00f1ando la celda desde Interface Builder Una vez hemos creado el proyecto y la clase controladora de la tabla y la celda ahora vamos a dise\u00f1ar su vista. Para ello abrimos la tabla en el storyboard. Dentro de Prototype cells podemos dise\u00f1ar la vista de la celda. Pero antes tenemos que asignar la clase TableViewCell que hemos creado a las celdas de nuestra tabla. Una vez hemos vinculado la vista de la celda a nuestro controlador, vamos a modificar la altura de la celda desde el size inspector , usando una altura de 70 puntos: Adem\u00e1s de indicar la altura de la celda para el Table View Cell (lo cual nos sirve para saber c\u00f3mo quedan los elementos en la vista de dise\u00f1o), tambi\u00e9n debemos hacerlo para las celdas del Table View : Si quisieramos hacer esto mismo desde c\u00f3digo (como lo hemos hecho desde el interfaz no hace falta), podr\u00edamos indicarlo as\u00ed en el m\u00e9todo viewDidLoad : self . tableView . rowHeight = 70 Ahora solo tenemos que arrastrar los objetos que queremos que aparezcan en la celda. En este ejemplo vamos a a\u00f1adir dos etiquetas ( labels ) y una imagen ( UIImageView ). La celda quedar\u00e1 de la siguiente manera en el Interface builder : En la pesta\u00f1a de Attributes Inspector de la celda escribimos un identificador para ella: TableViewCell . Esto servir\u00e1 m\u00e1s adelante para referenciarla desde el controlador de la tabla y as\u00ed poder utilizar las celdas desde este controlador: Ya hemos dise\u00f1ado la vista de la celda. Ahora vamos a programar el c\u00f3digo de su controlador. Programando la celda Tendremos que vincular a nuestra clase celda los Outlets que hemos creado antes en la vista. Para ello abrimos el fichero TableViewCell.swift y a\u00f1adimos las siguientes propiedades a la clase: @IBOutlet weak var imagen : UIImageView ! @IBOutlet weak var labelTitle : UILabel ! @IBOutlet weak var labelAuthor : UILabel ! Alternativamente, se pueden crear los IBOutlets con el asistente (a veces es m\u00e1s c\u00f3modo). Pinchando sobre el s\u00edmbolo que representa una tabla con un + dentro de ella (arriba a la derecha), se abre una segunda ventana de edici\u00f3n. As\u00ed se puede seleccionar la vista en una de las ventanas, y el c\u00f3digo en otra. Despu\u00e9s, puedes pinchar (bot\u00f3n derecho) sobre el componente de la vista y arrastrarlo al c\u00f3digo de la declaraci\u00f3n de la clase. Esto crea autom\u00e1ticamente las propiedades, y hace los enlaces. El mismo procedimiento es v\u00e1lido tambi\u00e9n para crear un IBAction . Ahora volvemos a la vista de la celda en el storyboard y enlazamos los Outlets creados en la clase con los objetos de la vista. Una vez hecho esto abrimos de nuevo la clase controladora de la tabla TableViewController.swift y modificamos los siguientes m\u00e9todos: override func numberOfSections ( in tableView : UITableView ) -> Int { return 1 } override func tableView ( _ tableView : UITableView , numberOfRowsInSection section : Int ) -> Int { return 3 } override func tableView ( _ tableView : UITableView , cellForRowAt indexPath : IndexPath ) -> UITableViewCell { let cell = tableView . dequeueReusableCell ( withIdentifier : \"TableViewCell\" , for : indexPath ) as ! TableViewCell cell . labelTitle ?. text = \"T\u00edtulo \\( indexPath . row + 1 ) \" cell . labelAuthor ?. text = \"Autor\" cell . imagen ?. image = UIImage ( named : \"logo-master.png\" ) return cell } Ahora descarga la imagen logo_master.png y arr\u00e1strala dentro de XCode a los Assets del proyecto. En este momento ya podemos ejecutar la aplicaci\u00f3n y nos debe aparecer la tabla con las celdas que acabamos de programar. Si la ejecutamos en el mismo dispositivo que ten\u00edamos seleccionado en la barra inferior (sobre el cu\u00e1l hemos hecho el dise\u00f1o), nos saldr\u00e1n los elementos relativamente bien colocados. En cambio, si la ejecutamos con el simulador para otro dispositivo distinto, probablemente se nos descoloquen los elementos de la celda porque falta ajustar los constraints (de hecho se mostrar\u00e1 alg\u00fan warning por este motivo). De momento no te preocupes por esto, lo arreglaremos m\u00e1s adelante. A\u00f1adiendo la barra de navegaci\u00f3n La aplicaci\u00f3n funciona y se muestra una tabla, aunque no tiene barra de navegaci\u00f3n. Normalmente todos los controladores en iOS suelen ir incrustados en controladores contenedores, que son los que gestionan la navegaci\u00f3n, como UINavigationController , UITabBarController o UISplitViewController . Para nuestro ejercicio, lo m\u00e1s adecuado incrustrar la tabla en un Navigation Controller , seleccionando el controlador de la tabla en el storyboard y eligiendo Editor > Embed in > Navigation Controller . A\u00f1ade un t\u00edtulo para la tabla mediante la siguiente l\u00ednea de c\u00f3digo en viewDidLoad de TableViewController (o si lo prefieres, desde el Interface Builder ): self . title = \"Mi tabla personalizada\" Personalizaci\u00f3n con efecto zebra Una vez tenemos las celdas hechas vamos a personalizar la tabla un poco m\u00e1s, a\u00f1adiendo un fondo a las celdas pares y otro a las impares, lo que se conoce como efecto zebra . Para esto necesitaremos dos im\u00e1genes m\u00e1s que se pueden descargar aqu\u00ed y a\u00f1adirlas a los Assets . Abrimos la vista de la celda en el storyboard y arrastramos un UIImageView ocupando todo el espacio de la celda. Es necesario enviar esta vista al fondo, con el men\u00fa Editor > Arrange > Send to back . Si en el modo visual se van descolocando las vistas de la celda cuando las mueves (aunque esto no deber\u00eda ocurrir con las \u00faltimas versiones de XCode), ajusta los tama\u00f1os desde el Size Inspector . En el fichero TableViewCell.swift enlazamos el nuevo UIImageView , como hemos hecho con el resto de elementos, y lo llamamos fondo . Ahora, en la clase TableViewController , dentro del m\u00e9todo cellForRowAt a\u00f1adimos lo siguiente justo antes de return cell if indexPath . row % 2 != 0 { cell . fondo . image = UIImage ( named : \"fondo_celda1.png\" ) } else { cell . fondo . image = UIImage ( named : \"fondo_celda2.png\" ) } Si ejecutamos ahora el proyecto tendremos nuestra tabla con las celdas personalizadas: Ajuste de las constraints S\u00f3lo hay un problema: como hemos comentado anteriormente, se ha dise\u00f1ado la vista para un iPhone en concreto (iPhone 14 Pro por defecto), y si ejecutamos el simulador con otro iPhone (por ejemplo el SE) los elementos de la celda nos saldr\u00e1n descolocados. Para que salgan bien nos falta ajustar las constraints de la vista. Para esto, seleccionamos el TableViewCell desde el storyboard , y en la parte inferior (\"All Views in Table View Cell\") marcamos \"All Views in TableViewController\" -> \"Reset to Suggested Constraints\". Probamos y vemos que la tabla es correcta, incluso rotando el dispositivo. Esta opci\u00f3n de Reset te puede sacar de m\u00e1s de un apuro cuando el ajustar el autolayout sea complicado. Recomiendo probar primero con ella, y si no funciona a la primera entonces ajustar las constraints a mano. Si se te queda muy corta la imagen del fondo cuando rotas el dispositivo puedes seleccionar la opci\u00f3n \"Scale to Fill\" en el inspector de atributos: Insertar datos en la tabla Para finalizar, extenderemos nuestro programa con las siguientes opciones: a) Vamos a rellenar las celdas de la tabla con datos de libros. Para ello, crearemos una nueva clase (con File > New > Swift file ) a la que llamaremos Libro . Reemplaza en este fichero import Foundation por import UIKit , y crea la clase con un String que ser\u00e1 el t\u00edtulo del libro, otro String que ser\u00e1 el autor y una imagen ( UIImage ) que ser\u00e1 la portada. A\u00f1ade tambi\u00e9n un m\u00e9todo init para inicializar las variables de la clase. b) Ahora crearemos un array dentro de la clase TableViewController , lo inicializamos y lo completamos con los 3 libros que prefieras. Cada elemento del array ser\u00e1 de la clase Libro . c) Una vez creado el array de libros vamos a mostrarlos en nuestra tabla. Para ello deberemos modificar los m\u00e9todos de la clase TableViewController , asignando los datos del array a las celdas correspondientes. d) Cuando hayamos terminado, comprobamos que la aplicaci\u00f3n funciona seg\u00fan lo esperado. Ejercicio 2- Personalizaci\u00f3n de ToolBars Los ToolBars , al igual que la mayor parte de componentes, se pueden personalizar para conseguir las funcionalidades que deseemos para nuestras apps. En el siguiente ejemplo vamos a crear una vista ToolBar personalizada con una imagen de fondo, estilos para los botones, a\u00f1adiendo botones de distinto tipo, etc. Comenzamos creando un nuevo proyecto de tipo iOS > App con el nombre ejercicio_toolbar y con interfaz Storyboard . Dise\u00f1o de la vista Abrimos la vista principal del storyboard , arrastramos un objeto UIToolBar y lo situamos en la parte superior. Tambi\u00e9n vamos a a\u00f1adir un objeto UILabel en el centro de la vista. Ahora vamos a a\u00f1adir los elementos que deseemos sobre el ToolBar . En nuestro caso arrastraremos desde el listado de objetos (en el siguiente orden) un Text Field , un Flexible Space Bar y un Segmented Control . Borraremos el bot\u00f3n Item de la izquierda. El ToolBar debe quedar de la siguiente manera: Como podemos observar, la funci\u00f3n del objeto Flexible Space no es m\u00e1s que a\u00f1adir un espacio flexible entre dos objetos dentro de un ToolBar . Una vez que tenemos la barra con todos sus elementos vamos a definir los elementos dentro de la clase. Dentro del c\u00f3digo de la clase ViewController a\u00f1adimos los siguientes outlets: @IBOutlet weak var toolBar : UIToolbar ! @IBOutlet weak var textField : UITextField ! @IBOutlet weak var segmentedControl : UISegmentedControl ! // Para la etiqueta centrada en la vista @IBOutlet weak var segmentLabel : UILabel ! Seguidamente tenemos que enlazar los outlets dentro de la vista. Si ejecutamos el c\u00f3digo, es posible que el toolbar y el label salgan descolocados (o que no salgan) cuando rotemos el dispositivo. Ajuste de las constraints Vamos a a\u00f1adir constraints desde XCode para fijar los m\u00e1rgenes. Selecciona el toolbar, y a\u00f1ade las siguientes constraints (arriba, izquierda, derecha) marcando Constrain to margins para que no se solape con la barra de estado: Vamos a centrar ahora el label , a\u00f1adiendo restricciones de centrado horizontal y vertical: Puedes ver los constraints a\u00f1adidos para cada elemento en el Size inspector . Por ejemplo, para el label tendr\u00edamos: Acciones Ahora vamos a implementar la acci\u00f3n del Segmented Control . Para ello declaramos el siguiente m\u00e9todo dentro de la clase ViewController : @IBAction func segmentedControlIndexChanged ( _ sender : Any ) { self . segmentLabel . text = self . segmentedControl . selectedSegmentIndex == 0 ? \"Segmento 1\" : \"Segmento 2\" } Para que el m\u00e9todo se invoque cuando se pulsa un bot\u00f3n del Segmented Control , deberemos enlazarlo con la vista. En este momento ya podemos ejecutar el proyecto por primera vez y comprobar que al pulsar sobre uno de los botones del Segmented Control la etiqueta Label cambia. Personalizaci\u00f3n avanzada Ya tenemos un objeto ToolBar con una personalizaci\u00f3n b\u00e1sica funcionando. Ahora vamos a cambiarlo un poco m\u00e1s: vamos a a\u00f1adirle una imagen de fondo, a asignar un color de fondo al Segmented Control y a modificar el dise\u00f1o del TextField . Para hacer todo esto debemos cambiar el m\u00e9todo viewDidLoad de la clase ViewController de forma que quede de la siguiente manera: override func viewDidLoad () { super . viewDidLoad () // Vamos a a\u00f1adir la imagen de fondo como un imageView, pero esta vez sin usar el storyboard (por hacerlo distinto) let iv = UIImageView ( image : UIImage ( named : \"fondo_madera.png\" )) iv . frame = CGRect ( x : 0 , y : 0 , width : self . toolBar . frame . size . width , height : 44 ) iv . autoresizingMask = UIView . AutoresizingMask . flexibleWidth // A\u00f1adimos la subview self . toolBar . insertSubview ( iv , at : 0 ) // Cambiamos el color del SegmentedControl self . segmentedControl . tintColor = UIColor . brown // Personalizamos el TextField desde c\u00f3digo (tambi\u00e9n se podr\u00eda hacer desde el Interface Builder) self . textField . textColor = UIColor . white self . textField . borderStyle = UITextField . BorderStyle . none self . textField . background = UIImage ( named : \"fondo_textfield.png\" ) self . textField . placeholder = \"Escribe aqu\u00ed\" } Para que el c\u00f3digo funcione debemos descargarnos las im\u00e1genes desde aqu\u00ed y a\u00f1adirlas a los Assets del proyecto. Una vez hecho esto ya podemos ejecutarlo y ver c\u00f3mo ha cambiado. De esta forma tendremos nuestro componente ToolBar bastante personalizado, d\u00e1ndole a la aplicaci\u00f3n un aspecto visual diferenciado. La metodolog\u00eda que acabamos de seguir nos servir\u00eda tambi\u00e9n para personalizar los componentes UITabBar y UINavigationBar , entre otros.","title":"1- Gu\u00edas de estilo y personalizaciones avanzadas"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#guias-de-estilo-en-ios","text":"Tanto el iPhone como el iPad supusieron un revolucionario giro en cuanto a dise\u00f1o de interfaz. Para evitar el caos a la hora de dise\u00f1ar cualquier tipo de aplicaci\u00f3n, tras cada actualizaci\u00f3n de iOS Apple plantea una serie de gu\u00edas de estilo que todo desarrollador debe seguir en la medida de lo posible para dise\u00f1ar una app. Estas guias de estilo no se aplican, como es l\u00f3gico, a la hora de dise\u00f1ar la interfaz de un juego, pero son muy \u00fatiles para crear aplicaciones. En esta sesi\u00f3n vamos a aprender a dise\u00f1ar apps para iPhone / iPad que sean usables, accesibles y en las que el usuario perciba una buena experiencia de uso. Hay que tener en cuenta que un usuario de iOS est\u00e1 habituado a una serie de elementos y situaciones b\u00e1sicas, como la navegaci\u00f3n dentro de vistas mediante Navigation Controllers , navegaci\u00f3n por las opciones fundamentales mediante los Tab Bar Controllers , uso de botones, etc. Aqu\u00ed haremos un resumen de todo lo que Apple propone en sus guias de estilo . En esta asignatura nos centraremos en los aspectos principales de la gu\u00eda, aunque es recomendable leer por completo las gu\u00edas de estilo tras cada actualizaci\u00f3n de iOS, ya que las gu\u00edas cambian mucho de un a\u00f1o para otro. Adem\u00e1s de la gu\u00eda de estilo oficial, conviene consultar detalladamente este enlace: iOS Design do's and don'ts Veremos 3 puntos principales: Principios de dise\u00f1o Caracter\u00edsticas de la plataforma iOS Gu\u00edas de uso de las principales tecnolog\u00edas disponibles en iOS","title":"Gu\u00edas de estilo en iOS"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#principios-de-diseno","text":"Apple recomienda dise\u00f1ar apps siguiendo estos principios: Claridad . En nuestras apps el texto debe poder ser legible a cualquier tama\u00f1o, los iconos deben ser precisos y claros, los adornos poco recargados y apropiados, y debemos centrarnos principalmente en la funcionalidad. Los espacios negativos, colores, fuentes, gr\u00e1ficos y elementos del interfaz deben resaltar el contenido que es importante y facilitar la interactividad. Amigabilidad . Un interfaz fluido, claro y visualmente atractivo ayuda a los usuarios a entender e interactuar con el contenido, que normalmente ocupa la pantalla completa. Es importante mantener el interfaz ligero y claro para que el contenido destaque mejor. Profundidad . Las distintas capas visuales y el movimiento realista deben facilitar la comprensi\u00f3n de la jerarqu\u00eda del interfaz e imprimir dinamismo. Tocar y descubrir mejora la sensaci\u00f3n de interacci\u00f3n y permite el acceso a funcionalidades y contenidos adicionales sin perder el contexto. Las transiciones proporcionan una sensaci\u00f3n de profundidad mientras se navega por el contenido. En general, lo principal que deben tener las aplicaciones es: Integridad est\u00e9tica: debemos integrar adecuadamente el aspecto visual con su funcionalidad. Consistencia: deben usarse elementos est\u00e1ndar a los que ya est\u00e1n habituados los usuarios de iOS y un dise\u00f1o uniforme durante toda la app. Adaptabilidad: es muy recomendable que el contenido de la pantalla cambie cuando se rota el dispositivo o se usan gestos. Las vistas deben adaptarse a cambios de orientaci\u00f3n de dispositivo, modo oscuro ( dark mode ) y tipos din\u00e1micos, dejando que los usuarios elijan las configuraciones que prefieran desde la configuraci\u00f3n general del dispositivo. Feedback : se deben confirmar las acciones y mostrar resultados para informar al usuario de que ha interactuado con nuestra app. Antes de comenzar a dise\u00f1ar una app tambi\u00e9n es muy importante conocer qui\u00e9nes son los usuarios a los que nos dirigimos, es decir, el p\u00fablico objetivo, y en funci\u00f3n de esto definir la interfaz gr\u00e1fica, los controles, terminolog\u00eda, etc. No es lo mismo dise\u00f1ar una app para ni\u00f1os que una de contabilidad, o una app para empresas. Se recomienda hacer un dise\u00f1o previo usando Mockups, o bien usando storyboards u otras herramientas antes de que la app sea funcional. Existen varios programas para Mockups, tales como mockup.io o Balsamiq . La aplicaci\u00f3n que dise\u00f1es debe estar totalmente adaptada a un dispositivo iOS, no a otro tipo ni a web. El usuario lo agradecer\u00e1 (y Apple, cuando lo revise, tambi\u00e9n). La inmensa mayoria de usuarios de iOS est\u00e1n acostumbrados al uso de botones, barras de navegaci\u00f3n, Tab Bars , etc. Debemos, en la medida de lo posible, hacer uso de toda esta serie de componentes que son dise\u00f1ados de forma espec\u00edfica para dispositivos iOS y con los que los usuarios est\u00e1n muy familiarizados. En este enlace se pueden ver todos los componentes que podemos usar en nuestras apps. Se dividen en: Contenido. Estos componentes sirven para mostrar gr\u00e1ficos, texto, im\u00e1genes, o contenidos web. Distribuci\u00f3n y organizaci\u00f3n. Elementos como las colecciones, tablas o etiquetas pueden usarse para organizar y mostrar los datos. Men\u00fas y acciones. Para interaccionar con el usuario disponemos de botones, men\u00fas o pop-ups, entre otros. Navegaci\u00f3n y b\u00fasqueda. El usuario puede moverse por nuestra app usando barras de navegaci\u00f3n, tab bars o usando campos de b\u00fasqueda, entre otros. Presentaci\u00f3n. Para presentar los datos podemos usar alertas, controles de p\u00e1gina, popovers, vistas de scroll, etc. Selecci\u00f3n y entradas. Entre otros, se pueden elegir valores de una lista con pickers , usando segmented controls , o emplear sliders para valores num\u00e9ricos. Estado. El estado de una tarea se puede medir con barras de progreso, anillos de actividad o medidores ( gauges ). Experiencias del sistema. El usuario puede recibir notificaciones, puede ver la barra de estado de la app, usar widgets , etc. Todos los componentes pueden consultarse con m\u00e1s detalle en la referencia del cat\u00e1logo de UIKit . Es importante que las aplicaciones funcionen correctamente en todos los dispositivos que puedan usarlas. Tambi\u00e9n hay que asegurarse antes de publicar en App Store de que no hay bugs , ya que si estos existen Apple puede rechazar la aplicaci\u00f3n, o si aparecen despu\u00e9s los usuarios podr\u00edan puntuarla mal o deje de usarla. Existen una serie de puntos a tener en cuenta en este caso: Hay que dise\u00f1ar cada aplicaci\u00f3n seg\u00fan el dispositivo en el que se use teniendo en cuenta especialmente las capas de vistas, ya que estas pueden cambiar bastante en funci\u00f3n del tama\u00f1o de pantalla disponible. Se debe de adaptar todo el arte (im\u00e1genes, videos, etc.) al dispositivo adecuado. Para esto se usan los Assets . En las \u00faltimas versiones de iOS, se recomienda usar ficheros PDF en los Assets , ya que se adaptar\u00e1n a cualquier tama\u00f1o. Las caracter\u00edsticas de la aplicaci\u00f3n deben conservarse a pesar del tipo de dispositivo que se use. Cuando sea posible, es conveniente dise\u00f1ar las apps para que funcionen en todos los dispositivos Apple (iOS, iPadOS, watchOS, tvOS y macOS).","title":"Principios de dise\u00f1o"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#caracteristicas-principales-de-la-plataforma-ios","text":"","title":"Caracter\u00edsticas principales de la plataforma iOS"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#guias-de-uso-de-las-principales-tecnologias-disponibles-en-ios","text":"La API de iOS nos da acceso a m\u00faltiples tecnolog\u00edas nativas que se describen a continuaci\u00f3n:","title":"Gu\u00edas de uso de las principales tecnolog\u00edas disponibles en iOS"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#ejercicios","text":"A continuaci\u00f3n vamos a empezar programando ejemplos de personalizaci\u00f3n de controladores. Llamaremos personalizaciones a las modificaciones sobre el aspecto visual de los componentes est\u00e1ndar de Apple. Normalmente las personalizaciones no son recomendables para no confundir al usuario, pero a veces son necesarias para juegos o aplicaciones que requieran un aspecto diferente, como puede verse en el siguiente ejemplo:","title":"Ejercicios"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#ejercicio-1-personalizacion-de-celdas","text":"La captura siguiente muestra un ejemplo de una tabla con las celdas totalmente personalizadas. A diferencia de la personalizaci\u00f3n de otros componentes, la personalizaci\u00f3n de celdas de una tabla es algo muy habitual en iOS. De esta forma podemos hacer que nuestras tablas se distingan del resto, mostrar datos de forma m\u00e1s adecuada, y ofrecer un aspecto caracter\u00edstico para nuestra app. \u00bfC\u00f3mo podemos hacer este tipo de celdas? Es muy sencillo, a continuaci\u00f3n veremos mediante un ejemplo paso a paso el dise\u00f1o y programaci\u00f3n de celdas personalizadas mediante XCode.","title":"Ejercicio 1- Personalizaci\u00f3n de celdas"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#creando-el-proyecto-y-las-clases-basicas","text":"Al terminar este ejemplo tendremos una aplicaci\u00f3n que solo contiene una vista de tabla UITableView con celdas personalizadas. Estas celdas tendr\u00e1n una imagen en el lado izquierdo, un texto en negrita en la parte superior y otro texto peque\u00f1o en la parte inferior. Las celdas tendr\u00e1n un tama\u00f1o algo mayor al que viene por defecto y, para finalizar, la tabla tendr\u00e1 estilo zebra , es decir, el fondo de las celdas tendr\u00e1 colores intercalados para cada fila. Comenzaremos creando el proyecto. Para ello, abrimos XCode y creamos un nuevo proyecto para iOS de tipo App . Lo guardaremos con el nombre ejercicio_celdas , y debemos elegir el interfaz Storyboard: Para empezar vamos a a\u00f1adir al storyboard principal ( Main ) un nuevo controlador de tipo Table View Controller (usando el bot\u00f3n + en la parte superior del interfaz de XCode). Ahora haremos que nuestra tabla sea lo primero que aparezca cuando se lance la app. Esto se puede hacer, por ejemplo, arrastrando la flecha horizontal que apunta al primer controlador (la vista vac\u00eda) hacia nuestro nuevo Table View Controller . Ya podemos borrar la vista vac\u00eda del storyboard, que ahora comenzar\u00e1 con nuestra tabla. Podemos tambi\u00e9n borrar el fichero ViewController.swift , ya que estaba asociado a la vista que hemos borrado. Ya tenemos la vista de la tabla, pero vamos a crear tambi\u00e9n un fichero de c\u00f3digo como controlador para poder programar los elementos de la celda. Seleccionamos File > New > File > Cocoa Touch Class , y le damos el nombre TableViewController , subclase de UITableViewController , dejando sin marcar \" Also create XIB file \". Ahora tenemos que asignar la vista al controlador. Para ello, seleccionamos el controlador en el storyboard, y desde el Identity Inspector le asignamos la clase que hemos creado TableViewController , como se muestra en la imagen: Por \u00faltimo, para nuestra vista personalizada vamos a crear un nuevo fichero subclase de UITableViewCell . Hacemos click en File > New > File > Cocoa Touch Class , y seleccionamos Subclass of UITableViewCell , dejando sin marcar \" Also create XIB file \". Lo guardamos con el nombre TableViewCell .","title":"Creando el proyecto y las clases b\u00e1sicas"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#disenando-la-celda-desde-interface-builder","text":"Una vez hemos creado el proyecto y la clase controladora de la tabla y la celda ahora vamos a dise\u00f1ar su vista. Para ello abrimos la tabla en el storyboard. Dentro de Prototype cells podemos dise\u00f1ar la vista de la celda. Pero antes tenemos que asignar la clase TableViewCell que hemos creado a las celdas de nuestra tabla. Una vez hemos vinculado la vista de la celda a nuestro controlador, vamos a modificar la altura de la celda desde el size inspector , usando una altura de 70 puntos: Adem\u00e1s de indicar la altura de la celda para el Table View Cell (lo cual nos sirve para saber c\u00f3mo quedan los elementos en la vista de dise\u00f1o), tambi\u00e9n debemos hacerlo para las celdas del Table View : Si quisieramos hacer esto mismo desde c\u00f3digo (como lo hemos hecho desde el interfaz no hace falta), podr\u00edamos indicarlo as\u00ed en el m\u00e9todo viewDidLoad : self . tableView . rowHeight = 70 Ahora solo tenemos que arrastrar los objetos que queremos que aparezcan en la celda. En este ejemplo vamos a a\u00f1adir dos etiquetas ( labels ) y una imagen ( UIImageView ). La celda quedar\u00e1 de la siguiente manera en el Interface builder : En la pesta\u00f1a de Attributes Inspector de la celda escribimos un identificador para ella: TableViewCell . Esto servir\u00e1 m\u00e1s adelante para referenciarla desde el controlador de la tabla y as\u00ed poder utilizar las celdas desde este controlador: Ya hemos dise\u00f1ado la vista de la celda. Ahora vamos a programar el c\u00f3digo de su controlador.","title":"Dise\u00f1ando la celda desde Interface Builder"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#programando-la-celda","text":"Tendremos que vincular a nuestra clase celda los Outlets que hemos creado antes en la vista. Para ello abrimos el fichero TableViewCell.swift y a\u00f1adimos las siguientes propiedades a la clase: @IBOutlet weak var imagen : UIImageView ! @IBOutlet weak var labelTitle : UILabel ! @IBOutlet weak var labelAuthor : UILabel ! Alternativamente, se pueden crear los IBOutlets con el asistente (a veces es m\u00e1s c\u00f3modo). Pinchando sobre el s\u00edmbolo que representa una tabla con un + dentro de ella (arriba a la derecha), se abre una segunda ventana de edici\u00f3n. As\u00ed se puede seleccionar la vista en una de las ventanas, y el c\u00f3digo en otra. Despu\u00e9s, puedes pinchar (bot\u00f3n derecho) sobre el componente de la vista y arrastrarlo al c\u00f3digo de la declaraci\u00f3n de la clase. Esto crea autom\u00e1ticamente las propiedades, y hace los enlaces. El mismo procedimiento es v\u00e1lido tambi\u00e9n para crear un IBAction . Ahora volvemos a la vista de la celda en el storyboard y enlazamos los Outlets creados en la clase con los objetos de la vista. Una vez hecho esto abrimos de nuevo la clase controladora de la tabla TableViewController.swift y modificamos los siguientes m\u00e9todos: override func numberOfSections ( in tableView : UITableView ) -> Int { return 1 } override func tableView ( _ tableView : UITableView , numberOfRowsInSection section : Int ) -> Int { return 3 } override func tableView ( _ tableView : UITableView , cellForRowAt indexPath : IndexPath ) -> UITableViewCell { let cell = tableView . dequeueReusableCell ( withIdentifier : \"TableViewCell\" , for : indexPath ) as ! TableViewCell cell . labelTitle ?. text = \"T\u00edtulo \\( indexPath . row + 1 ) \" cell . labelAuthor ?. text = \"Autor\" cell . imagen ?. image = UIImage ( named : \"logo-master.png\" ) return cell } Ahora descarga la imagen logo_master.png y arr\u00e1strala dentro de XCode a los Assets del proyecto. En este momento ya podemos ejecutar la aplicaci\u00f3n y nos debe aparecer la tabla con las celdas que acabamos de programar. Si la ejecutamos en el mismo dispositivo que ten\u00edamos seleccionado en la barra inferior (sobre el cu\u00e1l hemos hecho el dise\u00f1o), nos saldr\u00e1n los elementos relativamente bien colocados. En cambio, si la ejecutamos con el simulador para otro dispositivo distinto, probablemente se nos descoloquen los elementos de la celda porque falta ajustar los constraints (de hecho se mostrar\u00e1 alg\u00fan warning por este motivo). De momento no te preocupes por esto, lo arreglaremos m\u00e1s adelante.","title":"Programando la celda"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#anadiendo-la-barra-de-navegacion","text":"La aplicaci\u00f3n funciona y se muestra una tabla, aunque no tiene barra de navegaci\u00f3n. Normalmente todos los controladores en iOS suelen ir incrustados en controladores contenedores, que son los que gestionan la navegaci\u00f3n, como UINavigationController , UITabBarController o UISplitViewController . Para nuestro ejercicio, lo m\u00e1s adecuado incrustrar la tabla en un Navigation Controller , seleccionando el controlador de la tabla en el storyboard y eligiendo Editor > Embed in > Navigation Controller . A\u00f1ade un t\u00edtulo para la tabla mediante la siguiente l\u00ednea de c\u00f3digo en viewDidLoad de TableViewController (o si lo prefieres, desde el Interface Builder ): self . title = \"Mi tabla personalizada\"","title":"A\u00f1adiendo la barra de navegaci\u00f3n"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#personalizacion-con-efecto-zebra","text":"Una vez tenemos las celdas hechas vamos a personalizar la tabla un poco m\u00e1s, a\u00f1adiendo un fondo a las celdas pares y otro a las impares, lo que se conoce como efecto zebra . Para esto necesitaremos dos im\u00e1genes m\u00e1s que se pueden descargar aqu\u00ed y a\u00f1adirlas a los Assets . Abrimos la vista de la celda en el storyboard y arrastramos un UIImageView ocupando todo el espacio de la celda. Es necesario enviar esta vista al fondo, con el men\u00fa Editor > Arrange > Send to back . Si en el modo visual se van descolocando las vistas de la celda cuando las mueves (aunque esto no deber\u00eda ocurrir con las \u00faltimas versiones de XCode), ajusta los tama\u00f1os desde el Size Inspector . En el fichero TableViewCell.swift enlazamos el nuevo UIImageView , como hemos hecho con el resto de elementos, y lo llamamos fondo . Ahora, en la clase TableViewController , dentro del m\u00e9todo cellForRowAt a\u00f1adimos lo siguiente justo antes de return cell if indexPath . row % 2 != 0 { cell . fondo . image = UIImage ( named : \"fondo_celda1.png\" ) } else { cell . fondo . image = UIImage ( named : \"fondo_celda2.png\" ) } Si ejecutamos ahora el proyecto tendremos nuestra tabla con las celdas personalizadas:","title":"Personalizaci\u00f3n con efecto zebra"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#ajuste-de-las-constraints","text":"S\u00f3lo hay un problema: como hemos comentado anteriormente, se ha dise\u00f1ado la vista para un iPhone en concreto (iPhone 14 Pro por defecto), y si ejecutamos el simulador con otro iPhone (por ejemplo el SE) los elementos de la celda nos saldr\u00e1n descolocados. Para que salgan bien nos falta ajustar las constraints de la vista. Para esto, seleccionamos el TableViewCell desde el storyboard , y en la parte inferior (\"All Views in Table View Cell\") marcamos \"All Views in TableViewController\" -> \"Reset to Suggested Constraints\". Probamos y vemos que la tabla es correcta, incluso rotando el dispositivo. Esta opci\u00f3n de Reset te puede sacar de m\u00e1s de un apuro cuando el ajustar el autolayout sea complicado. Recomiendo probar primero con ella, y si no funciona a la primera entonces ajustar las constraints a mano. Si se te queda muy corta la imagen del fondo cuando rotas el dispositivo puedes seleccionar la opci\u00f3n \"Scale to Fill\" en el inspector de atributos:","title":"Ajuste de las constraints"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#insertar-datos-en-la-tabla","text":"Para finalizar, extenderemos nuestro programa con las siguientes opciones: a) Vamos a rellenar las celdas de la tabla con datos de libros. Para ello, crearemos una nueva clase (con File > New > Swift file ) a la que llamaremos Libro . Reemplaza en este fichero import Foundation por import UIKit , y crea la clase con un String que ser\u00e1 el t\u00edtulo del libro, otro String que ser\u00e1 el autor y una imagen ( UIImage ) que ser\u00e1 la portada. A\u00f1ade tambi\u00e9n un m\u00e9todo init para inicializar las variables de la clase. b) Ahora crearemos un array dentro de la clase TableViewController , lo inicializamos y lo completamos con los 3 libros que prefieras. Cada elemento del array ser\u00e1 de la clase Libro . c) Una vez creado el array de libros vamos a mostrarlos en nuestra tabla. Para ello deberemos modificar los m\u00e9todos de la clase TableViewController , asignando los datos del array a las celdas correspondientes. d) Cuando hayamos terminado, comprobamos que la aplicaci\u00f3n funciona seg\u00fan lo esperado.","title":"Insertar datos en la tabla"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#ejercicio-2-personalizacion-de-toolbars","text":"Los ToolBars , al igual que la mayor parte de componentes, se pueden personalizar para conseguir las funcionalidades que deseemos para nuestras apps. En el siguiente ejemplo vamos a crear una vista ToolBar personalizada con una imagen de fondo, estilos para los botones, a\u00f1adiendo botones de distinto tipo, etc. Comenzamos creando un nuevo proyecto de tipo iOS > App con el nombre ejercicio_toolbar y con interfaz Storyboard .","title":"Ejercicio 2- Personalizaci\u00f3n de ToolBars"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#diseno-de-la-vista","text":"Abrimos la vista principal del storyboard , arrastramos un objeto UIToolBar y lo situamos en la parte superior. Tambi\u00e9n vamos a a\u00f1adir un objeto UILabel en el centro de la vista. Ahora vamos a a\u00f1adir los elementos que deseemos sobre el ToolBar . En nuestro caso arrastraremos desde el listado de objetos (en el siguiente orden) un Text Field , un Flexible Space Bar y un Segmented Control . Borraremos el bot\u00f3n Item de la izquierda. El ToolBar debe quedar de la siguiente manera: Como podemos observar, la funci\u00f3n del objeto Flexible Space no es m\u00e1s que a\u00f1adir un espacio flexible entre dos objetos dentro de un ToolBar . Una vez que tenemos la barra con todos sus elementos vamos a definir los elementos dentro de la clase. Dentro del c\u00f3digo de la clase ViewController a\u00f1adimos los siguientes outlets: @IBOutlet weak var toolBar : UIToolbar ! @IBOutlet weak var textField : UITextField ! @IBOutlet weak var segmentedControl : UISegmentedControl ! // Para la etiqueta centrada en la vista @IBOutlet weak var segmentLabel : UILabel ! Seguidamente tenemos que enlazar los outlets dentro de la vista. Si ejecutamos el c\u00f3digo, es posible que el toolbar y el label salgan descolocados (o que no salgan) cuando rotemos el dispositivo.","title":"Dise\u00f1o de la vista"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#ajuste-de-las-constraints_1","text":"Vamos a a\u00f1adir constraints desde XCode para fijar los m\u00e1rgenes. Selecciona el toolbar, y a\u00f1ade las siguientes constraints (arriba, izquierda, derecha) marcando Constrain to margins para que no se solape con la barra de estado: Vamos a centrar ahora el label , a\u00f1adiendo restricciones de centrado horizontal y vertical: Puedes ver los constraints a\u00f1adidos para cada elemento en el Size inspector . Por ejemplo, para el label tendr\u00edamos:","title":"Ajuste de las constraints"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#acciones","text":"Ahora vamos a implementar la acci\u00f3n del Segmented Control . Para ello declaramos el siguiente m\u00e9todo dentro de la clase ViewController : @IBAction func segmentedControlIndexChanged ( _ sender : Any ) { self . segmentLabel . text = self . segmentedControl . selectedSegmentIndex == 0 ? \"Segmento 1\" : \"Segmento 2\" } Para que el m\u00e9todo se invoque cuando se pulsa un bot\u00f3n del Segmented Control , deberemos enlazarlo con la vista. En este momento ya podemos ejecutar el proyecto por primera vez y comprobar que al pulsar sobre uno de los botones del Segmented Control la etiqueta Label cambia.","title":"Acciones"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#personalizacion-avanzada","text":"Ya tenemos un objeto ToolBar con una personalizaci\u00f3n b\u00e1sica funcionando. Ahora vamos a cambiarlo un poco m\u00e1s: vamos a a\u00f1adirle una imagen de fondo, a asignar un color de fondo al Segmented Control y a modificar el dise\u00f1o del TextField . Para hacer todo esto debemos cambiar el m\u00e9todo viewDidLoad de la clase ViewController de forma que quede de la siguiente manera: override func viewDidLoad () { super . viewDidLoad () // Vamos a a\u00f1adir la imagen de fondo como un imageView, pero esta vez sin usar el storyboard (por hacerlo distinto) let iv = UIImageView ( image : UIImage ( named : \"fondo_madera.png\" )) iv . frame = CGRect ( x : 0 , y : 0 , width : self . toolBar . frame . size . width , height : 44 ) iv . autoresizingMask = UIView . AutoresizingMask . flexibleWidth // A\u00f1adimos la subview self . toolBar . insertSubview ( iv , at : 0 ) // Cambiamos el color del SegmentedControl self . segmentedControl . tintColor = UIColor . brown // Personalizamos el TextField desde c\u00f3digo (tambi\u00e9n se podr\u00eda hacer desde el Interface Builder) self . textField . textColor = UIColor . white self . textField . borderStyle = UITextField . BorderStyle . none self . textField . background = UIImage ( named : \"fondo_textfield.png\" ) self . textField . placeholder = \"Escribe aqu\u00ed\" } Para que el c\u00f3digo funcione debemos descargarnos las im\u00e1genes desde aqu\u00ed y a\u00f1adirlas a los Assets del proyecto. Una vez hecho esto ya podemos ejecutarlo y ver c\u00f3mo ha cambiado. De esta forma tendremos nuestro componente ToolBar bastante personalizado, d\u00e1ndole a la aplicaci\u00f3n un aspecto visual diferenciado. La metodolog\u00eda que acabamos de seguir nos servir\u00eda tambi\u00e9n para personalizar los componentes UITabBar y UINavigationBar , entre otros.","title":"Personalizaci\u00f3n avanzada"},{"location":"sesion-2-controladores-avanzados.html","text":"En esta sesi\u00f3n veremos otros controladores que son comunes en aplicaciones iOS: el controlador paginado ( UIPageViewController ), las colecciones ( UICollectionViewController ) y el controlador de b\u00fasqueda para tablas ( UISearchController ). UIPageViewController El controlador paginado ( UIPageViewController ) sirve para poder cambiar entre varias p\u00e1ginas en pantalla que contienen informaci\u00f3n similar. Es una clase bastante configurable, ya que permite modificar: La orientaci\u00f3n de las vistas de las p\u00e1ginas (horizontal o vertical). El estilo de transici\u00f3n ( page-curl o scrolling ). Para la transici\u00f3n page-curl , la localizaci\u00f3n del eje. Para la transici\u00f3n scrolling , el espacio entre p\u00e1ginas. La clase UIPageViewController se considera un controlador contenedor ( container controller ). Los controladores contenedores pueden usarse para almacenar y gestionar m\u00faltiples view controllers , y cambiar de uno a otro cuando sea necesario. Otros ejemplos de controladores contenedores son UINavigationController , UITabBarController y UISplitViewController . Vamos a hacer una aplicaci\u00f3n de ejemplo para ver las posibilidades de este controlador y c\u00f3mo se programa. Ejercicio 1 - UIPageViewController Esta aplicaci\u00f3n tendr\u00e1 4 p\u00e1ginas que contienen informaci\u00f3n de ayuda. Los controladores paginados se suelen usar frecuentemente para esto. Nuestra app quedar\u00e1 del siguiente modo cuando la terminemos: Para empezar crearemos un proyecto con la plantilla App y con storyboard . Lo llamaremos ejercicio_pageview . Creaci\u00f3n de las vistas Primero vamos a arrastrar un UIPageViewController al storyboard (fuera de la primera vista). Haremos lo mismo con otro UIViewController gen\u00e9rico, que es el que contendr\u00e1 la informaci\u00f3n de las 4 pantallas. Usaremos la misma vista para las 4 pantallas porque en realidad su estructura es la misma. El controlador inicial del storyboard que viene por defecto tambi\u00e9n vamos a usarlo, para superponer sobre \u00e9l el controlador paginado, como veremos m\u00e1s adelante. Tenemos que asignar un identificador del storyboard para las dos vistas que hemos creado, de modo que podamos referenciarlas posteriormente desde nuestro c\u00f3digo. Asigna el nombre PageViewController al controlador Page View Controller , y PageContentViewController al UIViewController . En el PageViewController , verifica que el valor de transici\u00f3n es Scroll en lugar de Page Curl , ya que el segundo queda bien para libros pero no para nuestra aplicaci\u00f3n. Implementaci\u00f3n de la vista de contenido (PageContentViewController) Vamos a dise\u00f1ar primero la vista de contenido ( PageContentViewController ), que deber\u00eda quedar de forma similar a la siguiente: Tendremos un label arriba y una imagen detr\u00e1s que ocupa toda la pantalla excepto la barra de estado superior. Ya tenemos la vista de contenido, pero nos har\u00e1 falta un controlador para cambiarla din\u00e1micamente. Crea un nuevo fichero con File > New File > Cocoa Touch Class , ll\u00e1malo PageContentViewController y hazlo subclase de UIViewController , dejando desmarcado Also create Xib . Volvemos al storyboard, nos situamos en el PageContentViewController y asignamos el controlador a la vista: Enlazamos los outlets de la imagen y la etiqueta al controlador. Ll\u00e1malos del siguiente modo: @IBOutlet weak var titulo : UILabel ! @IBOutlet weak var imageView : UIImageView ! A\u00f1ade los siguientes atributos a los anteriores: var pageIndex = 0 var titleText = \"\" var imageFilename = \"\" La variable pageIndex almacenar\u00e1 el \u00edndice de la p\u00e1gina actual. Cambiamos tambi\u00e9n el m\u00e9todo viewDidLoad para actualizar la imagen de fondo y el texto: self . imageView . image = UIImage ( named : self . imageFilename ) self . titulo . text = self . titleText Implementaci\u00f3n del primer controlador (ViewController) Ya tenemos la vista de contenido. Vamos a modificar ahora la primera vista del storyboard, a\u00f1adiendo un bot\u00f3n Start again , abajo y centrado: Crearemos una acci\u00f3n de este bot\u00f3n con ViewController . A este m\u00e9todo lo que llamaremos restart . Implementaci\u00f3n del controlador paginado (PageViewController) La estructura que vamos a seguir es la siguiente: Por tanto, nuestro controlador paginado gestionar\u00e1 cuatro controladores de la misma clase. Para usar este controlador, lo primero que tenemos que hacer es adoptar el protocolo UIPageViewControllerDataSource . El data source es el responsable de gestionar los controladores de las vistas de contenidos cuando se le pidan, por lo que en los m\u00e9todos de este protocolo indicaremos qu\u00e9 contenido mostrar para cada p\u00e1gina. En este ejemplo, usaremos la clase ViewController como data source para la instancia de UIPageViewController que hemos creado. Por esto es necesario indicar que la clase ViewController implementa el protocolo UIPageViewControllerDataSource . Esta clase ViewController tambi\u00e9n ser\u00e1 la responsable de proporcionar los datos de las p\u00e1ginas (im\u00e1genes y t\u00edtulos). Abre el fichero ViewController.swift y a\u00f1ade el delegado y estas tres propiedades (el modelo de datos): class ViewController : UIViewController , UIPageViewControllerDataSource , UIPageViewControllerDelegate { let pageTitles = [ \"Over 200 Tips and Tricks\" , \"Discover Hidden Features\" , \"Bookmark Favorite Tip\" , \"Free Regular Update\" ] let pageImages = [ \"page1.png\" , \"page2.png\" , \"page3.png\" , \"page4.png\" ] var pageViewController : UIPageViewController ? Puedes descargar las im\u00e1genes que vamos a usar desde aqu\u00ed , y a\u00f1adirlas a los Assets del proyecto. Ya hemos creado el modelo de datos, pero nos falta implementar los m\u00e9todos del protocolo UIPageViewControllerDataSource , que deben ser al menos estos dos: viewControllerAfterViewController : Aqu\u00ed debemos indicar qu\u00e9 controlador mostrar en la siguiente p\u00e1gina. viewControllerBeforeViewController : Aqu\u00ed debemos indicar qu\u00e9 controlador mostrar en la p\u00e1gina anterior. A\u00f1ade las siguientes l\u00edneas a ViewController.swift : func viewControllerAtIndex ( index : Int ) -> PageContentViewController ? { if self . pageTitles . count == 0 || index >= self . pageTitles . count { return nil ; } // Crear un nuevo controlador de contenido y pasar los datos let pageContentViewController = self . storyboard ?. instantiateViewController ( withIdentifier : \"PageContentViewController\" ) as ! PageContentViewController pageContentViewController . imageFilename = self . pageImages [ index ]; pageContentViewController . titleText = self . pageTitles [ index ]; pageContentViewController . pageIndex = index ; return pageContentViewController ; } func pageViewController ( _ pageViewController : UIPageViewController , viewControllerBefore viewController : UIViewController ) -> UIViewController ? { let pvc = viewController as ! PageContentViewController var index = pvc . pageIndex ; if index == 0 || index == Foundation . NSNotFound { return nil } index -= 1 return self . viewControllerAtIndex ( index : index ) } func pageViewController ( _ pageViewController : UIPageViewController , viewControllerAfter viewController : UIViewController ) -> UIViewController ? { let pvc = viewController as ! PageContentViewController var index = pvc . pageIndex ; if index == Foundation . NSNotFound { return nil } index += 1 if index == self . pageTitles . count { return nil } return self . viewControllerAtIndex ( index : index ) } Como puedes ver, los m\u00e9todos delegados de pageViewController son muy sencillos. Simplemente miramos el \u00edndice actual, lo incrementamos o decrementamos en funci\u00f3n del m\u00e9todo y devolvemos el controlador a mostrar. El m\u00e9todo viewControllerAtIndex es el que muestra el controlador indicado. Para ello, como puede verse, usamos la siguiente instrucci\u00f3n: let pageContentViewController = self . storyboard ?. instantiateViewController ( withIdentifier : \"PageContentViewController\" ) as ! PageContentViewController Recuerda que hab\u00edamos asignado un storyboardID a los controladores. Este identificador lo hemos usado como referencia para crear las nuevas instancias, ya que si te fijas, PageContentViewController est\u00e1 suelto en el storyboard. Ya lo tenemos casi. Para mostrar un indicador de p\u00e1gina, tenemos que indicarle a iOS el n\u00famero de p\u00e1ginas (el n\u00famero de puntos a mostrar) y qu\u00e9 n\u00famero de p\u00e1gina se selecciona inicialmente. A\u00f1ade los siguientes m\u00e9todos al final de ViewController.swift : func presentationCount ( for pageViewController : UIPageViewController ) -> Int { return self . pageTitles . count } func presentationIndex ( for pageViewController : UIPageViewController ) -> Int { return 0 } Si no se implementan estos m\u00e9todos, no se mostrar\u00e1 el indicador de p\u00e1gina Por \u00faltimo, vamos a crear el controlador paginado. Lo haremos en el m\u00e9todo viewDidLoad de ViewController.swift . C\u00e1mbialo por el siguiente: override func viewDidLoad () { super . viewDidLoad () // Creamos el controlador paginado self . pageViewController = self . storyboard ?. instantiateViewController ( withIdentifier : \"PageViewController\" ) as ! UIPageViewController ? self . pageViewController ?. dataSource = self self . pageViewController ?. delegate = self ; // Creamos el primer controlador de contenido let startingViewController = self . viewControllerAtIndex ( index : 0 ) let viewControllers = [ startingViewController !] self . pageViewController ?. setViewControllers ( viewControllers , direction : UIPageViewController . NavigationDirection . forward , animated : false , completion : nil ) // Cambiamos el tama\u00f1o para que quepa el bot\u00f3n de abajo self . pageViewController ?. view . frame = CGRect ( x : 0 , y : 0 , width : self . view . frame . size . width , height : self . view . frame . size . height - 30 ) // A\u00f1adimos el primer controlador de contenido self . addChild ( self . pageViewController !) self . view . addSubview (( self . pageViewController ?. view ) ! ) self . pageViewController ?. didMove ( toParent : self ) } En este m\u00e9todo hemos creado una instancia de PageViewController . Despu\u00e9s especificamos el data source (la fuente de datos), que es la clase actual. Creamos el primer controlador de contenido, lo a\u00f1adimos a un array de controladores, y lo asignamos al controlador de la p\u00e1gina para mostrarlo. Compilamos y ejecutamos. Deber\u00eda funcionar, pero la vista sale descolocada debido a que falta ajustar las constraints . Para arreglarlo, seleccionamos el PageContentViewController en el storyboard, y marcamos Reset to suggested constraints . Ejecutamos de nuevo y podemos ver que el contenido ya se muestra bien, aunque falta todav\u00eda el bot\u00f3n de abajo. Seleccionamos nuestro ViewController y marcamos de nuevo Reset to suggested constraints . Ahora s\u00ed que vemos el bot\u00f3n. Lo \u00fanico que nos falta son los puntos de abajo, que est\u00e1n ah\u00ed pero que no se ven porque son del mismo color que el fondo. Vamos a cambiarles el color. Abre el fichero AppDelegate.swift , y a\u00f1ade las siguientes l\u00edneas en didFinishLaunchingWithOptions : let pageControl = UIPageControl . appearance () pageControl . pageIndicatorTintColor = UIColor . lightGray pageControl . currentPageIndicatorTintColor = UIColor . black pageControl . backgroundColor = UIColor . white Si se te \"chafa\" el bot\u00f3n de Start again , b\u00e1jalo un poco en la vista, resetea de nuevo las constraints y recompila. S\u00f3lo nos falta la implementaci\u00f3n de este bot\u00f3n para volver a la primera p\u00e1gina. El m\u00e9todo restart en ViewController.swift deber\u00eda quedar de la siguiente manera: @IBAction func restart ( _ sender : AnyObject ) { let startingViewController = self . viewControllerAtIndex ( index : 0 ) let viewControllers = [ startingViewController !] self . pageViewController ?. setViewControllers ( viewControllers , direction : UIPageViewController . NavigationDirection . reverse , animated : false , completion : nil ) } Si ejecutamos de nuevo la aplicaci\u00f3n, veremos que el bot\u00f3n ya funciona. En este ejercicio hemos hecho la parte principal para usar un UIPageViewController en un storyboard. Se ha implementado la transici\u00f3n en scroll , pero este controlador es muy configurable y como hemos visto podemos usarlo tambi\u00e9n para implementar una app con navegaci\u00f3n de tipo libro. Ejercicio 2 - UICollectionViewController Las colecciones pueden usarse como alternativa a las tablas cuando tenemos una distribuci\u00f3n de los elementos de tipo rejilla ( grid ), por ejemplo. Para implementar una colecci\u00f3n es necesario indicar el n\u00famero de secciones, el tama\u00f1o de las celdas, y especificar los contenidos de cada celda. El controlador de la colecci\u00f3n autom\u00e1ticamente reorganizar\u00e1 las posiciones de las celdas en funci\u00f3n de su tama\u00f1o y del tama\u00f1o de la pantalla. Ejemplo UICollectionViewController Vamos a hacer un ejercicio sencillo para ver c\u00f3mo funciona. Crearemos un proyecto llamado ejercicio_collection , de tipo iOS App con storyboard . Arrastramos al storyboard (fuera de la vista inicial) un nuevo UICollectionViewController , y movemos en el storyboard la flecha que apunta al controlador inicial para que ahora este sea nuestro UICollectionViewController . Borramos el ViewController.swift y tambi\u00e9n su controlador del storyboard , ya que no los necesitaremos. Creamos un nuevo controlador con New > File > Cocoa Touch . Lo llamaremos CollectionViewController , subclase de UICollectionViewController , dejando desmarcado Also create Xib . En el storyboard, seleccionamos nuestra vista e indicamos cu\u00e1l va a ser el controlador: Creaci\u00f3n de las celdas En la vista de UICollectionViewController veremos un rect\u00e1ngulo en la parte superior izquierda, que se corresponde con una celda. Vamos a crear una clase propia para las celdas, de forma que podamos configurarlas para darles el aspecto que queramos. El procedimiento es similar al que hicimos para las celdas personalizadas. Creamos una nueva clase llamada CollectionViewCell , subclase de UICollectionViewCell , y desmarcando Also create XIB . En el storyboard, seleccionamos la celda que hay dentro de nuestro controlador de colecciones, y cambiamos la clase UICollectionViewCell por la que hemos creado, CollectionViewCell . En la pesta\u00f1a de Attributes Inspector escribimos el identificador idCelda para nuestras celdas. Seleccionamos el objeto Collection View en el storyboard , y en el Size inspector cambiamos el tama\u00f1o de las celdas ( Cell Size ) a 100 x 100 puntos. Como puede verse, tenemos m\u00e1s atributos que podr\u00edamos cambiar, como el tama\u00f1o de la cabecera y pie, el espaciado entre celdas, o los insets , que se pueden usar para crear bordes alrededor de las celdas. Tambi\u00e9n tenemos que cambiar el tama\u00f1o de la celda, seleccionando en el storyBoard nuestro idCelda : En este ejercicio configuraremos las celdas para que muestren una imagen. Para ello, desde el Interface Builder arrastramos un UIImageView a la celda, de forma que ocupe todo su tama\u00f1o. Crearemos un outlet de la imagen en nuestra celda personalizada y lo llamamos imageView . Ya tenemos la vista preparada, s\u00f3lo falta a\u00f1adir los datos. Configurar los datos Nos queda configurar el data source , es decir, implementar los m\u00e9todos delegados de UICollectionViewDataSource para mostrar los datos de las celdas. Abre el fichero CollectionViewController.swift , y mira los m\u00e9todos de la secci\u00f3n UICollectionViewDataSource . Como puedes ver, nuestra clase debe implementar: numberOfSections . Como en una tabla, debemos indicar el n\u00famero de secciones. Este m\u00e9todo es opcional, y si no lo implementamos se asumir\u00e1 una s\u00f3la secci\u00f3n. numberOfItemsInSection . Aqu\u00ed indicaremos la cantidad de items (celdas) para cada secci\u00f3n. cellForItemAt : Como en una tabla, en este m\u00e9todo indicaremos el contenido de cada celda. Si quieres m\u00e1s informaci\u00f3n sobre los m\u00e9todos de un protocolo o de cualquier clase Cocoa, en la vista de c\u00f3digo de XCode puedes pinchar sobre el nombre del mismo con Option+click para ver la ayuda r\u00e1pida, o con Command+click para ver m\u00e1s opciones. Vamos a crear los datos de nuestra aplicaci\u00f3n. Descarga este fichero con im\u00e1genes, y a\u00f1\u00e1delas todas al proyecto. Crearemos un array en CollectionViewController para almacenarlas: var foodImages = [ String ]() Inicializamos el array al final del m\u00e9todo viewDidLoad de CollectionViewController . for i in 1. .< 17 { let image = \" \\( i ) .jpg\" self . foodImages . append ( image ) } Para un bucle for lo normal es usar fast enumeration, pero en casos como este (cuando tenemos rangos) podemos usar el estilo anterior. Modificamos los m\u00e9todos delegados desde CollectionViewController : override func collectionView ( _ collectionView : UICollectionView , numberOfItemsInSection section : Int ) -> Int { return self . foodImages . count } override func collectionView ( _ collectionView : UICollectionView , cellForItemAt indexPath : IndexPath ) -> UICollectionViewCell { let cell = collectionView . dequeueReusableCell ( withReuseIdentifier : \"idCelda\" , for : indexPath ) as ! CollectionViewCell // Configure the cell if let image = UIImage ( named : self . foodImages [ indexPath . row ]) { cell . imageView . image = image } return cell } Podemos comentar el m\u00e9todo numberOfSections , ya que su implementaci\u00f3n no es obligatoria. Si ejecutamos la aplicaci\u00f3n en el simulador, veremos algo como esto: Y en landscape podemos ver c\u00f3mo se adapta: Evidentemente, no queda muy bien que las im\u00e1genes est\u00e9n tan pegadas a los bordes. Vamos a cambiar esto con los insets , desde las propiedades de la colecci\u00f3n: Como puedes ver, ahora queda algo mejor. Desde c\u00f3digo tambi\u00e9n podemos jugar con los tama\u00f1os de los bordes cambiando los atributos del controlador en funci\u00f3n del dispositivo, pero para este ejemplo no es necesario. Adem\u00e1s podr\u00edamos hacer que cuando se pulse una imagen se mostrara una vista de la misma a pantalla completa, aunque esto tampoco lo implementaremos en este ejercicio. Ejercicio 3 - Controlador de b\u00fasqueda En las aplicaciones iOS es com\u00fan encontrar una barra de b\u00fasqueda en asociada a una tabla en la que se muestran los resultados de la b\u00fasqueda. Este comportamiento est\u00e1ndar se defin\u00eda, hasta iOS7 , con la clase UISearchDisplayController . Este controlador era bastante complejo, por lo que Apple decidi\u00f3 cambiarlo en iOS7 por UISearchController . Vamos a ver c\u00f3mo se implementa este \u00faltimo, ya que es bastante m\u00e1s sencillo, aunque aun as\u00ed no es trivial. Creaci\u00f3n de la tabla Crea un proyecto llamado ejercicio_search usando la plantilla App . Para empezar vamos a a\u00f1adir al storyboard principal ( Main ) un nuevo controlador de tipo Table View Controller . Haremos que nuestra tabla sea lo primero que aparezca cuando se lance la app arrastrando la flecha horizontal que apunta al primer controlador (la vista vac\u00eda) hacia nuestro nuevo Table View Controller . Ya podemos borrar la vista vac\u00eda del storyboard, que ahora comenzar\u00e1 con nuestra tabla. Podemos tambi\u00e9n borrar el fichero ViewController.swift , ya que estaba asociado a la vista que hemos borrado. Ya tenemos la vista de la tabla, pero vamos a crear tambi\u00e9n un fichero de c\u00f3digo como controlador para poder programar los elementos de la celda. Seleccionamos File > New > File > Cocoa Touch Class , y le damos el nombre TableViewController , subclase de UITableViewController , dejando sin marcar \" Also create XIB file \". Ahora tenemos que asignar la vista al controlador. Para ello, seleccionamos el controlador en el storyboard, y desde el Identity Inspector le asignamos la clase que hemos creado TableViewController , como se muestra en la imagen: Tambi\u00e9n embebemos el controlador en una barra de navegaci\u00f3n, seleccion\u00e1ndolo en el storyboard e indicando desde el men\u00fa de XCode Editor > Embed in > Navigation Controller . Para ponerle un t\u00edtulo, a\u00f1adimos el siguiente c\u00f3digo en el m\u00e9todo viewDidLoad del TableViewController : self . title = \"B\u00fasqueda\" Ahora vamoas a a\u00f1adir unos datos de ejemplo a la clase TableViewController : let contenido = [ \"En\" , \"un\" , \"lugar\" , \"de\" , \"la\" , \"mancha\" ] Y completamos el c\u00f3digo de de esta clase para gestionar la tabla: override func tableView ( _ tableView : UITableView , numberOfRowsInSection section : Int ) -> Int { // #warning Incomplete implementation, return the number of rows return contenido . count } override func tableView ( _ tableView : UITableView , cellForRowAt indexPath : IndexPath ) -> UITableViewCell { let cell = tableView . dequeueReusableCell ( withIdentifier : \"Cell\" , for : indexPath ) // Configure the cell... let c = contenido [ indexPath . row ] cell . textLabel !. text = c return cell } Por \u00faltimo, debemos enlazar la celda a nuestro controlador, indicando el nombre Cell que le hemos dado en el c\u00f3digo: En este punto ya podemos ejecutar el c\u00f3digo y tendremos una tabla funcional, aunque sin barra de b\u00fasqueda: Implementaci\u00f3n del controlador de b\u00fasqueda El controlador de b\u00fasqueda ha ido evolucionando con las distintas versiones de XCode. Antes de iOS7 , esto se hac\u00eda arrastrando un objeto de tipo Search Bar and Search Display Controller al principio de la tabla desde el Interface Builder . La gesti\u00f3n de esto era algo complicada, ya que ten\u00edamos varias conexiones que deb\u00edamos gestionar manualmente. Ahora , Search Display Controller es un controlador deprecated (obsoleto), y Apple recomienda usar la clase UISearchController introducida en iOS7 . Parad\u00f3jicamente, esta clase no est\u00e1 en el Interface Builder , y s\u00f3lo podemos usarla mediante c\u00f3digo, pero simplifica bastante el procedimiento. Es de esta forma como vamos a hacerlo en nuestro ejemplo. Para esto, primero debemos crear nuestro searchController , y un array searchResults que contendr\u00e1 los resultados filtrados de la b\u00fasqueda. Al principio de la clase TableViewController declararemos las siguientes variables (privadas, ya que no hace falta acceder a ellas desde fuera de la misma): private var searchController : UISearchController ? private var searchResults = [ String ]() En el m\u00e9todo viewDidLoad de TableViewController creamos la barra de b\u00fasqueda y la inicializamos. A\u00f1adimos lo siguiente al final del m\u00e9todo: // Creamos una tabla alternativa para visualizar los resultados cuando se seleccione la b\u00fasqueda let searchResultsController = UITableViewController ( style : . plain ) searchResultsController . tableView . dataSource = self searchResultsController . tableView . delegate = self // Asignamos esta tabla a nuestro controlador de b\u00fasqueda self . searchController = UISearchController ( searchResultsController : searchResultsController ) self . searchController ?. searchResultsUpdater = self // Especificamos el tama\u00f1o de la barra de b\u00fasqueda if let frame = self . searchController ?. searchBar . frame { self . searchController ?. searchBar . frame = CGRect ( x : frame . origin . x , y : frame . origin . y , width : frame . size . width , height : 44.0 ) } // La a\u00f1adimos a la cabecera de la tabla self . tableView . tableHeaderView = self . searchController ?. searchBar // Esto es para indicar que nuestra vista de tabla de b\u00fasqueda se superpondr\u00e1 a la ya existente self . definesPresentationContext = true Ahora tendremos que cambiar los m\u00e9todos numberOfRowsInSection y cellForRowAtIndexPath . Esto lo haremos porque en funci\u00f3n de si est\u00e1 o no activa la barra de b\u00fasqueda tendremos que mostrar una informaci\u00f3n u otra. Si la vista de la tabla es la dada por el controlador de b\u00fasqueda, tendremos que usar los elementos de la lista filtrada. En caso contrario, los de la lista principal. override func tableView ( _ tableView : UITableView , numberOfRowsInSection section : Int ) -> Int { let src = self . searchController ?. searchResultsController as ! UITableViewController if tableView == src . tableView { return self . searchResults . count } else { return self . contenido . count } } override func tableView ( _ tableView : UITableView , cellForRowAt indexPath : IndexPath ) -> UITableViewCell { let cell = tableView . dequeueReusableCell ( withIdentifier : \"Cell\" , for : indexPath ) let src = self . searchController ?. searchResultsController as ! UITableViewController let object : String ? if tableView == src . tableView { object = self . searchResults [ indexPath . row ] } else { object = contenido [ indexPath . row ] } cell . textLabel !. text = object return cell } A\u00f1ade el protocolo de la barra de b\u00fasqueda a la clase TableViewController . Este protocolo se llama UISearchResultsUpdating . A continuaci\u00f3n tenemos que crear el m\u00e9todo delegado para actualizar los datos de la tabla cuando el usuario modifique el texto de b\u00fasqueda. A\u00f1ade el siguiente c\u00f3digo: func updateSearchResults ( for searchController : UISearchController ) { // Cogemos el texto introducido en la barra de b\u00fasqueda let searchString = self . searchController ?. searchBar . text // Si la cadena de b\u00fasqueda es vac\u00eda, copiamos en searchResults todos los objetos if searchString == nil || searchString == \"\" { self . searchResults = self . contenido } // Si no, copiamos en searchResults s\u00f3lo los que coinciden con el texto de b\u00fasqueda else { let searchPredicate = NSPredicate ( format : \"SELF BEGINSWITH[c] %@\" , searchString !) let array = ( self . contenido as NSArray ). filtered ( using : searchPredicate ) self . searchResults = array as ! [ String ] } // Recargamos los datos de la tabla let tvc = self . searchController ?. searchResultsController as ! UITableViewController tvc . tableView . reloadData () // Deseleccionamos la celda de la tabla principal if let selected = tableView . indexPathForSelectedRow { tableView . deselectRow ( at : selected , animated : false ) } } Si ejecutamos el programa veremos que casi lo tenemos listo. El \u00fanico peque\u00f1o problema es que fallar\u00e1 estrepitosamente cuando se pulse sobre la barra de b\u00fasqueda. Para arreglar este error, debemos asignar el prototipo de la celda del storyboard. En CellForRowAt IndexPath sustituye la siguiente l\u00ednea: let cell = tableView . dequeueReusableCell ( withIdentifier : \"Cell\" , for : indexPath ) Por esta otra: let cell = self . tableView . dequeueReusableCell ( withIdentifier : \"Cell\" , for : indexPath ) Si ejecutas de nuevo, la barra de b\u00fasqueda debe funcionar (aparece un teclado y es funcional). Sin embargo, en caso de que quisi\u00e9ramos leer o usar el valor que el usuario ha seleccionado, todav\u00eda nos har\u00eda falta a\u00f1adir lo siguiente: override func tableView ( _ tableView : UITableView , didSelectRowAt indexPath : IndexPath ) { let object : String if let indexPath = self . tableView . indexPathForSelectedRow { object = self . contenido [ indexPath . row ] } else { let sc = self . searchController ?. searchResultsController as ! UITableViewController object = self . searchResults [( sc . tableView . indexPathForSelectedRow ?. row ) ! ] } print ( object ) } Como puede verse este m\u00e9todo asigna una fuente de datos u otra dependiendo de si la barra de b\u00fasqueda est\u00e1 seleccionada o no. Esto es lo b\u00e1sico para crear una barra de b\u00fasqueda asociada a una tabla. Como puedes ver, el dise\u00f1o de Cocoa podr\u00eda ser m\u00e1s sencillo pero tampoco es es demasiado complicado, sobre todo si se compara con c\u00f3mo se hac\u00eda antes de iOS7.","title":"2- Controladores avanzados"},{"location":"sesion-2-controladores-avanzados.html#uipageviewcontroller","text":"El controlador paginado ( UIPageViewController ) sirve para poder cambiar entre varias p\u00e1ginas en pantalla que contienen informaci\u00f3n similar. Es una clase bastante configurable, ya que permite modificar: La orientaci\u00f3n de las vistas de las p\u00e1ginas (horizontal o vertical). El estilo de transici\u00f3n ( page-curl o scrolling ). Para la transici\u00f3n page-curl , la localizaci\u00f3n del eje. Para la transici\u00f3n scrolling , el espacio entre p\u00e1ginas. La clase UIPageViewController se considera un controlador contenedor ( container controller ). Los controladores contenedores pueden usarse para almacenar y gestionar m\u00faltiples view controllers , y cambiar de uno a otro cuando sea necesario. Otros ejemplos de controladores contenedores son UINavigationController , UITabBarController y UISplitViewController . Vamos a hacer una aplicaci\u00f3n de ejemplo para ver las posibilidades de este controlador y c\u00f3mo se programa.","title":"UIPageViewController"},{"location":"sesion-2-controladores-avanzados.html#ejercicio-1-uipageviewcontroller","text":"Esta aplicaci\u00f3n tendr\u00e1 4 p\u00e1ginas que contienen informaci\u00f3n de ayuda. Los controladores paginados se suelen usar frecuentemente para esto. Nuestra app quedar\u00e1 del siguiente modo cuando la terminemos: Para empezar crearemos un proyecto con la plantilla App y con storyboard . Lo llamaremos ejercicio_pageview .","title":"Ejercicio 1 - UIPageViewController"},{"location":"sesion-2-controladores-avanzados.html#ejercicio-2-uicollectionviewcontroller","text":"Las colecciones pueden usarse como alternativa a las tablas cuando tenemos una distribuci\u00f3n de los elementos de tipo rejilla ( grid ), por ejemplo. Para implementar una colecci\u00f3n es necesario indicar el n\u00famero de secciones, el tama\u00f1o de las celdas, y especificar los contenidos de cada celda. El controlador de la colecci\u00f3n autom\u00e1ticamente reorganizar\u00e1 las posiciones de las celdas en funci\u00f3n de su tama\u00f1o y del tama\u00f1o de la pantalla.","title":"Ejercicio 2 - UICollectionViewController"},{"location":"sesion-2-controladores-avanzados.html#ejemplo-uicollectionviewcontroller","text":"Vamos a hacer un ejercicio sencillo para ver c\u00f3mo funciona. Crearemos un proyecto llamado ejercicio_collection , de tipo iOS App con storyboard . Arrastramos al storyboard (fuera de la vista inicial) un nuevo UICollectionViewController , y movemos en el storyboard la flecha que apunta al controlador inicial para que ahora este sea nuestro UICollectionViewController . Borramos el ViewController.swift y tambi\u00e9n su controlador del storyboard , ya que no los necesitaremos. Creamos un nuevo controlador con New > File > Cocoa Touch . Lo llamaremos CollectionViewController , subclase de UICollectionViewController , dejando desmarcado Also create Xib . En el storyboard, seleccionamos nuestra vista e indicamos cu\u00e1l va a ser el controlador:","title":"Ejemplo UICollectionViewController"},{"location":"sesion-2-controladores-avanzados.html#ejercicio-3-controlador-de-busqueda","text":"En las aplicaciones iOS es com\u00fan encontrar una barra de b\u00fasqueda en asociada a una tabla en la que se muestran los resultados de la b\u00fasqueda. Este comportamiento est\u00e1ndar se defin\u00eda, hasta iOS7 , con la clase UISearchDisplayController . Este controlador era bastante complejo, por lo que Apple decidi\u00f3 cambiarlo en iOS7 por UISearchController . Vamos a ver c\u00f3mo se implementa este \u00faltimo, ya que es bastante m\u00e1s sencillo, aunque aun as\u00ed no es trivial.","title":"Ejercicio 3 - Controlador de b\u00fasqueda"},{"location":"sesion-2-controladores-avanzados.html#creacion-de-la-tabla","text":"Crea un proyecto llamado ejercicio_search usando la plantilla App . Para empezar vamos a a\u00f1adir al storyboard principal ( Main ) un nuevo controlador de tipo Table View Controller . Haremos que nuestra tabla sea lo primero que aparezca cuando se lance la app arrastrando la flecha horizontal que apunta al primer controlador (la vista vac\u00eda) hacia nuestro nuevo Table View Controller . Ya podemos borrar la vista vac\u00eda del storyboard, que ahora comenzar\u00e1 con nuestra tabla. Podemos tambi\u00e9n borrar el fichero ViewController.swift , ya que estaba asociado a la vista que hemos borrado. Ya tenemos la vista de la tabla, pero vamos a crear tambi\u00e9n un fichero de c\u00f3digo como controlador para poder programar los elementos de la celda. Seleccionamos File > New > File > Cocoa Touch Class , y le damos el nombre TableViewController , subclase de UITableViewController , dejando sin marcar \" Also create XIB file \". Ahora tenemos que asignar la vista al controlador. Para ello, seleccionamos el controlador en el storyboard, y desde el Identity Inspector le asignamos la clase que hemos creado TableViewController , como se muestra en la imagen: Tambi\u00e9n embebemos el controlador en una barra de navegaci\u00f3n, seleccion\u00e1ndolo en el storyboard e indicando desde el men\u00fa de XCode Editor > Embed in > Navigation Controller . Para ponerle un t\u00edtulo, a\u00f1adimos el siguiente c\u00f3digo en el m\u00e9todo viewDidLoad del TableViewController : self . title = \"B\u00fasqueda\" Ahora vamoas a a\u00f1adir unos datos de ejemplo a la clase TableViewController : let contenido = [ \"En\" , \"un\" , \"lugar\" , \"de\" , \"la\" , \"mancha\" ] Y completamos el c\u00f3digo de de esta clase para gestionar la tabla: override func tableView ( _ tableView : UITableView , numberOfRowsInSection section : Int ) -> Int { // #warning Incomplete implementation, return the number of rows return contenido . count } override func tableView ( _ tableView : UITableView , cellForRowAt indexPath : IndexPath ) -> UITableViewCell { let cell = tableView . dequeueReusableCell ( withIdentifier : \"Cell\" , for : indexPath ) // Configure the cell... let c = contenido [ indexPath . row ] cell . textLabel !. text = c return cell } Por \u00faltimo, debemos enlazar la celda a nuestro controlador, indicando el nombre Cell que le hemos dado en el c\u00f3digo: En este punto ya podemos ejecutar el c\u00f3digo y tendremos una tabla funcional, aunque sin barra de b\u00fasqueda:","title":"Creaci\u00f3n de la tabla"},{"location":"sesion-2-controladores-avanzados.html#implementacion-del-controlador-de-busqueda","text":"El controlador de b\u00fasqueda ha ido evolucionando con las distintas versiones de XCode. Antes de iOS7 , esto se hac\u00eda arrastrando un objeto de tipo Search Bar and Search Display Controller al principio de la tabla desde el Interface Builder . La gesti\u00f3n de esto era algo complicada, ya que ten\u00edamos varias conexiones que deb\u00edamos gestionar manualmente. Ahora , Search Display Controller es un controlador deprecated (obsoleto), y Apple recomienda usar la clase UISearchController introducida en iOS7 . Parad\u00f3jicamente, esta clase no est\u00e1 en el Interface Builder , y s\u00f3lo podemos usarla mediante c\u00f3digo, pero simplifica bastante el procedimiento. Es de esta forma como vamos a hacerlo en nuestro ejemplo. Para esto, primero debemos crear nuestro searchController , y un array searchResults que contendr\u00e1 los resultados filtrados de la b\u00fasqueda. Al principio de la clase TableViewController declararemos las siguientes variables (privadas, ya que no hace falta acceder a ellas desde fuera de la misma): private var searchController : UISearchController ? private var searchResults = [ String ]() En el m\u00e9todo viewDidLoad de TableViewController creamos la barra de b\u00fasqueda y la inicializamos. A\u00f1adimos lo siguiente al final del m\u00e9todo: // Creamos una tabla alternativa para visualizar los resultados cuando se seleccione la b\u00fasqueda let searchResultsController = UITableViewController ( style : . plain ) searchResultsController . tableView . dataSource = self searchResultsController . tableView . delegate = self // Asignamos esta tabla a nuestro controlador de b\u00fasqueda self . searchController = UISearchController ( searchResultsController : searchResultsController ) self . searchController ?. searchResultsUpdater = self // Especificamos el tama\u00f1o de la barra de b\u00fasqueda if let frame = self . searchController ?. searchBar . frame { self . searchController ?. searchBar . frame = CGRect ( x : frame . origin . x , y : frame . origin . y , width : frame . size . width , height : 44.0 ) } // La a\u00f1adimos a la cabecera de la tabla self . tableView . tableHeaderView = self . searchController ?. searchBar // Esto es para indicar que nuestra vista de tabla de b\u00fasqueda se superpondr\u00e1 a la ya existente self . definesPresentationContext = true Ahora tendremos que cambiar los m\u00e9todos numberOfRowsInSection y cellForRowAtIndexPath . Esto lo haremos porque en funci\u00f3n de si est\u00e1 o no activa la barra de b\u00fasqueda tendremos que mostrar una informaci\u00f3n u otra. Si la vista de la tabla es la dada por el controlador de b\u00fasqueda, tendremos que usar los elementos de la lista filtrada. En caso contrario, los de la lista principal. override func tableView ( _ tableView : UITableView , numberOfRowsInSection section : Int ) -> Int { let src = self . searchController ?. searchResultsController as ! UITableViewController if tableView == src . tableView { return self . searchResults . count } else { return self . contenido . count } } override func tableView ( _ tableView : UITableView , cellForRowAt indexPath : IndexPath ) -> UITableViewCell { let cell = tableView . dequeueReusableCell ( withIdentifier : \"Cell\" , for : indexPath ) let src = self . searchController ?. searchResultsController as ! UITableViewController let object : String ? if tableView == src . tableView { object = self . searchResults [ indexPath . row ] } else { object = contenido [ indexPath . row ] } cell . textLabel !. text = object return cell } A\u00f1ade el protocolo de la barra de b\u00fasqueda a la clase TableViewController . Este protocolo se llama UISearchResultsUpdating . A continuaci\u00f3n tenemos que crear el m\u00e9todo delegado para actualizar los datos de la tabla cuando el usuario modifique el texto de b\u00fasqueda. A\u00f1ade el siguiente c\u00f3digo: func updateSearchResults ( for searchController : UISearchController ) { // Cogemos el texto introducido en la barra de b\u00fasqueda let searchString = self . searchController ?. searchBar . text // Si la cadena de b\u00fasqueda es vac\u00eda, copiamos en searchResults todos los objetos if searchString == nil || searchString == \"\" { self . searchResults = self . contenido } // Si no, copiamos en searchResults s\u00f3lo los que coinciden con el texto de b\u00fasqueda else { let searchPredicate = NSPredicate ( format : \"SELF BEGINSWITH[c] %@\" , searchString !) let array = ( self . contenido as NSArray ). filtered ( using : searchPredicate ) self . searchResults = array as ! [ String ] } // Recargamos los datos de la tabla let tvc = self . searchController ?. searchResultsController as ! UITableViewController tvc . tableView . reloadData () // Deseleccionamos la celda de la tabla principal if let selected = tableView . indexPathForSelectedRow { tableView . deselectRow ( at : selected , animated : false ) } } Si ejecutamos el programa veremos que casi lo tenemos listo. El \u00fanico peque\u00f1o problema es que fallar\u00e1 estrepitosamente cuando se pulse sobre la barra de b\u00fasqueda. Para arreglar este error, debemos asignar el prototipo de la celda del storyboard. En CellForRowAt IndexPath sustituye la siguiente l\u00ednea: let cell = tableView . dequeueReusableCell ( withIdentifier : \"Cell\" , for : indexPath ) Por esta otra: let cell = self . tableView . dequeueReusableCell ( withIdentifier : \"Cell\" , for : indexPath ) Si ejecutas de nuevo, la barra de b\u00fasqueda debe funcionar (aparece un teclado y es funcional). Sin embargo, en caso de que quisi\u00e9ramos leer o usar el valor que el usuario ha seleccionado, todav\u00eda nos har\u00eda falta a\u00f1adir lo siguiente: override func tableView ( _ tableView : UITableView , didSelectRowAt indexPath : IndexPath ) { let object : String if let indexPath = self . tableView . indexPathForSelectedRow { object = self . contenido [ indexPath . row ] } else { let sc = self . searchController ?. searchResultsController as ! UITableViewController object = self . searchResults [( sc . tableView . indexPathForSelectedRow ?. row ) ! ] } print ( object ) } Como puede verse este m\u00e9todo asigna una fuente de datos u otra dependiendo de si la barra de b\u00fasqueda est\u00e1 seleccionada o no. Esto es lo b\u00e1sico para crear una barra de b\u00fasqueda asociada a una tabla. Como puedes ver, el dise\u00f1o de Cocoa podr\u00eda ser m\u00e1s sencillo pero tampoco es es demasiado complicado, sobre todo si se compara con c\u00f3mo se hac\u00eda antes de iOS7.","title":"Implementaci\u00f3n del controlador de b\u00fasqueda"},{"location":"sesion-3-apps-universales.html","text":"En esta primera parte empezaremos explicando c\u00f3mo programar apps universales cuya interfaz se adapte a modelos y tama\u00f1os diferentes de iPhone y iPad, teniendo en cuenta si las vistas son compactas o regulares. Finalmente haremos un ejercicio usando Split View adaptado a los distintos dispositivos. Aplicaciones universales En este apartado trataremos las aplicaciones universales , veremos qu\u00e9 son, qu\u00e9 ventajas e inconvenientes podemos encontrar a la hora de dise\u00f1arlas, c\u00f3mo programarlas y las recomendaciones de uso por parte de Apple. Y vamos a hacerlo usando un controlador de tipo Split View como base. Introducci\u00f3n Utilizamos el t\u00e9rmino universal para denominar a todas aquellas aplicaciones adaptadas tanto al iPad como al iPhone. Los usuarios agradecen este tipo de aplicaciones ya que pueden usarlas en todos sus dispositivos y adem\u00e1s cuanto mayor sea el n\u00famero de dispositivos compatibles m\u00e1s clientes potenciales podremos captar. El desarrollo de una aplicaci\u00f3n universal ahorra tiempo de desarrollo respecto a hacer apps independientes para cada dispositivo, ya que evidentemente programaremos un s\u00f3lo proyecto en lugar de varios. Tambi\u00e9n tiene ventajas para las actualizaciones, ya que tendremos que preocuparnos de implementar los cambios s\u00f3lo en una aplicaci\u00f3n. Dise\u00f1ando la interfaz de una aplicaci\u00f3n universal El primer paso para hacer una aplicaci\u00f3n universal desde cero es dise\u00f1ar la interfaz para cada una de las vistas. En versiones anteriores de iOS se separaba por un lado las de iPhone de las de iPad usando distintos ficheros .xib . Actualmente se debe hacer de forma conjunta usando los storyboards y autolayout (en el caso de UIKit, que es lo que veremos en la asignatura), o bien mediante SwiftUI. A continuaci\u00f3n detallaremos algunos de los puntos que debemos tener en cuenta a la hora de dise\u00f1ar una interfaz universal: Orientaci\u00f3n. Con la informaci\u00f3n sobre la orientaci\u00f3n del dispositivo podremos adaptar la interfaz de la aplicaci\u00f3n para acomodarla al mismo. En aplicaciones para iPhone, la adaptaci\u00f3n de la interfaz no es tan importante como en aplicaciones para iPad. Estructura de las vistas . La pantalla del iPad, al ser m\u00e1s grande que la del iPhone permite al usuario acceder a m\u00e1s informaci\u00f3n en pantalla. Comportamiento de las API. Componentes como los popover, por ejemplo, se comportan de forma distinta en un iphone y en un ipad. Caracter\u00edsticas Hardware. Distintos dispositivos iOS poseen distintas funcionalidades hardware, como el n\u00famero de c\u00e1maras, la capacidad de gestionar dynamic islands , etc. Hay que tener en cuenta este tipo de caracter\u00edsticas a la hora de implementar una aplicaci\u00f3n universal. Gestos. A veces en la pantalla del iPad podemos realizar m\u00e1s gestos que en la del iPhone debido a su tama\u00f1o. Por ejemplo, se pueden usar cuatro dedos al mismo tiempo. Arte. Hay que tener en cuenta la resoluci\u00f3n de los distintos dispositivos, almacenando las im\u00e1genes en los Assets usando varias resoluciones. Una alternativa recomendada por Apple es usar archivos PDF en los Assets. Programando una aplicaci\u00f3n universal Como acabamos de ver, para programar una aplicaci\u00f3n universal en iOS debemos tener en cuenta las caracter\u00edsticas de nuestro dispositivo. Para esto podemos usar c\u00f3digo condicional. Por ejemplo, podemos detectar en cualquier momento si estamos ejecutando nuestra app con un iPhone o un iPad con la instrucci\u00f3n UIDevice.currentDevice().userInterfaceIdiom . Para entender mejor en qu\u00e9 consiste una aplicaci\u00f3n universal y c\u00f3mo podemos comenzar a programar una, vamos a realizar un ejemplo paso a paso. Antes de XCode 6, cuando se creaba un nuevo proyecto se generaban dos vistas distintas , una adaptada al tama\u00f1o de pantalla de un iPhone y otra adaptada a un iPad. Sin embargo, desde hace bastantes a\u00f1os, Apple recomienda hacer las aplicaciones usando siempre autolayout para adaptar el tama\u00f1o de los elementos al de cualquier pantalla, tanto si es iPhone como iPad, en lugar de usar .xib separados, a no ser que sea estrictamente necesario (que a veces lo es). Ejemplo de vistas universales Comenzamos abriendo XCode y creando un nuevo proyecto de tipo iOS > App al que llamaremos prueba_universal . Primero abrimos la vista principal del storyboard . Podemos ver c\u00f3mo quedar\u00eda en distintos dispositivos sin llegar a ejecutar el simulador: Arrastra un UILabel a la vista principal del storyboard y su\u00e9ltala por el centro de la vista. En el storyboard pincha en la parte inferior, donde aparece el modelo (por ejemplo, iPhone14). y elige otro modelo, por ejemplo un iPad. La etiqueta se mover\u00e1 a otro lugar. Si lo rotamos (en la parte inferior, con el icono de un cuadrado que tiene encima una flecha), es posible que hasta desaparezca de la pantalla. Ajusta las opciones de autolayout para la etiqueta. Si no controlas todav\u00eda autolayout , puedes seleccionar el tri\u00e1ngulo de la parte inferior ( Resolve autolayout issues ) y elegir Reset to suggested constraints . Si mueves el UILabel a otra posici\u00f3n, ver\u00e1s que las l\u00edneas azules de gu\u00eda aparecen ahora de color naranja. Esto es porque todav\u00eda tiene las constraints anteriores y son inconsistentes con la nueva posici\u00f3n. Para actualizar la vista, pincha de nuevo en el tri\u00e1ngulo y selecciona Update constraint constants . Puedes ampliar o reducir los previews haciendo zoom con los dedos en el trackpad, o usando los controles de la parte inferior. En principio es sencillo, aunque a veces es complicado saber c\u00f3mo ajustar las constraints y manejar autolayout . Las opciones de autolayout pueden parecer f\u00e1ciles de interpretar, pero a la hora de la verdad no es f\u00e1cil dejar una vista como queremos. Vistas dependientes del dispositivo A veces nos interesa tener vistas separadas para distintos tama\u00f1os, de forma que podamos aprovechar mejor la pantalla. Como se ha mencionado anteriormente, se recomienda usar interfaces diferenciados, ya que simplemente escalar el tama\u00f1o de los componentes para pantallas m\u00e1s grandes no suele quedar bien. Para el dise\u00f1o del interfaz, en lugar de distinguir entre iPhone e iPad, Apple introdujo en XCode 7 el concepto de size clases . La idea es pensar el dise\u00f1o s\u00f3lo para dos tama\u00f1os: Compact : Cuando tenemos un tama\u00f1o Compact debemos hacer un interfaz m\u00ednimo que muestre s\u00f3lo la informaci\u00f3n m\u00e1s relevante de forma compacta. Regular : En un tama\u00f1o Regular podemos a\u00f1adir m\u00e1s elementos y hacer un interfaz completo, ya que dispondremos de m\u00e1s espacio en la pantalla. Adem\u00e1s, estos tama\u00f1os pueden venir dados para la anchura ( Width ) o la altura ( Height ). Por tanto, debemos tener en cuenta tres factores: Dispositivo . iPhone o iPad. Orientaci\u00f3n . Horizontal o vertical. Tama\u00f1o . Compacto o regular. B\u00e1sicamente (aunque en realidad es algo m\u00e1s complicado), los dispositivos de Apple tienen los siguientes tama\u00f1os: En la imagen, el iPhone que se ve en arriba a la derecha es un iPhone 6s/7s plus (o iPhone X), que son m\u00e1s grandes que otros iphones y por tanto tienen un tama\u00f1o regular cuando el m\u00f3vil est\u00e1 apaisado. Puedes ver un listado completo de los tama\u00f1os al final de este enlace . Es m\u00e1s complicado porque hay que tener en cuenta que no tenemos que asumir que siempre los tama\u00f1os de vista son constantes , ya que por ejemplo nuestra app en un iPad podr\u00eda mostrarse en una zona compacta de la pantalla en lugar de usar la pantalla completa. Por tanto, siempre hay que dise\u00f1ar las vistas en modo compacto y regular. En la ventana inferior de XCode podemos cambiar el tipo de dispositivo, su orientaci\u00f3n, y en el caso del iPad, su adaptaci\u00f3n. Independientemente de lo que seleccionemos, los cambios que hagamos aqu\u00ed sobre la vista se aplicar\u00e1n a todos los dispositivos. Es posible presentar un componente (por ejemplo, un bot\u00f3n o una etiqueta) s\u00f3lo para un tama\u00f1o determinado. Para esto, puedes seleccionarlo y pinchar en el s\u00edmbolo + que aparece junto a Installed en las propiedades de nuestro componente. Si por ejemplo elegimos width Compact y height Regular ( wC hR ) y desmarcamos Installed , la etiqueta desaparecer\u00e1 para estos tama\u00f1os (pru\u00e9balo por ejemplo con un iPhone SE). Tambi\u00e9n se pueden cambiar las propiedades de los componentes en funci\u00f3n del tama\u00f1o. Por ejemplo: Selecciona en la barra de abajo un iPhone SE (1st generation) en orientaci\u00f3n apaisada (en este caso es wC-hC ). Pulsa sobre el bot\u00f3n + a la izquierda de la propiedad Font de la etiqueta, en el Attributes Inspector , y luego en Add variation , dejando width=Compact y height=Compact . F\u00edjate en que aparece una nueva columna en la tabla de propiedades. Puedes cambiar ah\u00ed la fuente a 15 puntos, y esto s\u00f3lo se ver\u00e1 en los dispositivos wC-hC . Como puedes ver, muchas propiedades tienen el bot\u00f3n + para hacer cambios s\u00f3lo en ciertos tama\u00f1os. Si quieres eliminar la configuraci\u00f3n de una propiedad, puedes pulsar sobre el bot\u00f3n x que aparece al lado de ella. Split View Un Split View o Vista divida es, como hemos comentado anteriormente, una combinaci\u00f3n de dos vistas, una maestra y una detalle. En modo horizontal ( landscape mode ), la primera vista (maestra) es equivalente en anchura a una vista de iPhone cuando se encuentra en orientaci\u00f3n vertical. Esta vista maestra se suele usar para la navegaci\u00f3n principal dentro de un listado de opciones de la aplicaci\u00f3n. Por otro lado, la vista de la derecha (detalle), que corresponder\u00e1 a la porci\u00f3n m\u00e1s grande de la pantalla, mostrar\u00e1 la informaci\u00f3n en detalle que hayamos seleccionado en la vista de la izquierda. Este es el uso que Apple propone para este tipo de controlador, aunque puede tener muchos m\u00e1s. En modo vertical ( portrait mode ), el Split View cambia y puede verse como un Navigation Bar con dos vistas. La primera es la vista maestra, y la segunda la vista detalle. Esta transformaci\u00f3n hace falta programarla si no hacemos uso de las plantillas de XCode. Por tanto, s\u00f3lo una de las vistas ocupar\u00e1 toda la pantalla del iPad, como podemos ver en la siguiente imagen: Es muy recomendable que los Split View Controllers sean s\u00f3lo root controllers, por lo que normalmente s\u00f3lo debemos usarlos en la primera pantalla. No podemos a\u00f1adir un Split View Controller dentro de un Navigation Controller . Esto implica que si lo programamos nosotros en lugar de usar la plantilla perderemos los botones de navegaci\u00f3n. Por tanto, tendremos que implementar nosotros la l\u00f3gica de navegaci\u00f3n, como vamos a hacer a continuaci\u00f3n. Incorporar un controlador Split View a nuestra aplicaci\u00f3n es bastante sencillo aunque no es trivial. Es por ello que vamos a explicarlo con una app de ejemplo que mostrar\u00e1 informaci\u00f3n sobre pel\u00edculas. En modo horizontal ( landscape ) tendremos un listado en forma de tabla con todas las pel\u00edculas en la parte izquierda del Split View y cuando seleccionemos una nos aparecer\u00e1n sus detalles en la parte derecha. Ejercicio: App universal con splitviewcontroller Para empezar vamos a programar una app b\u00e1sica con SplitViewController adaptada a distintos modelos y tama\u00f1os de iPad y iPhone. Creamos un nuevo proyecto llamado ejercicio_peliculas con iOS > App y storyboard . Selecciona un iPad en la barra de abajo para ir haciendo el dise\u00f1o del storyboard en este dispositivo, y el mismo modelo en el simulador (en la barra superior) para ejecutarlo. Arrastra un UISplitViewController al storyboard . Mueve la flecha de inicio de la aplicaci\u00f3n para que el nuevo controlador sea el primero cuando arranque la app y borra el controlador antiguo del storyboard y su fichero ViewController.swift . El storyboard deber\u00eda quedar as\u00ed: Como puedes ver, de nuestro splitViewController salen dos vistas: Una maestra (la tabla) que est\u00e1 controlada por un navigation controller , y una secundaria (detalle) enlazada al splitViewController . Si pinchas en los atributos de este controlador podr\u00e1s ver algo como lo siguiente: Un atributo muy importante es el estilo ( style). Los _splitview pueden tener dos o tres columnas. Lo m\u00e1s com\u00fan es dos, pero puedes hacer una app de tres columnas y que por tanto estar\u00e1 asociada a tres vistas para mostrar informaci\u00f3n de segundo nivel. Puedes encontrar m\u00e1s informaci\u00f3n sobre splitView en este enlace . Tenemos una tabla y una vista detalle, pero nos faltan los ficheros de c\u00f3digo de los controladores. Para la tabla crea un nuevo archivo con File > New > File > Cocoa touch > UITableViewController y ll\u00e1malo TableViewController . Asigna el controlador a la vista: Creamos otro controlador para la vista detalle, al que llamaremos DetailViewController , subclase de UIViewController , y al igual que el anterior lo asignamos en el storyboard . Podemos ejecutar la aplicaci\u00f3n. En un iPad veremos que en modo Portrait s\u00f3lo se muetra la vista detalle. Pinchando en el icono superior se muestra tambi\u00e9n la maestra. Si rotamos se muestran ambas, aunque todav\u00eda est\u00e1n vac\u00edas. Ahora a\u00f1adimos algo de informaci\u00f3n b\u00e1sica para que se muestre. Para esto, a\u00f1ade el siguiente array en TableViewController : let contenido = [ \"Uno\" , \"dos\" , \"tres\" ] Borra el m\u00e9todo numberOfSections y modifica los siguientes m\u00e9todos: override func tableView ( _ tableView : UITableView , numberOfRowsInSection section : Int ) -> Int { return contenido . count } override func tableView ( _ tableView : UITableView , cellForRowAt indexPath : IndexPath ) -> UITableViewCell { let cell = tableView . dequeueReusableCell ( withIdentifier : \"Cell\" , for : indexPath ) // Configure the cell... cell . textLabel !. text = contenido [ indexPath . row ] return cell } Recuerda que, al igual que en el ejercicio de la barra de b\u00fasqueda, debemos registrar el identificador de la celda en nuestro TableViewCell : De momento la vista detalle no tiene nada. Vamos a a\u00f1adirle una etiqueta en el centro, ajust\u00e1ndola horizontalmente y verticalmente: Conectamos la etiqueta con IBOutlet a nuestro controlador DetailViewController . Lo llamamos etiqueta : @IBOutlet weak var etiqueta : UILabel ! Si ejecutamos la app veremos que se muestran ya elementos en la tabla y se ve la vista detalle, aunque la idea es que cambie conforme se selecciona una celda de la vista maestra. Para esto, tenemos que comunicar el controlador maestro con el detalle. Esto se puede hacer de forma muy sencilla, por ejemplo en el m\u00e9todo didSelectRowAt : override func tableView ( _ tableView : UITableView , didSelectRowAt indexPath : IndexPath ) { if let indexPath = self . tableView . indexPathForSelectedRow { let object = self . contenido [ indexPath . row ] // Conexi\u00f3n con el controlador detalle let detailViewController = splitViewController !. viewController ( for : . secondary ) as ? DetailViewController detailViewController ?. etiqueta . text = object } } Como puedes ver, hemos accedido al controlador splitViewController , y dentro de este al secundario (la vista detalle) que es de la clase DetailViewController . Ahora podemos acceder al Outlet que hab\u00edamos enlazado y ejecutar la app: Como puedes ver, si rotas el dispositivo las dos vistas aparecen lado a lado. Ahora ejecuta el programa en un iPhone 14. Ver\u00e1s que el aspecto es distinto: S\u00f3lo se muestra la vista maestra, y si pulsamos sobre una celda no se pasa a la vista detalle. El problema es que, aunque hemos cambiado la segunda vista internamente, esta no se ve. Para que se vea, a\u00f1adimos lo siguiente tras la conexi\u00f3n con el controlador detalle (en didSelectRowAt ): // Si el controlador detalle no est\u00e1 presentado lo mostramos if ! detailViewController !. isBeingPresented { splitViewController !. showDetailViewController ( detailViewController !, sender : self ) } Ejecuta ahora la app en iPhone e iPad, deber\u00eda funcionar correctamente con ambos y en cualquier orientaci\u00f3n y tama\u00f1o. Ejercicio Pel\u00edculas Vamos a programar un ejemplo de aplicaci\u00f3n completa usando SplitViewController con algunas vistas comunes y otras diferenciadas en funci\u00f3n del tama\u00f1o. Cuando tengamos la versi\u00f3n final del programa, en la vista maestra aparecer\u00e1 un listado de t\u00edtulos de pel\u00edculas y la vista detalle mostrar\u00e1 los detalles de la pel\u00edcula seleccionada, con el t\u00edtulo, un texto descriptivo, el a\u00f1o y una imagen. A\u00f1adir el modelo de datos Partimos el proyecto anterior ejercicio_peliculas modific\u00e1ndolo para guardar pel\u00edculas, por lo que vamos a implementar un modelo de datos. Para esto creamos una nueva clase Pelicula mediante _File > New > File > Swift file_ con estos contenidos: import UIKit class Pelicula { var titulo : String var caratula : String var fecha : String var descripcion : String ? init ( titulo : String , caratula : String , fecha : String , descripcion : String ?) { self . titulo = titulo self . fecha = fecha self . caratula = caratula self . descripcion = descripcion } } En MasterViewController sustituimos el array contenido que ten\u00edamos por un array de Pel\u00edculas: var peliculas = [ Pelicula ]() Reemplazamos en este fichero todas las apariciones de contenido por peliculas , y de object por pelicula . Vamos a a\u00f1adir a la tabla una pel\u00edcula de ejemplo. Para ello creamos el m\u00e9todo crearListaPeliculas en la clase MasterViewController : func crearPeliculas () { let sentidoDeLaVida = Pelicula ( titulo : \"El sentido de la vida\" , caratula : \"sentido.jpg\" , fecha : \"1983\" , descripcion : \"Conjunto de episodios que muestran de forma disparatada los momentos m\u00e1s importantes del ciclo de la vida. Desde el nacimiento a la muerte, pasando por asuntos como la filosof\u00eda, la historia o la medicina, todo tratado con el inconfundible humor de los populares c\u00f3micos ingleses. El pr\u00f3logo es un cortometraje independiente rodado por Terry Gilliam: Seguros permanentes Crimson.\" ) self . peliculas . append ( sentidoDeLaVida ) } A\u00f1adimos una llamada a este m\u00e9todo al final de viewDidLoad para inicializar las pel\u00edculas. Cambiamos tambi\u00e9n las siguientes lineas en el m\u00e9todo cellForRowAt para mostrar en las celdas el t\u00edtulo de la pel\u00edcula: cell . textLabel !. text = peliculas [ indexPath . row ]. titulo A continuaci\u00f3n modifica didSelectRowAt para usar los datos de las pel\u00edculas, de forma que la etiqueta de la vista detalle contenga siempre el t\u00edtulo. Ejecutamos el programa en un iPad, deber\u00eda mostrar una pel\u00edcula (s\u00f3lo el t\u00edtulo, ya que no hemos a\u00f1adido la imagen ni otros datos) y funcionar correctamente. Dise\u00f1o de vista y controlador detalle Vamos a dise\u00f1ar la vista detalle de manera independiente en funci\u00f3n del tama\u00f1o del dispositivo, pero antes vamos a hacer un peque\u00f1o cambio. En el c\u00f3digo que hemos visto anteriormente, cuando se selecciona una celda de la vista maestra se modifica directamente el contenido de la etiqueta de la vista detalle. Sin embargo, no es una buena pol\u00edtica de dise\u00f1o controlar una vista (en este caso, detalle) mediante el controlador de otra (maestra). Para mejorar el dise\u00f1o del c\u00f3digo, en DetailViewController crea un m\u00e9todo llamado didChangePelicula que reciba como par\u00e1metro una pel\u00edcula y actualice la vista en funci\u00f3n de los datos que tenga esta variable. De esta forma, desde TableViewController podremos reemplazar la l\u00ednea que asigna directamente la etiqueta por la llamada al m\u00e9todo para que se haga dentro del controlador detalle: // detailViewController?.etiqueta.text = pelicula detailViewController ?. didChangePelicula ( with : pelicula ) Selecciona la vista detalle en el storyboard y haz que sea como la que se muetra a continuaci\u00f3n. La etiqueta Titulo es la que ten\u00edamos en el centro, que debes mover a la parte superior izquierda. Tambi\u00e9n a\u00f1adimos otro UILabel , un UIImageView y un UITextView : Tras colocar los elementos, usa Reset to suggested constraints para que los constraints se ajusten de forma autom\u00e1tica. Prueba tambi\u00e9n a ver la vista con otros dispositivos y orientaciones seleccion\u00e1ndolos en la barra inferior. Ponemos el UITextView s\u00f3lo como lectura, para impedir que el usuario lo edite y salga un teclado cuando se pulsa sobre \u00e9l. Para esto, desmarca Editable y Selectable en sus propiedades. Conecta todos los elementos de la vista ( titulo , imagen , fecha y descripcion ) al controlador DetailViewController con IBOutlets. Necesitar\u00e1s descargar esta imagen y arrastrarla a los Assets . Por \u00faltimo modifica el m\u00e9todo didChangePelicula para actualizar todos los outlets. En el caso de la imagen ser\u00eda: self . imagen . image = UIImage ( named : pelicula . caratula ) Ejecuta el programa con el simulador de distintos iPhone y iPad para ver los resultados. Seguro que en algunos casos visualmente no queda demasiado bien, pero de momento no es un problema. Vamos a ajustar mejor la vista en funci\u00f3n del dispositivo. Vista compacta y stacks Empezaremos con el dise\u00f1o para tama\u00f1os compactos. Si ejecutamos el programa en un iPhone SE en landscape , veremos que la imagen ocupa casi toda la pantalla y deja poco espacio para el texto. En apaisado y con tama\u00f1os compactos, lo ideal ser\u00eda que la imagen estuviera a la izquierda y el texto a la derecha. Existe una soluci\u00f3n limpia para esto: usar Stacks para agrupar las vistas y gestionar los giros. Selecciona el UIImageView y el UITextView . Ahora pulsa sobre el elemento Stack , el icono de la flecha hacia abajo en esta imagen, y selecciona Stack View : Ver\u00e1s que las vistas se unen, esto es porque hemos creado un grupo con dos elementos. Como ves, un Stack se usa para agrupar vistas, y nos permite realizar ciertas acciones con ellas. Vamos a reajustar las constraints con este nuevo Stack , seleccionando Reset to suggested constraints para toda la vista detalle. Si ejecutamos el programa, el aspecto ser\u00e1 m\u00e1s o menos como el que ten\u00edamos antes. Vamos a arreglar los problemas del giro, ya que cuando ponemos un iPhone en landscape no se visualiza bien la pel\u00edcula. Para ello, necesitamos conectar nuestro Stack View a DetailViewController . Ll\u00e1malo stackView : @IBOutlet weak var stackView : UIStackView ! Ahora vamos a a\u00f1adir el siguiente m\u00e9todo en DetailViewController : override func viewWillLayoutSubviews () { if view . bounds . size . width >= view . bounds . size . height { self . stackView . axis = . horizontal } else { self . stackView . axis = . vertical } } Este m\u00e9todo se invoca cuando iOS detecta que hay que reajustar las vistas (por ejemplo cuando se realiza un giro). En el c\u00f3digo indicamos que cuando tengamos m\u00e1s espacio horizontal que vertical nuestras vistas del stack deben reposicionarse. Adem\u00e1s, lo har\u00e1n con una animaci\u00f3n. Prueba a ejecutar de nuevo el programa en un iPhone, debe verse as\u00ed en portrait : Y as\u00ed en landscape : Para saber m\u00e1s sobre lo que podemos hacer con la clase UIStackView , puedes consultar su referencia aqu\u00ed . Vista regular Vamos a ajustar el constraint de la altura de la imagen para hacerla m\u00e1s grande en tama\u00f1os wR-hR , ya que en estos casos tenemos m\u00e1s espacio. Ahora pulsamos sobre el bot\u00f3n + de la altura, a\u00f1adiendo una variaci\u00f3n para wR-hR : Y finalmente indicamos un valor m\u00e1s alto: Ejecutamos el programa y vemos que funciona correctamente en iPad, en cualquier orientaci\u00f3n. Ahora vamos a cambiar el tipo de letra para wR-hR , de forma que se vea m\u00e1s grande en un iPad. Cambia s\u00f3lo para tama\u00f1os wR-hR la fuente del texto a System-20 , y la del t\u00edtulo a System-22 y en negrita: Ahora vamos a a\u00f1adir una etiqueta que contenga la fecha, pero s\u00f3lo en aquellos casos en los que tengamos suficiente espacio en anchura, en orientaciones regular width: wR . Seleccionamos un iPad en la barra inferior del storyboard , e indicamos Vary for traits > width . La barra debe cambiar a color azul. A\u00f1adimos un UILabel arriba a la derecha, al que pondremos el t\u00edtulo Fecha , como puede verse en la siguiente imagen: Cuando el ancho es Regular tenemos m\u00e1s espacio, es por esto que lo a\u00f1adimos aqu\u00ed. Esta etiqueta s\u00f3lo se mostrar\u00e1 en los iPad cuando nuestra app est\u00e9 a pantalla completa en cualquier orientaci\u00f3n, o en el iPhone 6s/7 Plus con pantalla completa y landscape . Ejecutamos el c\u00f3digo en el simulador de iPad para ver los resultados. Deber\u00edamos obtener algo parecido a esto: El aspecto no est\u00e1 mal, pero s\u00f3lo es una primera aproximaci\u00f3n. Vamos a mejorar un poco el programa con los siguientes cambios: Completa el modelo a\u00f1adiendo dos pel\u00edculas m\u00e1s (con sus im\u00e1genes) al proyecto, las que prefieras. Vamos a mejorar la presentaci\u00f3n visual. Para ello cambia el t\u00edtulo de la barra de la vista detalle, de Pel\u00edcula al t\u00edtulo de la pel\u00edcula seleccionada en la vista con el a\u00f1o entre par\u00e9ntesis. Por ejemplo, en la barra superior deber\u00eda salir El sentido de la vida (1983) . Elimina los UILabel del t\u00edtulo y de la fecha, ya que esta informaci\u00f3n se va a mostrar ahora en la barra superior. Cambia el aspecto gr\u00e1fico de las vistas para que queden lo mejor posible. Puedes mover los objetos, redimensionarlos o modificar sus propiedades, por ejemplo. Cambia el UITextView para que no sea editable mediante sus propiedades en el storyboard . La primera vez que aparece la aplicaci\u00f3n en iPad en portrait (sin llegar a seleccionar una pel\u00edcula) sale la vista detalle con informaci\u00f3n vac\u00eda. Haz que en este caso se muestre s\u00f3lo Pel\u00edcula en la barra del t\u00edtulo, y que la descripci\u00f3n sea el mensaje Selecciona una pel\u00edcula .","title":"3- Dise\u00f1o de aplicaciones universales"},{"location":"sesion-3-apps-universales.html#aplicaciones-universales","text":"En este apartado trataremos las aplicaciones universales , veremos qu\u00e9 son, qu\u00e9 ventajas e inconvenientes podemos encontrar a la hora de dise\u00f1arlas, c\u00f3mo programarlas y las recomendaciones de uso por parte de Apple. Y vamos a hacerlo usando un controlador de tipo Split View como base.","title":"Aplicaciones universales"},{"location":"sesion-3-apps-universales.html#introduccion","text":"Utilizamos el t\u00e9rmino universal para denominar a todas aquellas aplicaciones adaptadas tanto al iPad como al iPhone. Los usuarios agradecen este tipo de aplicaciones ya que pueden usarlas en todos sus dispositivos y adem\u00e1s cuanto mayor sea el n\u00famero de dispositivos compatibles m\u00e1s clientes potenciales podremos captar. El desarrollo de una aplicaci\u00f3n universal ahorra tiempo de desarrollo respecto a hacer apps independientes para cada dispositivo, ya que evidentemente programaremos un s\u00f3lo proyecto en lugar de varios. Tambi\u00e9n tiene ventajas para las actualizaciones, ya que tendremos que preocuparnos de implementar los cambios s\u00f3lo en una aplicaci\u00f3n.","title":"Introducci\u00f3n"},{"location":"sesion-3-apps-universales.html#disenando-la-interfaz-de-una-aplicacion-universal","text":"El primer paso para hacer una aplicaci\u00f3n universal desde cero es dise\u00f1ar la interfaz para cada una de las vistas. En versiones anteriores de iOS se separaba por un lado las de iPhone de las de iPad usando distintos ficheros .xib . Actualmente se debe hacer de forma conjunta usando los storyboards y autolayout (en el caso de UIKit, que es lo que veremos en la asignatura), o bien mediante SwiftUI. A continuaci\u00f3n detallaremos algunos de los puntos que debemos tener en cuenta a la hora de dise\u00f1ar una interfaz universal: Orientaci\u00f3n. Con la informaci\u00f3n sobre la orientaci\u00f3n del dispositivo podremos adaptar la interfaz de la aplicaci\u00f3n para acomodarla al mismo. En aplicaciones para iPhone, la adaptaci\u00f3n de la interfaz no es tan importante como en aplicaciones para iPad. Estructura de las vistas . La pantalla del iPad, al ser m\u00e1s grande que la del iPhone permite al usuario acceder a m\u00e1s informaci\u00f3n en pantalla. Comportamiento de las API. Componentes como los popover, por ejemplo, se comportan de forma distinta en un iphone y en un ipad. Caracter\u00edsticas Hardware. Distintos dispositivos iOS poseen distintas funcionalidades hardware, como el n\u00famero de c\u00e1maras, la capacidad de gestionar dynamic islands , etc. Hay que tener en cuenta este tipo de caracter\u00edsticas a la hora de implementar una aplicaci\u00f3n universal. Gestos. A veces en la pantalla del iPad podemos realizar m\u00e1s gestos que en la del iPhone debido a su tama\u00f1o. Por ejemplo, se pueden usar cuatro dedos al mismo tiempo. Arte. Hay que tener en cuenta la resoluci\u00f3n de los distintos dispositivos, almacenando las im\u00e1genes en los Assets usando varias resoluciones. Una alternativa recomendada por Apple es usar archivos PDF en los Assets.","title":"Dise\u00f1ando la interfaz de una aplicaci\u00f3n universal"},{"location":"sesion-3-apps-universales.html#programando-una-aplicacion-universal","text":"Como acabamos de ver, para programar una aplicaci\u00f3n universal en iOS debemos tener en cuenta las caracter\u00edsticas de nuestro dispositivo. Para esto podemos usar c\u00f3digo condicional. Por ejemplo, podemos detectar en cualquier momento si estamos ejecutando nuestra app con un iPhone o un iPad con la instrucci\u00f3n UIDevice.currentDevice().userInterfaceIdiom . Para entender mejor en qu\u00e9 consiste una aplicaci\u00f3n universal y c\u00f3mo podemos comenzar a programar una, vamos a realizar un ejemplo paso a paso. Antes de XCode 6, cuando se creaba un nuevo proyecto se generaban dos vistas distintas , una adaptada al tama\u00f1o de pantalla de un iPhone y otra adaptada a un iPad. Sin embargo, desde hace bastantes a\u00f1os, Apple recomienda hacer las aplicaciones usando siempre autolayout para adaptar el tama\u00f1o de los elementos al de cualquier pantalla, tanto si es iPhone como iPad, en lugar de usar .xib separados, a no ser que sea estrictamente necesario (que a veces lo es).","title":"Programando una aplicaci\u00f3n universal"},{"location":"sesion-3-apps-universales.html#ejemplo-de-vistas-universales","text":"Comenzamos abriendo XCode y creando un nuevo proyecto de tipo iOS > App al que llamaremos prueba_universal . Primero abrimos la vista principal del storyboard . Podemos ver c\u00f3mo quedar\u00eda en distintos dispositivos sin llegar a ejecutar el simulador: Arrastra un UILabel a la vista principal del storyboard y su\u00e9ltala por el centro de la vista. En el storyboard pincha en la parte inferior, donde aparece el modelo (por ejemplo, iPhone14). y elige otro modelo, por ejemplo un iPad. La etiqueta se mover\u00e1 a otro lugar. Si lo rotamos (en la parte inferior, con el icono de un cuadrado que tiene encima una flecha), es posible que hasta desaparezca de la pantalla. Ajusta las opciones de autolayout para la etiqueta. Si no controlas todav\u00eda autolayout , puedes seleccionar el tri\u00e1ngulo de la parte inferior ( Resolve autolayout issues ) y elegir Reset to suggested constraints . Si mueves el UILabel a otra posici\u00f3n, ver\u00e1s que las l\u00edneas azules de gu\u00eda aparecen ahora de color naranja. Esto es porque todav\u00eda tiene las constraints anteriores y son inconsistentes con la nueva posici\u00f3n. Para actualizar la vista, pincha de nuevo en el tri\u00e1ngulo y selecciona Update constraint constants . Puedes ampliar o reducir los previews haciendo zoom con los dedos en el trackpad, o usando los controles de la parte inferior. En principio es sencillo, aunque a veces es complicado saber c\u00f3mo ajustar las constraints y manejar autolayout . Las opciones de autolayout pueden parecer f\u00e1ciles de interpretar, pero a la hora de la verdad no es f\u00e1cil dejar una vista como queremos.","title":"Ejemplo de vistas universales"},{"location":"sesion-3-apps-universales.html#vistas-dependientes-del-dispositivo","text":"A veces nos interesa tener vistas separadas para distintos tama\u00f1os, de forma que podamos aprovechar mejor la pantalla. Como se ha mencionado anteriormente, se recomienda usar interfaces diferenciados, ya que simplemente escalar el tama\u00f1o de los componentes para pantallas m\u00e1s grandes no suele quedar bien. Para el dise\u00f1o del interfaz, en lugar de distinguir entre iPhone e iPad, Apple introdujo en XCode 7 el concepto de size clases . La idea es pensar el dise\u00f1o s\u00f3lo para dos tama\u00f1os: Compact : Cuando tenemos un tama\u00f1o Compact debemos hacer un interfaz m\u00ednimo que muestre s\u00f3lo la informaci\u00f3n m\u00e1s relevante de forma compacta. Regular : En un tama\u00f1o Regular podemos a\u00f1adir m\u00e1s elementos y hacer un interfaz completo, ya que dispondremos de m\u00e1s espacio en la pantalla. Adem\u00e1s, estos tama\u00f1os pueden venir dados para la anchura ( Width ) o la altura ( Height ). Por tanto, debemos tener en cuenta tres factores: Dispositivo . iPhone o iPad. Orientaci\u00f3n . Horizontal o vertical. Tama\u00f1o . Compacto o regular. B\u00e1sicamente (aunque en realidad es algo m\u00e1s complicado), los dispositivos de Apple tienen los siguientes tama\u00f1os: En la imagen, el iPhone que se ve en arriba a la derecha es un iPhone 6s/7s plus (o iPhone X), que son m\u00e1s grandes que otros iphones y por tanto tienen un tama\u00f1o regular cuando el m\u00f3vil est\u00e1 apaisado. Puedes ver un listado completo de los tama\u00f1os al final de este enlace . Es m\u00e1s complicado porque hay que tener en cuenta que no tenemos que asumir que siempre los tama\u00f1os de vista son constantes , ya que por ejemplo nuestra app en un iPad podr\u00eda mostrarse en una zona compacta de la pantalla en lugar de usar la pantalla completa. Por tanto, siempre hay que dise\u00f1ar las vistas en modo compacto y regular. En la ventana inferior de XCode podemos cambiar el tipo de dispositivo, su orientaci\u00f3n, y en el caso del iPad, su adaptaci\u00f3n. Independientemente de lo que seleccionemos, los cambios que hagamos aqu\u00ed sobre la vista se aplicar\u00e1n a todos los dispositivos. Es posible presentar un componente (por ejemplo, un bot\u00f3n o una etiqueta) s\u00f3lo para un tama\u00f1o determinado. Para esto, puedes seleccionarlo y pinchar en el s\u00edmbolo + que aparece junto a Installed en las propiedades de nuestro componente. Si por ejemplo elegimos width Compact y height Regular ( wC hR ) y desmarcamos Installed , la etiqueta desaparecer\u00e1 para estos tama\u00f1os (pru\u00e9balo por ejemplo con un iPhone SE). Tambi\u00e9n se pueden cambiar las propiedades de los componentes en funci\u00f3n del tama\u00f1o. Por ejemplo: Selecciona en la barra de abajo un iPhone SE (1st generation) en orientaci\u00f3n apaisada (en este caso es wC-hC ). Pulsa sobre el bot\u00f3n + a la izquierda de la propiedad Font de la etiqueta, en el Attributes Inspector , y luego en Add variation , dejando width=Compact y height=Compact . F\u00edjate en que aparece una nueva columna en la tabla de propiedades. Puedes cambiar ah\u00ed la fuente a 15 puntos, y esto s\u00f3lo se ver\u00e1 en los dispositivos wC-hC . Como puedes ver, muchas propiedades tienen el bot\u00f3n + para hacer cambios s\u00f3lo en ciertos tama\u00f1os. Si quieres eliminar la configuraci\u00f3n de una propiedad, puedes pulsar sobre el bot\u00f3n x que aparece al lado de ella.","title":"Vistas dependientes del dispositivo"},{"location":"sesion-3-apps-universales.html#split-view","text":"Un Split View o Vista divida es, como hemos comentado anteriormente, una combinaci\u00f3n de dos vistas, una maestra y una detalle. En modo horizontal ( landscape mode ), la primera vista (maestra) es equivalente en anchura a una vista de iPhone cuando se encuentra en orientaci\u00f3n vertical. Esta vista maestra se suele usar para la navegaci\u00f3n principal dentro de un listado de opciones de la aplicaci\u00f3n. Por otro lado, la vista de la derecha (detalle), que corresponder\u00e1 a la porci\u00f3n m\u00e1s grande de la pantalla, mostrar\u00e1 la informaci\u00f3n en detalle que hayamos seleccionado en la vista de la izquierda. Este es el uso que Apple propone para este tipo de controlador, aunque puede tener muchos m\u00e1s. En modo vertical ( portrait mode ), el Split View cambia y puede verse como un Navigation Bar con dos vistas. La primera es la vista maestra, y la segunda la vista detalle. Esta transformaci\u00f3n hace falta programarla si no hacemos uso de las plantillas de XCode. Por tanto, s\u00f3lo una de las vistas ocupar\u00e1 toda la pantalla del iPad, como podemos ver en la siguiente imagen: Es muy recomendable que los Split View Controllers sean s\u00f3lo root controllers, por lo que normalmente s\u00f3lo debemos usarlos en la primera pantalla. No podemos a\u00f1adir un Split View Controller dentro de un Navigation Controller . Esto implica que si lo programamos nosotros en lugar de usar la plantilla perderemos los botones de navegaci\u00f3n. Por tanto, tendremos que implementar nosotros la l\u00f3gica de navegaci\u00f3n, como vamos a hacer a continuaci\u00f3n. Incorporar un controlador Split View a nuestra aplicaci\u00f3n es bastante sencillo aunque no es trivial. Es por ello que vamos a explicarlo con una app de ejemplo que mostrar\u00e1 informaci\u00f3n sobre pel\u00edculas. En modo horizontal ( landscape ) tendremos un listado en forma de tabla con todas las pel\u00edculas en la parte izquierda del Split View y cuando seleccionemos una nos aparecer\u00e1n sus detalles en la parte derecha.","title":"Split View"},{"location":"sesion-3-apps-universales.html#ejercicio-app-universal-con-splitviewcontroller","text":"Para empezar vamos a programar una app b\u00e1sica con SplitViewController adaptada a distintos modelos y tama\u00f1os de iPad y iPhone. Creamos un nuevo proyecto llamado ejercicio_peliculas con iOS > App y storyboard . Selecciona un iPad en la barra de abajo para ir haciendo el dise\u00f1o del storyboard en este dispositivo, y el mismo modelo en el simulador (en la barra superior) para ejecutarlo. Arrastra un UISplitViewController al storyboard . Mueve la flecha de inicio de la aplicaci\u00f3n para que el nuevo controlador sea el primero cuando arranque la app y borra el controlador antiguo del storyboard y su fichero ViewController.swift . El storyboard deber\u00eda quedar as\u00ed: Como puedes ver, de nuestro splitViewController salen dos vistas: Una maestra (la tabla) que est\u00e1 controlada por un navigation controller , y una secundaria (detalle) enlazada al splitViewController . Si pinchas en los atributos de este controlador podr\u00e1s ver algo como lo siguiente: Un atributo muy importante es el estilo ( style). Los _splitview pueden tener dos o tres columnas. Lo m\u00e1s com\u00fan es dos, pero puedes hacer una app de tres columnas y que por tanto estar\u00e1 asociada a tres vistas para mostrar informaci\u00f3n de segundo nivel. Puedes encontrar m\u00e1s informaci\u00f3n sobre splitView en este enlace . Tenemos una tabla y una vista detalle, pero nos faltan los ficheros de c\u00f3digo de los controladores. Para la tabla crea un nuevo archivo con File > New > File > Cocoa touch > UITableViewController y ll\u00e1malo TableViewController . Asigna el controlador a la vista: Creamos otro controlador para la vista detalle, al que llamaremos DetailViewController , subclase de UIViewController , y al igual que el anterior lo asignamos en el storyboard . Podemos ejecutar la aplicaci\u00f3n. En un iPad veremos que en modo Portrait s\u00f3lo se muetra la vista detalle. Pinchando en el icono superior se muestra tambi\u00e9n la maestra. Si rotamos se muestran ambas, aunque todav\u00eda est\u00e1n vac\u00edas. Ahora a\u00f1adimos algo de informaci\u00f3n b\u00e1sica para que se muestre. Para esto, a\u00f1ade el siguiente array en TableViewController : let contenido = [ \"Uno\" , \"dos\" , \"tres\" ] Borra el m\u00e9todo numberOfSections y modifica los siguientes m\u00e9todos: override func tableView ( _ tableView : UITableView , numberOfRowsInSection section : Int ) -> Int { return contenido . count } override func tableView ( _ tableView : UITableView , cellForRowAt indexPath : IndexPath ) -> UITableViewCell { let cell = tableView . dequeueReusableCell ( withIdentifier : \"Cell\" , for : indexPath ) // Configure the cell... cell . textLabel !. text = contenido [ indexPath . row ] return cell } Recuerda que, al igual que en el ejercicio de la barra de b\u00fasqueda, debemos registrar el identificador de la celda en nuestro TableViewCell : De momento la vista detalle no tiene nada. Vamos a a\u00f1adirle una etiqueta en el centro, ajust\u00e1ndola horizontalmente y verticalmente: Conectamos la etiqueta con IBOutlet a nuestro controlador DetailViewController . Lo llamamos etiqueta : @IBOutlet weak var etiqueta : UILabel ! Si ejecutamos la app veremos que se muestran ya elementos en la tabla y se ve la vista detalle, aunque la idea es que cambie conforme se selecciona una celda de la vista maestra. Para esto, tenemos que comunicar el controlador maestro con el detalle. Esto se puede hacer de forma muy sencilla, por ejemplo en el m\u00e9todo didSelectRowAt : override func tableView ( _ tableView : UITableView , didSelectRowAt indexPath : IndexPath ) { if let indexPath = self . tableView . indexPathForSelectedRow { let object = self . contenido [ indexPath . row ] // Conexi\u00f3n con el controlador detalle let detailViewController = splitViewController !. viewController ( for : . secondary ) as ? DetailViewController detailViewController ?. etiqueta . text = object } } Como puedes ver, hemos accedido al controlador splitViewController , y dentro de este al secundario (la vista detalle) que es de la clase DetailViewController . Ahora podemos acceder al Outlet que hab\u00edamos enlazado y ejecutar la app: Como puedes ver, si rotas el dispositivo las dos vistas aparecen lado a lado. Ahora ejecuta el programa en un iPhone 14. Ver\u00e1s que el aspecto es distinto: S\u00f3lo se muestra la vista maestra, y si pulsamos sobre una celda no se pasa a la vista detalle. El problema es que, aunque hemos cambiado la segunda vista internamente, esta no se ve. Para que se vea, a\u00f1adimos lo siguiente tras la conexi\u00f3n con el controlador detalle (en didSelectRowAt ): // Si el controlador detalle no est\u00e1 presentado lo mostramos if ! detailViewController !. isBeingPresented { splitViewController !. showDetailViewController ( detailViewController !, sender : self ) } Ejecuta ahora la app en iPhone e iPad, deber\u00eda funcionar correctamente con ambos y en cualquier orientaci\u00f3n y tama\u00f1o.","title":"Ejercicio: App universal con splitviewcontroller"},{"location":"sesion-3-apps-universales.html#ejercicio-peliculas","text":"Vamos a programar un ejemplo de aplicaci\u00f3n completa usando SplitViewController con algunas vistas comunes y otras diferenciadas en funci\u00f3n del tama\u00f1o. Cuando tengamos la versi\u00f3n final del programa, en la vista maestra aparecer\u00e1 un listado de t\u00edtulos de pel\u00edculas y la vista detalle mostrar\u00e1 los detalles de la pel\u00edcula seleccionada, con el t\u00edtulo, un texto descriptivo, el a\u00f1o y una imagen.","title":"Ejercicio Pel\u00edculas"},{"location":"sesion-3-apps-universales.html#anadir-el-modelo-de-datos","text":"Partimos el proyecto anterior ejercicio_peliculas modific\u00e1ndolo para guardar pel\u00edculas, por lo que vamos a implementar un modelo de datos. Para esto creamos una nueva clase Pelicula mediante _File > New > File > Swift file_ con estos contenidos: import UIKit class Pelicula { var titulo : String var caratula : String var fecha : String var descripcion : String ? init ( titulo : String , caratula : String , fecha : String , descripcion : String ?) { self . titulo = titulo self . fecha = fecha self . caratula = caratula self . descripcion = descripcion } } En MasterViewController sustituimos el array contenido que ten\u00edamos por un array de Pel\u00edculas: var peliculas = [ Pelicula ]() Reemplazamos en este fichero todas las apariciones de contenido por peliculas , y de object por pelicula . Vamos a a\u00f1adir a la tabla una pel\u00edcula de ejemplo. Para ello creamos el m\u00e9todo crearListaPeliculas en la clase MasterViewController : func crearPeliculas () { let sentidoDeLaVida = Pelicula ( titulo : \"El sentido de la vida\" , caratula : \"sentido.jpg\" , fecha : \"1983\" , descripcion : \"Conjunto de episodios que muestran de forma disparatada los momentos m\u00e1s importantes del ciclo de la vida. Desde el nacimiento a la muerte, pasando por asuntos como la filosof\u00eda, la historia o la medicina, todo tratado con el inconfundible humor de los populares c\u00f3micos ingleses. El pr\u00f3logo es un cortometraje independiente rodado por Terry Gilliam: Seguros permanentes Crimson.\" ) self . peliculas . append ( sentidoDeLaVida ) } A\u00f1adimos una llamada a este m\u00e9todo al final de viewDidLoad para inicializar las pel\u00edculas. Cambiamos tambi\u00e9n las siguientes lineas en el m\u00e9todo cellForRowAt para mostrar en las celdas el t\u00edtulo de la pel\u00edcula: cell . textLabel !. text = peliculas [ indexPath . row ]. titulo A continuaci\u00f3n modifica didSelectRowAt para usar los datos de las pel\u00edculas, de forma que la etiqueta de la vista detalle contenga siempre el t\u00edtulo. Ejecutamos el programa en un iPad, deber\u00eda mostrar una pel\u00edcula (s\u00f3lo el t\u00edtulo, ya que no hemos a\u00f1adido la imagen ni otros datos) y funcionar correctamente.","title":"A\u00f1adir el modelo de datos"},{"location":"sesion-3-apps-universales.html#diseno-de-vista-y-controlador-detalle","text":"Vamos a dise\u00f1ar la vista detalle de manera independiente en funci\u00f3n del tama\u00f1o del dispositivo, pero antes vamos a hacer un peque\u00f1o cambio. En el c\u00f3digo que hemos visto anteriormente, cuando se selecciona una celda de la vista maestra se modifica directamente el contenido de la etiqueta de la vista detalle. Sin embargo, no es una buena pol\u00edtica de dise\u00f1o controlar una vista (en este caso, detalle) mediante el controlador de otra (maestra). Para mejorar el dise\u00f1o del c\u00f3digo, en DetailViewController crea un m\u00e9todo llamado didChangePelicula que reciba como par\u00e1metro una pel\u00edcula y actualice la vista en funci\u00f3n de los datos que tenga esta variable. De esta forma, desde TableViewController podremos reemplazar la l\u00ednea que asigna directamente la etiqueta por la llamada al m\u00e9todo para que se haga dentro del controlador detalle: // detailViewController?.etiqueta.text = pelicula detailViewController ?. didChangePelicula ( with : pelicula ) Selecciona la vista detalle en el storyboard y haz que sea como la que se muetra a continuaci\u00f3n. La etiqueta Titulo es la que ten\u00edamos en el centro, que debes mover a la parte superior izquierda. Tambi\u00e9n a\u00f1adimos otro UILabel , un UIImageView y un UITextView : Tras colocar los elementos, usa Reset to suggested constraints para que los constraints se ajusten de forma autom\u00e1tica. Prueba tambi\u00e9n a ver la vista con otros dispositivos y orientaciones seleccion\u00e1ndolos en la barra inferior. Ponemos el UITextView s\u00f3lo como lectura, para impedir que el usuario lo edite y salga un teclado cuando se pulsa sobre \u00e9l. Para esto, desmarca Editable y Selectable en sus propiedades. Conecta todos los elementos de la vista ( titulo , imagen , fecha y descripcion ) al controlador DetailViewController con IBOutlets. Necesitar\u00e1s descargar esta imagen y arrastrarla a los Assets . Por \u00faltimo modifica el m\u00e9todo didChangePelicula para actualizar todos los outlets. En el caso de la imagen ser\u00eda: self . imagen . image = UIImage ( named : pelicula . caratula ) Ejecuta el programa con el simulador de distintos iPhone y iPad para ver los resultados. Seguro que en algunos casos visualmente no queda demasiado bien, pero de momento no es un problema. Vamos a ajustar mejor la vista en funci\u00f3n del dispositivo.","title":"Dise\u00f1o de vista y controlador detalle"},{"location":"sesion-4-multitouch.html","text":"Pantalla t\u00e1ctil El sensor de pantalla es, obviamente, el m\u00e1s usado y com\u00fan de todos. En una aplicaci\u00f3n iOS que utilice los componentes b\u00e1sicos de UIKit como tablas, botones, campos de texto, etc. problamente no tendremos que preocuparnos por gestionar los eventos producidos por el sensor de la pantalla. En aplicaciones como juegos, o m\u00e1s elaboradas, es muy habitual que tengamos que hacer uso de los eventos que detallaremos a continuaci\u00f3n. La gesti\u00f3n de eventos de entrada ( Touch Events ) se realiza a trav\u00e9s de los siguientes m\u00e9todos, que m\u00e1s adelante detallaremos mediante un ejemplo: func touchesBegan(Set<UITouch>, with: UIEvent?) : Captura las pulsaciones sobre la pantalla. El m\u00e9todo recibe la lista de pulsaciones que se detectan. func touchesMoved(Set<UITouch>, with: UIEvent?) : Captura los movimientos de las pulsaciones sobre la pantalla func touchesEnded(Set<UITouch>, with: UIEvent?) : Captura las \u00faltimas pulsaciones sobre la pantalla func touchesCancelled(Set<UITouch>, with: UIEvent?) : Evento que se ejecuta cuando cerramos la aplicaci\u00f3n o la vista mientras se est\u00e1 detectando pulsaciones en la pantalla, o cuando se interrumpe por un evento externo como una llamada. En general, estos eventos pertenecen a la clase UIResponder . Puedes obtener m\u00e1s informaci\u00f3n sobre esta clase aqu\u00ed . Adem\u00e1s de los eventos de pulsaci\u00f3n sobre la pantalla, controla los de movimiento (por ejemplo cuando se agita el dispositivo) y los de control remoto (cuando se dispone de un dispositivo externo de control). Los dispositivos iOS tambi\u00e9n admiten varias pulsaciones al mismo tiempo, lo que se le conoce con el nombre de multitouch . Esta caracter\u00edstica hay que tenerla en cuenta a la hora de implementar los m\u00e9todos anteriores. Para entrar m\u00e1s en profundidad en el uso de las funciones de pulsaciones en iOS, vamos a realizar una aplicaci\u00f3n de ejemplo en la que arrastraremos una imagen por la pantalla de nuestro dispositivo. Ejercicio 1 - Gestos Comenzamos creando un proyecto en XCode de tipo App con storyboard que guardaremos con el nombre ejercicio_touch . Creamos un objeto de tipo UIImageView , lo arrastramos a la vista coloc\u00e1ndolo en la parte superior izquierda de la pantalla, y lo enlazamos a nuestro ViewController para crear la propiedad, a la que llamaremos imageView . Arrastra la imagen logo-master.png al proyecto y as\u00edgnala a la vista como se indica a continuaci\u00f3n (aunque tambi\u00e9n se podr\u00eda hacer por c\u00f3digo): Ahora editamos el archivo ViewController.swift , y a\u00f1adimos un Outlet que enlazamos con nuestro UIImageView y un booleano llamado tocaImagen . Debe quedar de la siguiente forma: @IBOutlet weak var imageView : UIImageView ! var tocaImagen = false Como se puede ver tenemos dos propiedades: una imagen que podremos mover por la pantalla, y un booleano que utilizaremos para indicar si la estamos moviendo o no. Ahora a\u00f1adimos al fichero ViewController.swift los cuatro m\u00e9todos que gestionan los gestos: override func touchesBegan ( _ touches : Set < UITouch >, with event : UIEvent ?) { if let touch = touches . first { print ( \"Touches began\" ) let loc = touch . location ( in : self . view ) if self . imageView . frame . contains ( loc ) { print ( \"Detectado toque sobre la imagen\" ) self . tocaImagen = true } } super . touchesBegan ( touches , with : event ) } override func touchesMoved ( _ touches : Set < UITouch >, with event : UIEvent ?) { if let touch = touches . first { print ( \"Touches moved\" ) let loc = touch . location ( in : self . view ) if self . tocaImagen == true { self . imageView . center = loc } } super . touchesMoved ( touches , with : event ) } override func touchesEnded ( _ touches : Set < UITouch >, with event : UIEvent ?) { print ( \"Touches ended\" ) self . tocaImagen = false super . touchesEnded ( touches , with : event ) } override func touchesCancelled ( _ touches : Set < UITouch >, with event : UIEvent ?) { print ( \"Touches cancelled\" ) self . tocaImagen = false super . touchesCancelled ( touches , with : event ) } Como podemos observar en el c\u00f3digo anterior, hemos utilizado la clase de UIKit UITouch . Esta clase representa el evento de toque. Al mismo tiempo que el usuario interact\u00faa con la pantalla, iOS env\u00eda continuamente mensajes al evento correspondiente (uno de los cuatro comentados anteriormente). Cada evento incluye informaci\u00f3n sobre los distintos toques en la secuencia producida por el usuario y cada toque en particular corresponde a una instancia de la clase UITouch . Con esto \u00faltimo ya podemos ejecutar la aplicaci\u00f3n y veremos que podemos pulsar sobre la imagen y arrastrarla. El funcionamiento de estos m\u00e9todos es muy simple. Primero se ejecuta touchesBegan que detecta el primer toque sobre la pantalla, en el comprobamos si la posici\u00f3n del toque est\u00e1 dentro del cuadro ( frame ) del UIImageView . Si es as\u00ed actualizamos la variable booleana a true , y en caso contrario no hacemos nada. En el momento en que arrastremos el dedo sobre la pantalla se ejecutar\u00e1 continuamente el m\u00e9todo touchesMoved . En este, si la variable booleana tocaImagen est\u00e1 a true actualizamos la posici\u00f3n de la imagen a la posici\u00f3n detectada, y en caso contrario no hacemos nada. Por \u00faltimo, cuando dejamos de pulsar la pantalla se ejecutar\u00e1 el m\u00e9todo touchesEnded el cual simplemente volver\u00e1 a actualizar la variable booleana a false . Si queremos detectar varios toques al mismo tiempo, primero deberemos activarlo, por ejemplo en viewDidLoad : self . imageView . isMultipleTouchEnabled = true Tambi\u00e9n podr\u00edamos haberlo hecho desde el Storyboard, pinchando sobre el UIImageView : Y luego podemos gestionar los toques simult\u00e1neos como en el siguiente ejemplo, en el que vamos a modificar el m\u00e9todo touchesBegan : override func touchesBegan ( _ touches : Set < UITouch >, with event : UIEvent ?) { if let touch = touches . first { // S\u00f3lo nos centramos en el primer toque print ( \"Touches began\" ) let touchCount = event !. allTouches !. count // N\u00famero de dedos pulsando let tapCount = touch . tapCount // N\u00faero de pulsaciones r\u00e1pidas print ( \"Finger count= \\( touchCount ) \" ) print ( \"Tap count= \\( tapCount ) \" ) let loc = touch . location ( in : self . view ) if self . imageView . frame . contains ( loc ) { print ( \"Detectado toque sobre la imagen\" ) self . tocaImagen = true } } super . touchesBegan ( touches , with : event ) } En el fragmento de c\u00f3digo anterior, si se ha hecho alguna pulsaci\u00f3n distinguimos primero el n\u00famero de dedos y luego comprobamos el n\u00famero de pulsaciones r\u00e1pidas (equivalente a un doble click del rat\u00f3n). Esto es un claro ejemplo de gesti\u00f3n de la funci\u00f3n multitouch de iOS y, como se puede ver, es bastante simple de implementar. Para simular dos pulsaciones al mismo tiempo en el simulador de iPhone/iPad de XCode, podemos pulsar la tecla alt (opci\u00f3n) mientras movemos el cursor. Desde XCode 7 existe la opci\u00f3n de usar 3D touch , que b\u00e1sicamente consiste en un sensor de presi\u00f3n para la pantalla de forma que se puedan ejecutar distintas acciones en funci\u00f3n del grado de presi\u00f3n. Desde XCode 7.3 podemos usar el simulador para esto (antes estaba limitado a dispositivos reales). No vamos a entrar en detalles sobre el 3D Touch , pero si quieres saber m\u00e1s la clase UITouch tiene una propiedad adicional llamada force que se usa para medir la fuerza de la pulsaci\u00f3n del usuario con respecto a una fuerza m\u00e1xima cuyo valor es maximumPossibleForce . if self . traitCollection . forceTouchCapability == UIForceTouchCapability . available { print ( \"Force= \\( touch . force ) from \\( touch . maximumPossibleForce ) \" ) } En algunos modelos de iPad tambi\u00e9n se puede usar un l\u00e1piz digital ( Apple Pencil ). Podemos distinguir un trazo del l\u00e1piz de una pulsaci\u00f3n del dedo mediante la siguiente condici\u00f3n: if touch . type == . stylus { print ( \"Stylus detected\" ) } Adem\u00e1s, desde el iPhone 7 Apple ha introducido Haptic Feedback , que permite responder f\u00edsicamente a las interacciones del usuario con la pantalla. Para m\u00e1s informaci\u00f3n, se puede consultar la referencia de la clase UIFeedbackGenerator . Reconocimiento de gestos multit\u00e1ctiles con UIGestureRecognizer En el apartado anterior hemos visto como mover un objeto por la pantalla usando los m\u00e9todos de detecci\u00f3n de pulsaciones en la pantalla y programando todo el c\u00f3digo nosotros. Esto est\u00e1 bien para gestos simples, pero el problema de lo que hemos implementado anteriormente es que si queremos detectar un gesto como un swipe , tendremos que registrar las notificaciones para cada toque de las vistas (usando touchesBegan , touchesMoved y touchesEnded ). En las primeras versiones de iOS cada programador escrib\u00eda c\u00f3digo distinto para detectar los toques en la pantalla, provocando bugs e incosistencias entre apps. Para evitar esto, hace mucho tiempo (iOS 3) Apple a\u00f1adi\u00f3 la clase UIGestureRecognizer para los gestos comunes en iOS. Esta clase nos permite gestionar los toques, el efecto \"pellizco\" (por ejemplo para hacer zoom), rotaciones, swipes, pans, y pulsaciones largas, entre otras. Usando esta clase no s\u00f3lo ahorramos mucho c\u00f3digo sino que tambi\u00e9n hacemos que nuestras apps sean consistentes. Los gestos que podemos gestionar en iOS son los siguientes: Toque ( tap ): Consiste en presionar o hacer \"click\" sobre un bot\u00f3n o cualquier objeto que est\u00e9 en pantalla. Arrastre ( drag ): Mover el dedo sobre la pantalla en una direcci\u00f3n, puede usarse para navegar sobre los elementos de una tabla, por ejemplo. Arrastre r\u00e1pido ( flick ): Como el anterior, pero m\u00e1s r\u00e1pido. Sirve para moverse por la pantalla de forma r\u00e1pida. Arrastre lateral ( swipe ): Mover el dedo en direcci\u00f3n horizontal, sirve para mostrar el bot\u00f3n de \"Eliminar\" en una fila de una tabla. Doble toque ( double tap ): Presionar dos veces seguidas y de forma r\u00e1pida la pantalla. Sirve para aumentar una imagen o un mapa, por ejemplo. Pellizco exterior ( pinch open ): Gesto de pellizco sobre la pantalla que sirve para aumentar una imagen o un mapa. Pellizco interior ( pinch close ): El inverso del anterior. Toque continuo ( touch and hold ): Como el toque b\u00e1sico, pero manteniendo el dedo sobre la pantalla. Sirve para mostrar un menu contextual sobre la zona que se pulsa. Agitar ( shake ): Para inicializar una acci\u00f3n de deshacer (undo) o rehacer (redo). 3D touch ( hard press ): Los modelos posteriores a iPhone 6S a\u00f1aden un gesto 3D que se activa cuando pulsamos la pantallas con una presi\u00f3n mayor. Se usa para mostrar informaci\u00f3n como un peek (una vista flotante) o pop (men\u00fa contextual). Puedes ver los movimientos en detalle en la gu\u00eda de estilo, secci\u00f3n Inputs > Touchscreen gestures . Usar la clase UIGestureRecognizer es muy sencillo, simplemente hay que: * Crear un Gesture Recognizer . Cuando se crea un elemento de esta clase debemos especificar una funci\u00f3n callback . Esta funci\u00f3n se llamar\u00e1 cuando los gestos empiecen, cambien o terminen. * A\u00f1adir un Gesture Recognizer a la vista. Cada gesture recognizer se asocia con una (y s\u00f3lo una ) vista. Cuando se produce un gesto dentro de los l\u00edmites de esa vista, el recognizer mirar\u00e1 si coincide con el tipo de gesto buscado, y si es as\u00ed se notificar\u00e1 mediante la funci\u00f3n callback . Podemos a\u00f1adir un Gesture Recognizer mediante c\u00f3digo o usando el storyboard. Veremos como hacerlo de las dos formas mediante un ejercicio sencillo similar al anterior. Ejercicio 2 - Multitouch Crea un nuevo proyecto y ll\u00e1malo ejercicio_multitouch . Como en el anterior, a\u00f1ade una UIImageView en la parte superior izquierda de la vista, as\u00edgnale la imagen logo-master y enl\u00e1zala con el controlador. Recuerda marcar para el UIImageView desde el Storyboard las casillas User Interaction Enabled y seleccionar Multiple Touch . Alternativamente puedes hacerlo mediante c\u00f3digo en viewDidLoad : self . imageView . isUserInteractionEnabled = true self . imageView . isMultipleTouchEnabled = true Vamos a definir un gesto que realice la funci\u00f3n de pulsaci\u00f3n, similar a lo realizado en el primer ejemplo, pero con UIGestureRecognizer . Para ello, en ViewController.swift asignamos el protocolo: class ViewController : UIViewController , UIGestureRecognizerDelegate Y en el fichero ViewController.swift a\u00f1adimos lo siguiente al final del m\u00e9todo viewDidLoad : let tap = UITapGestureRecognizer ( target : self , action : #selector ( handleTap )) tap . delegate = self self . imageView . addGestureRecognizer ( tap ) En el c\u00f3digo anterior nos hemos definido un objeto de la clase UITapGestureRecognizer , al cual le hemos asignado una acci\u00f3n llamada handleTap que se ejecutar\u00e1 cuando se detecte una pulsaci\u00f3n. Tambi\u00e9n hemos asignado el objeto creado a la imagen para que los gestos est\u00e9n \u00fanicamente asociados a esa vista. Ahora implementamos el m\u00e9todo handleTap : @objc func handleTap ( sender : UITapGestureRecognizer ) { print ( \"Tap\" ); } Si volvemos a ejecutar la aplicaci\u00f3n veremos que aparece el mensaje \"Tap\" cuando pulsamos sobre la imagen. A continuaci\u00f3n vamos a a\u00f1adir los gestos de arrastre, rotaci\u00f3n y pellizco de la misma manera que hemos implementado el de pulsaci\u00f3n: // Gesto de pulsar y arrastrar let pan = UIPanGestureRecognizer ( target : self , action : #selector ( handlePan )) pan . delegate = self self . imageView . addGestureRecognizer ( pan ) // Gesto de rotaci\u00f3n let rotation = UIRotationGestureRecognizer ( target : self , action : #selector ( handleRotation )) rotation . delegate = self self . imageView . addGestureRecognizer ( rotation ) // Gesto de pellizcar let pinch = UIPinchGestureRecognizer ( target : self , action : #selector ( handlePinch )) pinch . delegate = self self . imageView . addGestureRecognizer ( pinch ) Implementamos los m\u00e9todos de las acciones: @objc func handlePan ( sender : UIPanGestureRecognizer ) { print ( \"Pan\" ) let translation = sender . translation ( in : self . view ) if let view = sender . view { view . center = CGPoint ( x : view . center . x + translation . x , y : view . center . y + translation . y ) } sender . setTranslation ( CGPoint . zero , in : self . view ) } @objc func handleRotation ( sender : UIRotationGestureRecognizer ) { print ( \"Rotation\" ) if let view = sender . view { view . transform = view . transform . rotated ( by : sender . rotation ) sender . rotation = 0 } } @objc func handlePinch ( sender : UIPinchGestureRecognizer ) { print ( \"Pinch\" ) if let view = sender . view { view . transform = view . transform . scaledBy ( x : sender . scale , y : sender . scale ) sender . scale = 1 ; } } Si ejecutamos la aplicaci\u00f3n veremos que funciona todo correctamente pero al intentar realizar dos gestos al mismo tiempo estos no funcionan de manera simult\u00e1nea por ejemplo, ampliar y rotar). Para que dos o m\u00e1s gestos se puedan usar al mismo tiempo, en el fichero ViewController.swift tenemos que implementar el m\u00e9todo shouldRecognizeSimultaneouslyWithGestureRecognizer : func gestureRecognizer ( _ gestureRecognizer : UIGestureRecognizer , shouldRecognizeSimultaneouslyWith otherGestureRecognizer : UIGestureRecognizer ) -> Bool { return true } Si volvemos a ejecutar la aplicaci\u00f3n de nuevo, veremos que ya podemos realizar dos o m\u00e1s gestos al mismo tiempo. En total podemos usar los siguientes gestos en nuestras aplicaciones, adem\u00e1s de crear los nuestros propios creando subclases de UIGestureRecognizer : UITapGestureRecognizer UIPinchGestureRecognizer UIRotationGestureRecognizer UISwipeGestureRecognizer UIPanGestureRecognizer UIScreenEdgePanGestureRecognizer UILongPressGestureRecognizer Y esto es lo b\u00e1sico para poder implementar reconocimiento de gestos en nuestra aplicaci\u00f3n. Para finalizar vamos a implementar un gesto adicional, pero en lugar de hacerlo mediante c\u00f3digo lo haremos desde el storyboard para verlo de una forma alternativa. Para a\u00f1adirlo desde el storyboard (aunque probablemente es m\u00e1s r\u00e1pido desde c\u00f3digo), selecciona el gesto Long press Gesture Recognizer de la Librer\u00eda (con el bot\u00f3n + ) y arr\u00e1stralo sobre la imagen. Puedes cambiar desde el interfaz sus par\u00e1metros, como por ejemplo la duraci\u00f3n m\u00ednima. Finalmente asigna un m\u00e9todo al gesto, arrastrando el objeto al c\u00f3digo de la clase y seleccionando Action , y conecta el delegado con el ViewController . El m\u00e9todo debe imprimir el mensaje print(\"long press\") cuando se realice una pulsaci\u00f3n larga sobre la imagen. Con el bot\u00f3n derecho sobre el gesto puedes ver con qu\u00e9 objeto se relaciona y cambiarlo si es necesario.","title":"4- Detecci\u00f3n de gestos"},{"location":"sesion-4-multitouch.html#pantalla-tactil","text":"El sensor de pantalla es, obviamente, el m\u00e1s usado y com\u00fan de todos. En una aplicaci\u00f3n iOS que utilice los componentes b\u00e1sicos de UIKit como tablas, botones, campos de texto, etc. problamente no tendremos que preocuparnos por gestionar los eventos producidos por el sensor de la pantalla. En aplicaciones como juegos, o m\u00e1s elaboradas, es muy habitual que tengamos que hacer uso de los eventos que detallaremos a continuaci\u00f3n. La gesti\u00f3n de eventos de entrada ( Touch Events ) se realiza a trav\u00e9s de los siguientes m\u00e9todos, que m\u00e1s adelante detallaremos mediante un ejemplo: func touchesBegan(Set<UITouch>, with: UIEvent?) : Captura las pulsaciones sobre la pantalla. El m\u00e9todo recibe la lista de pulsaciones que se detectan. func touchesMoved(Set<UITouch>, with: UIEvent?) : Captura los movimientos de las pulsaciones sobre la pantalla func touchesEnded(Set<UITouch>, with: UIEvent?) : Captura las \u00faltimas pulsaciones sobre la pantalla func touchesCancelled(Set<UITouch>, with: UIEvent?) : Evento que se ejecuta cuando cerramos la aplicaci\u00f3n o la vista mientras se est\u00e1 detectando pulsaciones en la pantalla, o cuando se interrumpe por un evento externo como una llamada. En general, estos eventos pertenecen a la clase UIResponder . Puedes obtener m\u00e1s informaci\u00f3n sobre esta clase aqu\u00ed . Adem\u00e1s de los eventos de pulsaci\u00f3n sobre la pantalla, controla los de movimiento (por ejemplo cuando se agita el dispositivo) y los de control remoto (cuando se dispone de un dispositivo externo de control). Los dispositivos iOS tambi\u00e9n admiten varias pulsaciones al mismo tiempo, lo que se le conoce con el nombre de multitouch . Esta caracter\u00edstica hay que tenerla en cuenta a la hora de implementar los m\u00e9todos anteriores. Para entrar m\u00e1s en profundidad en el uso de las funciones de pulsaciones en iOS, vamos a realizar una aplicaci\u00f3n de ejemplo en la que arrastraremos una imagen por la pantalla de nuestro dispositivo.","title":"Pantalla t\u00e1ctil"},{"location":"sesion-4-multitouch.html#ejercicio-1-gestos","text":"Comenzamos creando un proyecto en XCode de tipo App con storyboard que guardaremos con el nombre ejercicio_touch . Creamos un objeto de tipo UIImageView , lo arrastramos a la vista coloc\u00e1ndolo en la parte superior izquierda de la pantalla, y lo enlazamos a nuestro ViewController para crear la propiedad, a la que llamaremos imageView . Arrastra la imagen logo-master.png al proyecto y as\u00edgnala a la vista como se indica a continuaci\u00f3n (aunque tambi\u00e9n se podr\u00eda hacer por c\u00f3digo): Ahora editamos el archivo ViewController.swift , y a\u00f1adimos un Outlet que enlazamos con nuestro UIImageView y un booleano llamado tocaImagen . Debe quedar de la siguiente forma: @IBOutlet weak var imageView : UIImageView ! var tocaImagen = false Como se puede ver tenemos dos propiedades: una imagen que podremos mover por la pantalla, y un booleano que utilizaremos para indicar si la estamos moviendo o no. Ahora a\u00f1adimos al fichero ViewController.swift los cuatro m\u00e9todos que gestionan los gestos: override func touchesBegan ( _ touches : Set < UITouch >, with event : UIEvent ?) { if let touch = touches . first { print ( \"Touches began\" ) let loc = touch . location ( in : self . view ) if self . imageView . frame . contains ( loc ) { print ( \"Detectado toque sobre la imagen\" ) self . tocaImagen = true } } super . touchesBegan ( touches , with : event ) } override func touchesMoved ( _ touches : Set < UITouch >, with event : UIEvent ?) { if let touch = touches . first { print ( \"Touches moved\" ) let loc = touch . location ( in : self . view ) if self . tocaImagen == true { self . imageView . center = loc } } super . touchesMoved ( touches , with : event ) } override func touchesEnded ( _ touches : Set < UITouch >, with event : UIEvent ?) { print ( \"Touches ended\" ) self . tocaImagen = false super . touchesEnded ( touches , with : event ) } override func touchesCancelled ( _ touches : Set < UITouch >, with event : UIEvent ?) { print ( \"Touches cancelled\" ) self . tocaImagen = false super . touchesCancelled ( touches , with : event ) } Como podemos observar en el c\u00f3digo anterior, hemos utilizado la clase de UIKit UITouch . Esta clase representa el evento de toque. Al mismo tiempo que el usuario interact\u00faa con la pantalla, iOS env\u00eda continuamente mensajes al evento correspondiente (uno de los cuatro comentados anteriormente). Cada evento incluye informaci\u00f3n sobre los distintos toques en la secuencia producida por el usuario y cada toque en particular corresponde a una instancia de la clase UITouch . Con esto \u00faltimo ya podemos ejecutar la aplicaci\u00f3n y veremos que podemos pulsar sobre la imagen y arrastrarla. El funcionamiento de estos m\u00e9todos es muy simple. Primero se ejecuta touchesBegan que detecta el primer toque sobre la pantalla, en el comprobamos si la posici\u00f3n del toque est\u00e1 dentro del cuadro ( frame ) del UIImageView . Si es as\u00ed actualizamos la variable booleana a true , y en caso contrario no hacemos nada. En el momento en que arrastremos el dedo sobre la pantalla se ejecutar\u00e1 continuamente el m\u00e9todo touchesMoved . En este, si la variable booleana tocaImagen est\u00e1 a true actualizamos la posici\u00f3n de la imagen a la posici\u00f3n detectada, y en caso contrario no hacemos nada. Por \u00faltimo, cuando dejamos de pulsar la pantalla se ejecutar\u00e1 el m\u00e9todo touchesEnded el cual simplemente volver\u00e1 a actualizar la variable booleana a false . Si queremos detectar varios toques al mismo tiempo, primero deberemos activarlo, por ejemplo en viewDidLoad : self . imageView . isMultipleTouchEnabled = true Tambi\u00e9n podr\u00edamos haberlo hecho desde el Storyboard, pinchando sobre el UIImageView : Y luego podemos gestionar los toques simult\u00e1neos como en el siguiente ejemplo, en el que vamos a modificar el m\u00e9todo touchesBegan : override func touchesBegan ( _ touches : Set < UITouch >, with event : UIEvent ?) { if let touch = touches . first { // S\u00f3lo nos centramos en el primer toque print ( \"Touches began\" ) let touchCount = event !. allTouches !. count // N\u00famero de dedos pulsando let tapCount = touch . tapCount // N\u00faero de pulsaciones r\u00e1pidas print ( \"Finger count= \\( touchCount ) \" ) print ( \"Tap count= \\( tapCount ) \" ) let loc = touch . location ( in : self . view ) if self . imageView . frame . contains ( loc ) { print ( \"Detectado toque sobre la imagen\" ) self . tocaImagen = true } } super . touchesBegan ( touches , with : event ) } En el fragmento de c\u00f3digo anterior, si se ha hecho alguna pulsaci\u00f3n distinguimos primero el n\u00famero de dedos y luego comprobamos el n\u00famero de pulsaciones r\u00e1pidas (equivalente a un doble click del rat\u00f3n). Esto es un claro ejemplo de gesti\u00f3n de la funci\u00f3n multitouch de iOS y, como se puede ver, es bastante simple de implementar. Para simular dos pulsaciones al mismo tiempo en el simulador de iPhone/iPad de XCode, podemos pulsar la tecla alt (opci\u00f3n) mientras movemos el cursor. Desde XCode 7 existe la opci\u00f3n de usar 3D touch , que b\u00e1sicamente consiste en un sensor de presi\u00f3n para la pantalla de forma que se puedan ejecutar distintas acciones en funci\u00f3n del grado de presi\u00f3n. Desde XCode 7.3 podemos usar el simulador para esto (antes estaba limitado a dispositivos reales). No vamos a entrar en detalles sobre el 3D Touch , pero si quieres saber m\u00e1s la clase UITouch tiene una propiedad adicional llamada force que se usa para medir la fuerza de la pulsaci\u00f3n del usuario con respecto a una fuerza m\u00e1xima cuyo valor es maximumPossibleForce . if self . traitCollection . forceTouchCapability == UIForceTouchCapability . available { print ( \"Force= \\( touch . force ) from \\( touch . maximumPossibleForce ) \" ) } En algunos modelos de iPad tambi\u00e9n se puede usar un l\u00e1piz digital ( Apple Pencil ). Podemos distinguir un trazo del l\u00e1piz de una pulsaci\u00f3n del dedo mediante la siguiente condici\u00f3n: if touch . type == . stylus { print ( \"Stylus detected\" ) } Adem\u00e1s, desde el iPhone 7 Apple ha introducido Haptic Feedback , que permite responder f\u00edsicamente a las interacciones del usuario con la pantalla. Para m\u00e1s informaci\u00f3n, se puede consultar la referencia de la clase UIFeedbackGenerator .","title":"Ejercicio 1 - Gestos"},{"location":"sesion-4-multitouch.html#reconocimiento-de-gestos-multitactiles-con-uigesturerecognizer","text":"En el apartado anterior hemos visto como mover un objeto por la pantalla usando los m\u00e9todos de detecci\u00f3n de pulsaciones en la pantalla y programando todo el c\u00f3digo nosotros. Esto est\u00e1 bien para gestos simples, pero el problema de lo que hemos implementado anteriormente es que si queremos detectar un gesto como un swipe , tendremos que registrar las notificaciones para cada toque de las vistas (usando touchesBegan , touchesMoved y touchesEnded ). En las primeras versiones de iOS cada programador escrib\u00eda c\u00f3digo distinto para detectar los toques en la pantalla, provocando bugs e incosistencias entre apps. Para evitar esto, hace mucho tiempo (iOS 3) Apple a\u00f1adi\u00f3 la clase UIGestureRecognizer para los gestos comunes en iOS. Esta clase nos permite gestionar los toques, el efecto \"pellizco\" (por ejemplo para hacer zoom), rotaciones, swipes, pans, y pulsaciones largas, entre otras. Usando esta clase no s\u00f3lo ahorramos mucho c\u00f3digo sino que tambi\u00e9n hacemos que nuestras apps sean consistentes. Los gestos que podemos gestionar en iOS son los siguientes: Toque ( tap ): Consiste en presionar o hacer \"click\" sobre un bot\u00f3n o cualquier objeto que est\u00e9 en pantalla. Arrastre ( drag ): Mover el dedo sobre la pantalla en una direcci\u00f3n, puede usarse para navegar sobre los elementos de una tabla, por ejemplo. Arrastre r\u00e1pido ( flick ): Como el anterior, pero m\u00e1s r\u00e1pido. Sirve para moverse por la pantalla de forma r\u00e1pida. Arrastre lateral ( swipe ): Mover el dedo en direcci\u00f3n horizontal, sirve para mostrar el bot\u00f3n de \"Eliminar\" en una fila de una tabla. Doble toque ( double tap ): Presionar dos veces seguidas y de forma r\u00e1pida la pantalla. Sirve para aumentar una imagen o un mapa, por ejemplo. Pellizco exterior ( pinch open ): Gesto de pellizco sobre la pantalla que sirve para aumentar una imagen o un mapa. Pellizco interior ( pinch close ): El inverso del anterior. Toque continuo ( touch and hold ): Como el toque b\u00e1sico, pero manteniendo el dedo sobre la pantalla. Sirve para mostrar un menu contextual sobre la zona que se pulsa. Agitar ( shake ): Para inicializar una acci\u00f3n de deshacer (undo) o rehacer (redo). 3D touch ( hard press ): Los modelos posteriores a iPhone 6S a\u00f1aden un gesto 3D que se activa cuando pulsamos la pantallas con una presi\u00f3n mayor. Se usa para mostrar informaci\u00f3n como un peek (una vista flotante) o pop (men\u00fa contextual). Puedes ver los movimientos en detalle en la gu\u00eda de estilo, secci\u00f3n Inputs > Touchscreen gestures . Usar la clase UIGestureRecognizer es muy sencillo, simplemente hay que: * Crear un Gesture Recognizer . Cuando se crea un elemento de esta clase debemos especificar una funci\u00f3n callback . Esta funci\u00f3n se llamar\u00e1 cuando los gestos empiecen, cambien o terminen. * A\u00f1adir un Gesture Recognizer a la vista. Cada gesture recognizer se asocia con una (y s\u00f3lo una ) vista. Cuando se produce un gesto dentro de los l\u00edmites de esa vista, el recognizer mirar\u00e1 si coincide con el tipo de gesto buscado, y si es as\u00ed se notificar\u00e1 mediante la funci\u00f3n callback . Podemos a\u00f1adir un Gesture Recognizer mediante c\u00f3digo o usando el storyboard. Veremos como hacerlo de las dos formas mediante un ejercicio sencillo similar al anterior.","title":"Reconocimiento de gestos multit\u00e1ctiles con UIGestureRecognizer"},{"location":"sesion-4-multitouch.html#ejercicio-2-multitouch","text":"Crea un nuevo proyecto y ll\u00e1malo ejercicio_multitouch . Como en el anterior, a\u00f1ade una UIImageView en la parte superior izquierda de la vista, as\u00edgnale la imagen logo-master y enl\u00e1zala con el controlador. Recuerda marcar para el UIImageView desde el Storyboard las casillas User Interaction Enabled y seleccionar Multiple Touch . Alternativamente puedes hacerlo mediante c\u00f3digo en viewDidLoad : self . imageView . isUserInteractionEnabled = true self . imageView . isMultipleTouchEnabled = true Vamos a definir un gesto que realice la funci\u00f3n de pulsaci\u00f3n, similar a lo realizado en el primer ejemplo, pero con UIGestureRecognizer . Para ello, en ViewController.swift asignamos el protocolo: class ViewController : UIViewController , UIGestureRecognizerDelegate Y en el fichero ViewController.swift a\u00f1adimos lo siguiente al final del m\u00e9todo viewDidLoad : let tap = UITapGestureRecognizer ( target : self , action : #selector ( handleTap )) tap . delegate = self self . imageView . addGestureRecognizer ( tap ) En el c\u00f3digo anterior nos hemos definido un objeto de la clase UITapGestureRecognizer , al cual le hemos asignado una acci\u00f3n llamada handleTap que se ejecutar\u00e1 cuando se detecte una pulsaci\u00f3n. Tambi\u00e9n hemos asignado el objeto creado a la imagen para que los gestos est\u00e9n \u00fanicamente asociados a esa vista. Ahora implementamos el m\u00e9todo handleTap : @objc func handleTap ( sender : UITapGestureRecognizer ) { print ( \"Tap\" ); } Si volvemos a ejecutar la aplicaci\u00f3n veremos que aparece el mensaje \"Tap\" cuando pulsamos sobre la imagen. A continuaci\u00f3n vamos a a\u00f1adir los gestos de arrastre, rotaci\u00f3n y pellizco de la misma manera que hemos implementado el de pulsaci\u00f3n: // Gesto de pulsar y arrastrar let pan = UIPanGestureRecognizer ( target : self , action : #selector ( handlePan )) pan . delegate = self self . imageView . addGestureRecognizer ( pan ) // Gesto de rotaci\u00f3n let rotation = UIRotationGestureRecognizer ( target : self , action : #selector ( handleRotation )) rotation . delegate = self self . imageView . addGestureRecognizer ( rotation ) // Gesto de pellizcar let pinch = UIPinchGestureRecognizer ( target : self , action : #selector ( handlePinch )) pinch . delegate = self self . imageView . addGestureRecognizer ( pinch ) Implementamos los m\u00e9todos de las acciones: @objc func handlePan ( sender : UIPanGestureRecognizer ) { print ( \"Pan\" ) let translation = sender . translation ( in : self . view ) if let view = sender . view { view . center = CGPoint ( x : view . center . x + translation . x , y : view . center . y + translation . y ) } sender . setTranslation ( CGPoint . zero , in : self . view ) } @objc func handleRotation ( sender : UIRotationGestureRecognizer ) { print ( \"Rotation\" ) if let view = sender . view { view . transform = view . transform . rotated ( by : sender . rotation ) sender . rotation = 0 } } @objc func handlePinch ( sender : UIPinchGestureRecognizer ) { print ( \"Pinch\" ) if let view = sender . view { view . transform = view . transform . scaledBy ( x : sender . scale , y : sender . scale ) sender . scale = 1 ; } } Si ejecutamos la aplicaci\u00f3n veremos que funciona todo correctamente pero al intentar realizar dos gestos al mismo tiempo estos no funcionan de manera simult\u00e1nea por ejemplo, ampliar y rotar). Para que dos o m\u00e1s gestos se puedan usar al mismo tiempo, en el fichero ViewController.swift tenemos que implementar el m\u00e9todo shouldRecognizeSimultaneouslyWithGestureRecognizer : func gestureRecognizer ( _ gestureRecognizer : UIGestureRecognizer , shouldRecognizeSimultaneouslyWith otherGestureRecognizer : UIGestureRecognizer ) -> Bool { return true } Si volvemos a ejecutar la aplicaci\u00f3n de nuevo, veremos que ya podemos realizar dos o m\u00e1s gestos al mismo tiempo. En total podemos usar los siguientes gestos en nuestras aplicaciones, adem\u00e1s de crear los nuestros propios creando subclases de UIGestureRecognizer : UITapGestureRecognizer UIPinchGestureRecognizer UIRotationGestureRecognizer UISwipeGestureRecognizer UIPanGestureRecognizer UIScreenEdgePanGestureRecognizer UILongPressGestureRecognizer Y esto es lo b\u00e1sico para poder implementar reconocimiento de gestos en nuestra aplicaci\u00f3n. Para finalizar vamos a implementar un gesto adicional, pero en lugar de hacerlo mediante c\u00f3digo lo haremos desde el storyboard para verlo de una forma alternativa. Para a\u00f1adirlo desde el storyboard (aunque probablemente es m\u00e1s r\u00e1pido desde c\u00f3digo), selecciona el gesto Long press Gesture Recognizer de la Librer\u00eda (con el bot\u00f3n + ) y arr\u00e1stralo sobre la imagen. Puedes cambiar desde el interfaz sus par\u00e1metros, como por ejemplo la duraci\u00f3n m\u00ednima. Finalmente asigna un m\u00e9todo al gesto, arrastrando el objeto al c\u00f3digo de la clase y seleccionando Action , y conecta el delegado con el ViewController . El m\u00e9todo debe imprimir el mensaje print(\"long press\") cuando se realice una pulsaci\u00f3n larga sobre la imagen. Con el bot\u00f3n derecho sobre el gesto puedes ver con qu\u00e9 objeto se relaciona y cambiarlo si es necesario.","title":"Ejercicio 2 - Multitouch"}]}