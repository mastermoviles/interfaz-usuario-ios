{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Table of contents","text":"<ul> <li>Presentaci\u00f3n</li> <li>Sesion 1 - Gu\u00edas de estilo y personalizaciones avanzadas</li> <li>Sesion 2 - Controladores avanzados</li> <li>Sesion 3 - Apps universales</li> <li>Sesion 4 - Gestos</li> </ul>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html","title":"1- Gu\u00edas de estilo y personalizaciones avanzadas","text":"<p>En esta primera sesi\u00f3n veremos los patrones de dise\u00f1o que Apple nos recomienda seguir para nuestras aplicaciones. En algunos casos es obligatorio cumplir estos patrones y el hecho de no hacerlo puede ser motivo de rechazo para publicar en el App Store. Por \u00faltimo implementaremos dos ejercicios de personalizaci\u00f3n de controladores. </p>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#guias-de-estilo-en-ios","title":"Gu\u00edas de estilo en iOS","text":"<p>Tanto el iPhone como el iPad supusieron un revolucionario giro en cuanto a dise\u00f1o de interfaz. Para evitar el caos a la hora de dise\u00f1ar cualquier tipo de aplicaci\u00f3n, tras cada actualizaci\u00f3n de iOS Apple plantea una serie de gu\u00edas de estilo que todo desarrollador debe seguir en la medida de lo posible para dise\u00f1ar una app. Estas guias de estilo no se aplican, como es l\u00f3gico, a la hora de dise\u00f1ar la interfaz de un juego, pero son muy \u00fatiles para crear aplicaciones.</p> <p>En esta sesi\u00f3n vamos a aprender a dise\u00f1ar apps para iPhone / iPad que sean usables, accesibles y en las que el usuario perciba una buena experiencia de uso. Hay que tener en cuenta que un usuario de iOS est\u00e1 habituado a una serie de elementos y situaciones b\u00e1sicas, como la navegaci\u00f3n dentro de vistas mediante Navigation Controllers, navegaci\u00f3n por las opciones mediante los Tab Bar Controllers, uso de botones, etc. Aqu\u00ed haremos un resumen de todo lo que Apple propone en sus guias de estilo. En esta asignatura nos centraremos en los aspectos principales de la gu\u00eda, aunque es recomendable leer por completo las gu\u00edas de estilo tras cada actualizaci\u00f3n de iOS, ya que las gu\u00edas cambian de un a\u00f1o para otro.</p> <p>Adem\u00e1s de la gu\u00eda de estilo oficial, conviene consultar detalladamente este enlace: iOS Design do's and don'ts.</p> <p>En esta secci\u00f3n veremos 3 puntos principales:</p> <ul> <li>Principios de dise\u00f1o</li> <li>Caracter\u00edsticas de la plataforma iOS</li> <li>Gu\u00edas de uso de las principales tecnolog\u00edas disponibles en iOS</li> </ul>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#principios-de-diseno","title":"Principios de dise\u00f1o","text":"<p>Apple recomienda dise\u00f1ar apps siguiendo estos principios:</p> <ul> <li>Claridad. En nuestras apps el texto debe poder ser legible a cualquier tama\u00f1o, los iconos deben ser precisos y claros, los adornos poco recargados y apropiados, y debemos centrarnos principalmente en la funcionalidad. Los espacios negativos, colores, fuentes, gr\u00e1ficos y elementos del interfaz deben resaltar el contenido que es importante y facilitar la interacci\u00f3n.</li> <li>Amigabilidad. Un interfaz fluido, claro y visualmente atractivo ayuda a los usuarios a entender e interactuar con el contenido, que normalmente ocupa la pantalla completa. Es importante mantener el interfaz ligero y claro para que el contenido destaque mejor.</li> <li>Profundidad. Las distintas capas visuales y el movimiento realista deben facilitar la comprensi\u00f3n de la jerarqu\u00eda del interfaz e imprimir dinamismo. Tocar y descubrir mejora la sensaci\u00f3n de interacci\u00f3n y permite el acceso a funcionalidades y contenidos adicionales sin perder el contexto. Las transiciones proporcionan una sensaci\u00f3n de profundidad mientras se navega por el contenido.</li> </ul> <p>En general, lo principal que deben tener las aplicaciones es:</p> <ul> <li>Integridad est\u00e9tica: debemos integrar adecuadamente el aspecto visual con su funcionalidad.</li> <li>Consistencia: deben usarse elementos est\u00e1ndar a los que ya est\u00e1n habituados los usuarios de iOS y un dise\u00f1o uniforme durante toda la app.</li> <li>Adaptabilidad: es muy recomendable que el contenido de la pantalla cambie cuando se rota el dispositivo o se usan gestos. Las vistas deben adaptarse a cambios de orientaci\u00f3n de dispositivo, modo oscuro (dark mode) y tipos din\u00e1micos, dejando que los usuarios elijan las configuraciones que prefieran desde la configuraci\u00f3n general del dispositivo. </li> <li>Feedback: se deben confirmar las acciones y mostrar resultados para informar al usuario de que ha interactuado con nuestra app.</li> </ul> <p>Antes de comenzar a dise\u00f1ar una app tambi\u00e9n es muy importante conocer qui\u00e9nes son los usuarios a los que nos dirigimos, es decir, el p\u00fablico objetivo, y en funci\u00f3n de esto definir la interfaz gr\u00e1fica, los controles, terminolog\u00eda, etc. No es lo mismo dise\u00f1ar una app para ni\u00f1os que una de contabilidad, por ejemplo.</p> <p>Siempre es recomendable hacer un dise\u00f1o previo usando Mockups, storyboards u otras herramientas antes de que la app sea funcional. Existen varios programas de Mockups, como mockup.io o Balsamiq.</p> <p>La aplicaci\u00f3n que dise\u00f1es debe estar totalmente adaptada a un dispositivo iOS, no a web u otro tipo. El usuario lo agradecer\u00e1 (y Apple, cuando lo revise, tambi\u00e9n). La inmensa mayoria de usuarios de iOS est\u00e1n acostumbrados al uso de botones, barras de navegaci\u00f3n, Tab Bars, etc. Por tanto, en la medida de lo posible debemos hacer uso de toda esta serie de componentes que han sido dise\u00f1ados de forma espec\u00edfica para dispositivos iOS y con los que los usuarios est\u00e1n muy familiarizados.</p> <p>En este enlace se pueden ver todos los componentes que podemos usar en nuestras apps. Se dividen en:</p> <ul> <li>Contenido. Estos componentes sirven para mostrar gr\u00e1ficos, texto, im\u00e1genes, o contenidos web.</li> <li>Distribuci\u00f3n y organizaci\u00f3n. Elementos como las colecciones, tablas o etiquetas pueden usarse para organizar y mostrar los datos. </li> <li>Men\u00fas y acciones. Para interaccionar con el usuario disponemos de botones, men\u00fas o pop-ups, entre otros.</li> <li>Navegaci\u00f3n y b\u00fasqueda. El usuario puede moverse por nuestra app usando barras de navegaci\u00f3n, tab bars o usando campos de b\u00fasqueda, entre otros.</li> <li>Presentaci\u00f3n. Para presentar los datos podemos usar alertas, controles de p\u00e1gina, popovers, vistas de scroll, etc.</li> <li>Selecci\u00f3n y entradas. Entre otros, se pueden elegir valores de una lista con pickers, usando segmented controls, o emplear sliders para valores num\u00e9ricos.</li> <li>Estado. El estado de una tarea se puede medir con barras de progreso, anillos de actividad o medidores (gauges).</li> <li>Experiencias del sistema. El usuario puede recibir notificaciones, puede ver la barra de estado de la app, usar widgets, etc.</li> </ul> <p>Todos los componentes pueden consultarse con m\u00e1s detalle en la referencia del cat\u00e1logo de UIKit. </p> <p>Es importante que las aplicaciones funcionen correctamente en todos los dispositivos donde puedan instalarse. Tambi\u00e9n hay que asegurarse antes de publicar en App Store de que no hay bugs, ya que si estos existen Apple puede rechazar la aplicaci\u00f3n, o si aparecen despu\u00e9s los usuarios podr\u00edan puntuarla mal o dejar de usarla. Existen una serie de puntos a tener en cuenta para esto:</p> <ul> <li>Hay que dise\u00f1ar cada aplicaci\u00f3n seg\u00fan el dispositivo en el que se use teniendo en cuenta especialmente las capas de vistas, ya que su aspecto puede cambiar bastante en funci\u00f3n del tama\u00f1o de pantalla disponible.</li> <li>Se debe de adaptar todo el arte (im\u00e1genes, videos, etc.) al dispositivo en cuesti\u00f3n. Para esto se usan los Assets. En las \u00faltimas versiones de iOS, se recomienda usar ficheros PDF en los Assets, ya que se adaptar\u00e1n a cualquier tama\u00f1o.</li> <li>Las caracter\u00edsticas principales de la aplicaci\u00f3n deben conservarse independientemente del tipo de dispositivo que se use.</li> <li>Cuando sea posible, es conveniente dise\u00f1ar las apps para que funcionen en todos los dispositivos Apple (iOS, iPadOS, watchOS, tvOS y macOS).</li> </ul>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#caracteristicas-principales-de-la-plataforma-ios","title":"Caracter\u00edsticas principales de la plataforma iOS","text":""},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#la-pantalla","title":"La pantalla","text":"<p>Todo usuario que usa una aplicaci\u00f3n interact\u00faa mediante la pantalla. Existen distintas resoluciones de pantalla (a nivel de desarrollo de c\u00f3digo y a nivel f\u00edsico) seg\u00fan cada dispositivo. Se pueden consultar consejos de dise\u00f1o y la resoluci\u00f3n de todos los modelos de Apple en este enlace. </p> <p>Es importante resaltar que el tama\u00f1o en puntos no es el mismo que el tama\u00f1o en p\u00edxeles, que normalmente es un m\u00faltiplo (2x, 3x) de los puntos, como puede verse en el siguiente ejemplo:</p> <p></p> <p>Nota sobre la detecci\u00f3n de contacto (touch events): El tama\u00f1o de la zona m\u00ednima para que el evento de contacto funcione correctamente debe de ser de al menos 44 x 44 puntos.</p> <p>Dada la diferencia de resoluci\u00f3n entre los distintos dispositivos de Apple, se recomienda usar siempre autolayout o SwiftUI en lugar de indicar expl\u00edcitamente coordenadas de la pantalla donde colocar los componentes.</p> <p>SwiftUI es el nuevo sistema de Apple para el desarrollo de interfaces. Tiene como principal ventaja sobre el sistema tradicional (UIKit) que se ahorra c\u00f3digo al usar sintaxis declarativa. Tambi\u00e9n facilita que la app funcione correctamente en todos los dispositivos debido a las mejores sobre el autolayout de UIKit. Sin embargo, en esta asignatura todav\u00eda no vamos a introducir este entorno porque es muy reciente, todav\u00eda tiene bugs y est\u00e1 sujeto a cambios frecuentes que pueden hacer que las apps no compilen correctamente en pocos meses. De todos modos, si quieres m\u00e1s informaci\u00f3n sobre SwiftUI puedes consultar este enlace.</p>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#orientacion-del-dispositivo","title":"Orientaci\u00f3n del dispositivo","text":"<p>Uno de los requisitos a la hora de publicar una aplicaci\u00f3n de iPhone/iPad en el App Store es la compatibilidad con las distintas orientaciones que puede adoptar el dispositivo iOS, tanto  vertical (portrait) como horizontal (landscape). Cualquier aplicaci\u00f3n debe  estar adaptada a ambas posiciones para mejorar la usabilidad. La programaci\u00f3n de la orientaci\u00f3n en una aplicaci\u00f3n iOS es relativamente sencilla (excepto en casos puntuales) y no implementarla puede suponer, como hemos comentado, el rechazo de su publicaci\u00f3n en el App Store.</p> <p>A continuaci\u00f3n puedes ver orientaciones de ejemplo para un iPhone y su layout:</p> <p></p> <p>Y para el iPad:</p> <p></p>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#storyboards","title":"Storyboards","text":"<p>Con <code>UIKit</code> se suelen dise\u00f1ar las apps usando un <code>Main.storyboard</code> (aunque tambi\u00e9n puede hacerse desde c\u00f3digo). Para la pantalla de inicio que se muestra brevemente al arrancar la aplicaci\u00f3n, a veces interesa implementar  otro storyboard adicional (<code>LaunchScreen.storyboard</code>) si el proceso de carga de la app es lento. Las nuevas apps basadas en <code>SwiftUI</code> no usan storyboards.</p>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#gestos","title":"Gestos","text":"<p>Llamamos gestos a los distintos movimientos que hace el usuario sobre la pantalla para realizar acciones. En la \u00faltima sesi\u00f3n veremos en detalle c\u00f3mo gestionar los gestos sobre la pantalla.</p>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#ayuda","title":"Ayuda","text":"<p>Una aplicaci\u00f3n debe ser lo suficientemente simple e intuitiva para que el usuario sepa usarla. Hay que tener en cuenta que el usuario no tendr\u00e1 tiempo ni ganas de estar leyendo un texto de ayuda la primera vez que usa la aplicaci\u00f3n. Lo ideal es que no sea necesario ninguna ayuda, pero si existe debe ser lo m\u00e1s clara y compacta posible, y si se pueden utilizar im\u00e1genes o videos, mejor.</p>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#sonidos","title":"Sonidos","text":"<p>A veces nos interesa reproducir sonidos en nuestra app, bien porque es necesario o para llamar la atenci\u00f3n del usuario. Sin embargho hay que tener en cuenta lo siguiente:</p> <ul> <li>Si el usuario activa el modo silencio en el dispositivo, este no debe de emitir ning\u00fan tipo de sonido. Hay apps que se saltan esto, y suele ser algo bastante molesto. Si nuestra app se basa completamente en el sonido (por ejemplo, un reproductor musical) puede que tengamos que hacer alguna acci\u00f3n (por ejemplo pausar la m\u00fasica) cuando se silencie el m\u00f3vil.</li> <li>El tipo de sonido escogido para las distintas caracter\u00edsticas de la aplicaci\u00f3n es muy importante. Estos sonidos deben ser adecuados y deben ajustarse al tipo de acci\u00f3n que se est\u00e9 ejecutando.</li> <li>Hay que tener tambi\u00e9n en cuenta la gesti\u00f3n de las interrupciones de audio. Por ejemplo, puede producirse una llamada entrante, la aplicaci\u00f3n pasar a estado inactivo (background), etc.</li> <li>Si estamos desarrollando una aplicaci\u00f3n musical, para mejorar la experiencia de usuario tambi\u00e9n podemos usar el control remoto de Apple o el sistema AirPlay.</li> </ul>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#accesibilidad","title":"Accesibilidad","text":"<p>iOS ofrece funcionalidades de accesibilidad para usuarios con discapacidades visuales o auditivas. Con poco esfuerzo y usando los componentes de UIKit podemos adaptar nuestra app para que todos los usuarios puedan usarla. Para esto se recomienda:</p> <ul> <li>Proporcionar etiquetas de texto alternativas para im\u00e1genes, iconos y elementos del interfaz. Estas etiquetas alternativas no ser\u00e1n visibles en la pantalla, pero permitir\u00e1n al sistema de voz (VoiceOver) describir qu\u00e9 hay en la pantalla, ayudando a las personas con problemas visuales.</li> <li>Responder a las opciones de accesibilidad. Debemos permitir a UIKit implementar su interfaz de usuario, para que los elementos se adapten a las preferencias de accesibilidad como texto en negrita o m\u00e1s grande, o eliminar animaciones. Debemos usar la fuente de texto del sistema cuando sea posible.</li> <li>Probar la app en modo accesible, para ver c\u00f3mo queda.</li> <li>Usar suficiente contraste para que los iconos y el texto sean f\u00e1cilmente distinguibles.</li> </ul>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#carga","title":"Carga","text":"<p>Si usamos una pantalla est\u00e1tica mientras se est\u00e1 cargando contenido, puede parecer que la app se haya bloqueado. En lugar de esto, hay que dejar claro que la carga est\u00e1 en marcha, por ejemplo usando barras de progreso o animaciones. </p>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#preferencias","title":"Preferencias","text":"<p>Si la aplicaci\u00f3n utiliza preferencias propias, podemos hacer una vista para ellas dentro de nuestra aplicaci\u00f3n en el caso de que el usuario necesite cambiarlas con frecuencia, o bien a\u00f1adir un settings bundle si el cambio no es tan frecuente. Un settings bundle contiene ficheros (principalmente .plist) que describen la estructura y estilo de presentaci\u00f3n de las preferencias, y es muy sencillo de implementar. La app Settings usa esta informaci\u00f3n para crear una entrada para nuestra aplicaci\u00f3n y mostrar las preferencias.</p> <p></p>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#guias-de-uso-de-las-principales-tecnologias-disponibles-en-ios","title":"Gu\u00edas de uso de las principales tecnolog\u00edas disponibles en iOS","text":"<p>La API de iOS nos da acceso a m\u00faltiples tecnolog\u00edas nativas que se describen a continuaci\u00f3n:</p>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#multitarea","title":"Multitarea","text":"<p>Mediante la multitarea nuestro dispositivo puede ejecutar m\u00e1s de dos aplicaciones al mismo tiempo. Otras tareas que no est\u00e9n mostr\u00e1ndose en pantalla pueden estar guardadas en memoria (en background) o tambi\u00e9n mostr\u00e1ndose simult\u00e1neamente en la pantalla. Apple recomienda que nuestra aplicaci\u00f3n tenga en cuenta dicha caracter\u00edstica ya que de esta forma el usuario puede estar realizando otras tareas al mismo tiempo sin necesidad de cerrarla.</p> <p></p> <p>La aplicaci\u00f3n debe estar preparada para gestionar interrupciones de audio en cualquier momento, pararse y reiniciarse sin ninguna complicaci\u00f3n ni lag y de forma \"suave\", y debe comportarse de forma adecuada cuando se encuentra en background. La multitarea es una tecnolog\u00eda que se utiliza muy a menudo en iOS y es por ello que debemos tenerla presente cuando dise\u00f1amos nuestras aplicaciones. La gesti\u00f3n del paso de un estado activo a inactivo debe programarse cuando sea necesario. Por ejemplo, hay que tener en cuenta que nuestro juego Angry Birds puede interrumpirse por una llamada a mitad del lanzamiento de un p\u00e1jaro.</p> <p>Para determinar el comportamiento de nuestra aplicaci\u00f3n cuando entra en modo background podemos implementar m\u00e9todos que se ver\u00e1n en otras asignaturas del m\u00e1ster.</p> <p>Adem\u00e1s de tener que estar preparados para interrupciones, la multitarea implica que nuestra app puede ejecutarse s\u00f3lo en una zona de la pantalla, por lo que hay que tener en cuenta esto en la fase de dise\u00f1o.</p>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#notificaciones","title":"Notificaciones","text":"<p>Las notificaciones push permiten avisar a los usuarios independientemente de si la aplicaci\u00f3n est\u00e1 funcionando en ese momento. Esto es muy \u00fatil en apps que usen un calendario, para avisar de eventos futuros, o para alg\u00fan tipo de recordatorio. Tambi\u00e9n se utiliza muy a menudo en juegos.</p> <p></p> <p>Se pueden enviar notificaciones usando un servidor propio, o bien generarlas localmente desde nuestra app. En el caso de requerir un servidor tambi\u00e9n se pueden contratar servicios externos que realicen esa tarea de forma bastante econ\u00f3mica.</p>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#extensiones","title":"Extensiones","text":"<p>Con las extensiones los usuarios pueden usar un componente desarrollado por nosotros desde una app externa. Por ejemplo, mientras un usuario ve una p\u00e1gina web con Safari, podr\u00eda usar nuestras extensiones para enviar una imagen o un art\u00edculo a nuestra red social. O podr\u00eda tambi\u00e9n usar desde la aplicaci\u00f3n de fotos de Apple una extensi\u00f3n nuestra para editar la imagen.</p> <p>Las extensiones pueden ser de tipo widget, para realizar acciones desde el notification center, share para compartir contenido con terceros, action para ver contenido desde otra aplicaci\u00f3n, photo editing para editar im\u00e1genes, o custom keyboard para reemplazar el teclado de iOS por uno personalizado, entre otras posibilidades.</p> <p> </p> <p>B\u00e1sicamente estos son los conceptos principales de la gu\u00eda de estilo de Apple, aunque hay m\u00e1s tecnolog\u00edas que pueden verse en su gu\u00eda de estilo.</p>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#personalizaciones-avanzadas","title":"Personalizaciones avanzadas","text":"<p>Las personalizaciones son las modificaciones sobre el aspecto visual de los componentes est\u00e1ndar de Apple. Por lo general las personalizaciones no se recomiendan para evitar confundir al usuario, pero a veces son necesarias para juegos o aplicaciones que requieran un aspecto diferente, como puede verse en el siguiente ejemplo:</p> <p></p> <p>Vamos a empezar programando ejemplos de personalizaci\u00f3n de controladores. </p>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#ejercicio-1-personalizacion-de-celdas","title":"Ejercicio 1- Personalizaci\u00f3n de celdas","text":"<p>La siguiente imagen muestra un ejemplo de una tabla con las celdas totalmente personalizadas.</p> <p></p> <p>A diferencia de la personalizaci\u00f3n de otros componentes, la personalizaci\u00f3n de celdas en las tablas es algo muy habitual en iOS. De esta forma podemos hacer que nuestras tablas se distingan del resto, mostrar datos de forma m\u00e1s adecuada, y ofrecer un aspecto caracter\u00edstico para nuestra app.</p> <p>\u00bfC\u00f3mo podemos hacer este tipo de celdas? Es muy sencillo, a continuaci\u00f3n veremos mediante un ejemplo paso a paso el dise\u00f1o y programaci\u00f3n de celdas personalizadas mediante XCode.</p>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#creando-el-proyecto-y-las-clases-basicas","title":"Creando el proyecto y las clases b\u00e1sicas","text":"<p>Al terminar este ejemplo tendremos una aplicaci\u00f3n que solo contiene una vista de tabla <code>UITableView</code> con celdas personalizadas. Estas celdas tendr\u00e1n una imagen en el lado izquierdo, un texto en negrita en la parte superior y otro texto peque\u00f1o en la parte inferior. Las celdas tendr\u00e1n un tama\u00f1o algo mayor al que viene por defecto y, para finalizar, la tabla tendr\u00e1 estilo zebra, es decir, el fondo de las celdas tendr\u00e1 colores intercalados para cada fila.</p> <p>Comenzaremos creando el proyecto. Para ello, abrimos XCode y creamos un nuevo proyecto para iOS de tipo App. Lo guardaremos con el nombre <code>ejercicio_celdas</code> seleccionando el interfaz Storyboard:</p> <p></p> <p>Para empezar vamos a a\u00f1adir al storyboard principal (Main) un nuevo controlador (usando el bot\u00f3n + en la parte superior del interfaz de XCode) de tipo <code>Table View Controller</code>.</p> <p>Ahora haremos que nuestra tabla sea lo primero que aparezca cuando se inicie la app. Esto se puede hacer, por ejemplo, arrastrando la flecha horizontal que apunta al primer controlador hacia nuestro nuevo Table View Controller. Ya podemos borrar la vista vac\u00eda del storyboard, que ahora comenzar\u00e1 con nuestra tabla. Podemos tambi\u00e9n borrar el fichero <code>ViewController.swift</code>, ya que estaba asociado a la vista que hemos eliminado.</p> <p>Ya tenemos la vista de la tabla. Ahora vamos a crear tambi\u00e9n un fichero de c\u00f3digo como controlador para poder programar los elementos de la celda. Seleccionamos File &gt; New &gt; File &gt; Cocoa Touch Class, y le damos el nombre <code>TableViewController</code>, subclase de <code>UITableViewController</code>, dejando sin marcar \"Also create XIB file\". </p> <p>Ahora tenemos que asignar la vista al controlador. Para ello, seleccionamos el controlador en el storyboard, y desde el Identity Inspector le asignamos la clase que hemos creado <code>TableViewController</code>, como se muestra en la imagen:</p> <p></p> <p>Por \u00faltimo, para nuestra vista personalizada vamos a crear un nuevo fichero subclase de <code>UITableViewCell</code>. Hacemos click en File &gt; New &gt; File &gt; Cocoa Touch Class, y seleccionamos Subclass of <code>UITableViewCell</code>, dejando sin marcar \"Also create XIB file\". Lo guardamos con el nombre <code>TableViewCell</code>.</p>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#disenando-la-celda-desde-interface-builder","title":"Dise\u00f1ando la celda desde Interface Builder","text":"<p>Una vez hemos creado el proyecto y la clase controladora de la tabla y la celda vamos a dise\u00f1ar su vista. Para ello abrimos la tabla en el storyboard. Dentro de Prototype cells podemos dise\u00f1ar la vista de la celda, pero antes tenemos que asignar a las celdas de nuestra tabla la clase <code>TableViewCell</code> que hemos creado.</p> <p></p> <p>Una vez hemos vinculado la vista de la celda a nuestro controlador vamos a modificar la altura de la celda desde el size inspector, usando una altura de 70 puntos:</p> <p></p> <p>Adem\u00e1s de indicar la altura de la celda para el <code>Table View Cell</code> (lo cual nos sirve para saber c\u00f3mo quedan los elementos en la vista de dise\u00f1o), tambi\u00e9n debemos hacerlo para las celdas del <code>Table View</code>:</p> <p></p> <p>Si quisieramos hacer lo mismo pero desde c\u00f3digo, podr\u00edamos indicarlo as\u00ed en el m\u00e9todo <code>viewDidLoad</code>:</p> <pre><code> self.tableView.rowHeight=70\n</code></pre> <p>Ahora solo tenemos que arrastrar los objetos que queremos que aparezcan en la celda. En este ejemplo vamos a a\u00f1adir dos etiquetas (<code>UILabel</code>) y una imagen (<code>UIImageView</code>). La celda quedar\u00e1 as\u00ed en el Interface builder:</p> <p></p> <p>En la pesta\u00f1a de Attributes Inspector de la celda escribimos un identificador para ella: <code>TableViewCell</code>. Esto servir\u00e1 m\u00e1s adelante para referenciarla desde el controlador de la tabla y as\u00ed poder utilizar las celdas desde este controlador:</p> <p></p> <p>Ya hemos dise\u00f1ado la vista de la celda. Ahora vamos a programar el c\u00f3digo de su controlador.</p>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#programando-la-celda","title":"Programando la celda","text":"<p>Tendremos que vincular a nuestra clase celda los Outlets que hemos creado antes en la vista. Para ello abrimos el fichero TableViewCell.swift y a\u00f1adimos las siguientes propiedades a la clase:</p> <pre><code>@IBOutlet weak var imagen: UIImageView!\n@IBOutlet weak var labelTitle: UILabel!\n@IBOutlet weak var labelAuthor: UILabel!\n</code></pre> <p>Alternativamente, se pueden crear los IBOutlets con el asistente (a veces es m\u00e1s c\u00f3modo). Pinchando sobre el s\u00edmbolo que representa una tabla con un + dentro de ella (arriba a la derecha), se abre una segunda ventana de edici\u00f3n. As\u00ed se puede seleccionar la vista en una de las ventanas, y el c\u00f3digo en otra. Despu\u00e9s, puedes pinchar (bot\u00f3n derecho) sobre el componente de la vista y arrastrarlo al c\u00f3digo de la declaraci\u00f3n de la clase. Esto crea autom\u00e1ticamente las propiedades, y genera los enlaces. El mismo procedimiento es v\u00e1lido tambi\u00e9n para crear un <code>IBAction</code>.</p> <p>Ahora volvemos a la vista de la celda en el storyboard y enlazamos los Outlets creados en la clase con los objetos de la vista.</p> <p>Una vez hecho esto abrimos de nuevo la clase controladora de la tabla <code>TableViewController.swift</code> y modificamos los siguientes m\u00e9todos:</p> <pre><code> override func numberOfSections(in tableView: UITableView) -&gt; Int {\n     return 1\n }\n\n override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {\n     return 3\n }\n\n override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {\n     let cell = tableView.dequeueReusableCell(withIdentifier: \"TableViewCell\", for: indexPath) as! TableViewCell\n\n     cell.labelTitle?.text = \"T\u00edtulo \\(indexPath.row+1)\"\n     cell.labelAuthor?.text = \"Autor\"\n     cell.imagen?.image = UIImage(named : \"logo-master.png\")\n\n     return cell\n }\n</code></pre> <p>Descarga la imagen logo_master.png y arr\u00e1strala dentro de XCode a los Assets del proyecto. </p> <p>En este momento ya podemos ejecutar la aplicaci\u00f3n y nos debe aparecer la tabla con las celdas que acabamos de programar. Si la ejecutamos en el mismo dispositivo que ten\u00edamos seleccionado en la barra inferior (sobre el cu\u00e1l hemos hecho el dise\u00f1o), nos saldr\u00e1n los elementos relativamente bien colocados. En cambio, si la ejecutamos con el simulador para otro dispositivo distinto, probablemente se nos descoloquen los elementos de la celda porque falta ajustar los constraints (de hecho se mostrar\u00e1 alg\u00fan warning por este motivo). De momento no te preocupes por esto, lo arreglaremos m\u00e1s adelante.</p>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#anadiendo-la-barra-de-navegacion","title":"A\u00f1adiendo la barra de navegaci\u00f3n","text":"<p>La aplicaci\u00f3n funciona se muestra una tabla, pero no tiene barra de navegaci\u00f3n. Normalmente todos los controladores en iOS suelen ir incrustados en controladores contenedores, que son los que gestionan la navegaci\u00f3n, como <code>UINavigationController</code>, <code>UITabBarController</code> o  <code>UISplitViewController</code>. </p> <p>Para nuestro ejercicio, lo m\u00e1s adecuado incrustrar la tabla en un <code>UINavigationController</code>, seleccionando el controlador de la tabla en el storyboard y eligiendo Editor &gt; Embed in &gt; Navigation Controller. A\u00f1ade un t\u00edtulo para la tabla mediante la siguiente l\u00ednea de c\u00f3digo en <code>viewDidLoad</code> de <code>TableViewController</code> (o si lo prefieres, desde el Interface Builder):</p> <pre><code>    self.title = \"Mi tabla personalizada\"\n</code></pre>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#personalizacion-con-efecto-zebra","title":"Personalizaci\u00f3n con efecto zebra","text":"<p>Una vez tenemos las celdas vamos a personalizar la tabla un poco m\u00e1s, a\u00f1adiendo un fondo a las celdas pares y otro a las impares, lo que se conoce como efecto zebra. Para esto necesitaremos dos im\u00e1genes m\u00e1s que se pueden descargar aqu\u00ed y a\u00f1adirlas a los Assets.</p> <p>Abrimos la vista de la celda en el storyboard y arrastramos un <code>UIImageView</code> ocupando todo el espacio de la celda. Es necesario enviar esta vista al fondo, con el men\u00fa Editor &gt; Arrange &gt; Send to back. Si en el modo visual se van descolocando las vistas de la celda cuando las mueves (aunque esto no deber\u00eda ocurrir con las \u00faltimas versiones de XCode), ajusta los tama\u00f1os desde el Size Inspector.</p> <p>En el fichero <code>TableViewCell.swift</code> enlazamos el nuevo <code>UIImageView</code>, como hemos hecho con el resto de elementos, y lo llamamos <code>fondo</code>.</p> <p>Ahora, en la clase <code>TableViewController</code>, dentro del m\u00e9todo <code>cellForRowAt</code> a\u00f1adimos lo siguiente justo antes de <code>return cell</code></p> <pre><code>if indexPath.row % 2 != 0 {\n    cell.fondo.image = UIImage(named:\"fondo_celda1.png\")\n}\nelse {\n    cell.fondo.image = UIImage(named:\"fondo_celda2.png\")\n}\n</code></pre> <p>Si ejecutamos ahora el proyecto tendremos nuestra tabla con las celdas personalizadas:</p> <p></p>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#ajuste-de-las-constraints","title":"Ajuste de las constraints","text":"<p>S\u00f3lo hay un problema: como hemos comentado anteriormente, se ha dise\u00f1ado la vista para un iPhone en concreto (iPhone 14 Pro por defecto), y si ejecutamos el simulador con otro iPhone (por ejemplo el SE) los elementos de la celda nos saldr\u00e1n descolocados. Para que salgan bien nos falta ajustar las constraints de la vista.</p> <p>Para esto, seleccionamos el <code>TableViewCell</code> desde el storyboard, y en la parte inferior (\"All Views in Table View Cell\") marcamos \"All Views in TableViewController\" -&gt; \"Reset to Suggested Constraints\". Probamos y vemos que la tabla es correcta, incluso rotando el dispositivo.</p> <p>Esta opci\u00f3n de Reset te puede sacar de m\u00e1s de un apuro cuando el ajustar el autolayout sea complicado. Recomiendo probar primero con ella, y si no funciona a la primera entonces ajustar las constraints a mano.</p> <p></p> <p>Si se te queda muy corta la imagen del fondo cuando rotas el dispositivo puedes seleccionar la opci\u00f3n \"Scale to Fill\" en el inspector de atributos:</p> <p></p>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#insertar-datos-en-la-tabla","title":"Insertar datos en la tabla","text":"<p>Para finalizar, extenderemos nuestro programa con las siguientes opciones:</p> <p>a) Vamos a rellenar las celdas de la tabla con datos de libros. Para ello, crearemos una nueva clase (con File &gt; New &gt; Swift file) a la que llamaremos <code>Libro</code>. Reemplaza en este fichero <code>import Foundation</code> por <code>import UIKit</code>, y crea la clase con un <code>String</code> que ser\u00e1 el t\u00edtulo del libro, otro <code>String</code> que ser\u00e1 el autor y una imagen (<code>UIImage</code>) que ser\u00e1 la portada. A\u00f1ade tambi\u00e9n un m\u00e9todo <code>init</code> para inicializar las variables de la clase.</p> <p>b) Ahora crearemos un array dentro de la clase <code>TableViewController</code>, lo inicializamos y lo completamos con los 3 libros que prefieras. Cada elemento del array ser\u00e1 de la clase <code>Libro</code>.</p> <p>c) Una vez creado el array de libros vamos a mostrarlos en nuestra tabla. Para ello deberemos modificar los m\u00e9todos de la clase <code>TableViewController</code>, asignando los datos del array a las celdas correspondientes.</p> <p>d) Cuando hayamos terminado, comprobamos que la aplicaci\u00f3n funciona seg\u00fan lo esperado.</p>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#ejercicio-2-personalizacion-de-toolbars","title":"Ejercicio 2- Personalizaci\u00f3n de ToolBars","text":"<p>Los ToolBars, al igual que la mayor parte de componentes, se pueden personalizar para conseguir las funcionalidades que deseemos para nuestras apps. En el siguiente ejemplo vamos a crear una vista ToolBar personalizada con una imagen de fondo, estilos para los botones, a\u00f1adiendo botones de distinto tipo, etc.</p> <p>Comenzamos creando un nuevo proyecto de tipo iOS &gt; App con el nombre  <code>ejercicio_toolbar</code> y con interfaz storyboard.</p>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#diseno-de-la-vista","title":"Dise\u00f1o de la vista","text":"<p>Abrimos la vista principal del storyboard, arrastramos un objeto <code>UIToolBar</code> y lo situamos en la parte superior. Tambi\u00e9n vamos a a\u00f1adir un objeto <code>UILabel</code> en el centro de la vista.</p> <p></p> <p>Ahora vamos a a\u00f1adir los elementos que deseemos sobre el ToolBar. En nuestro caso arrastraremos desde el listado de objetos (en el siguiente orden) un Text Field, un Flexible Space Bar y un Segmented Control. Borraremos el bot\u00f3n Item de la izquierda. El ToolBar debe quedar de la siguiente manera:</p> <p></p> <p>Como podemos observar, la funci\u00f3n del objeto Flexible Space no es m\u00e1s que a\u00f1adir un espacio flexible entre dos objetos dentro de un ToolBar o de una barra de navegaci\u00f3n. </p> <p>Una vez tenemos la barra con todos sus elementos, vamos a definir los elementos dentro de la clase. En el c\u00f3digo de la clase <code>ViewController</code> a\u00f1adimos los siguientes outlets:</p> <pre><code>@IBOutlet weak var toolBar: UIToolbar!\n@IBOutlet weak var textField: UITextField!\n@IBOutlet weak var segmentedControl: UISegmentedControl!\n\n// Para la etiqueta centrada en la vista\n@IBOutlet weak var segmentLabel: UILabel!\n</code></pre> <p>Seguidamente tenemos que enlazar los outlets dentro de la vista. Si ejecutamos el c\u00f3digo, es posible que el toolbar y el label salgan descolocados (o no salgan) cuando rotemos el dispositivo. </p>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#ajuste-de-las-constraints_1","title":"Ajuste de las constraints","text":"<p>Vamos a a\u00f1adir constraints desde XCode para fijar los m\u00e1rgenes. Selecciona el toolbar, y a\u00f1ade las siguientes constraints (arriba, izquierda, derecha) marcando Constrain to margins para que no se solape con la barra de estado:</p> <p></p> <p>Vamos a centrar ahora el label, a\u00f1adiendo restricciones de centrado horizontal y vertical:</p> <p></p> <p>Puedes ver los constraints a\u00f1adidos para cada elemento en el Size inspector. Por ejemplo, para el label tendr\u00edamos:</p> <p></p>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#acciones","title":"Acciones","text":"<p>Ahora vamos a implementar la acci\u00f3n del Segmented Control. Para ello declaramos el siguiente m\u00e9todo dentro de la clase <code>ViewController</code>:</p> <pre><code>@IBAction func segmentedControlIndexChanged(_ sender: Any) {\n          self.segmentLabel.text = self.segmentedControl.selectedSegmentIndex == 0 ? \"Segmento 1\" : \"Segmento 2\"\n}\n</code></pre> <p>Para que el m\u00e9todo se invoque cuando se pulsa un bot\u00f3n del Segmented Control, deberemos enlazarlo con la vista. </p> <p>En este momento ya podemos ejecutar el proyecto por primera vez y comprobar que al pulsar sobre uno de los botones del Segmented Control la etiqueta Label cambia.</p>"},{"location":"sesion-1-guias-de-estilo-y-personalizaciones-avanzadas.html#personalizacion-avanzada","title":"Personalizaci\u00f3n avanzada","text":"<p>Ya tenemos un objeto ToolBar con una personalizaci\u00f3n b\u00e1sica funcionando. Ahora vamos a cambiarlo un poco m\u00e1s: vamos a a\u00f1adirle una imagen de fondo, a asignar un color de fondo al Segmented Control y a modificar el dise\u00f1o del TextField. Para hacer todo esto debemos cambiar el m\u00e9todo <code>viewDidLoad</code> de la clase <code>ViewController</code> para que quede de la siguiente manera:</p> <pre><code>override func viewDidLoad() {\n    super.viewDidLoad()\n\n    // Vamos a a\u00f1adir la imagen de fondo como un imageView, pero esta vez sin usar el storyboard (por hacerlo distinto)\n    let iv = UIImageView(image:UIImage(named:\"fondo_madera.png\"))\n    iv.frame = CGRect(x:0, y:0, width:self.toolBar.frame.size.width, height:44)\n    iv.autoresizingMask = UIView.AutoresizingMask.flexibleWidth\n\n    // A\u00f1adimos la subview\n    self.toolBar.insertSubview(iv, at:0)\n\n    // Cambiamos el color del SegmentedControl\n    self.segmentedControl.tintColor=UIColor.brown\n\n    // Personalizamos el TextField desde c\u00f3digo (tambi\u00e9n se podr\u00eda hacer desde el Interface Builder)\n    self.textField.textColor = UIColor.white\n    self.textField.borderStyle = UITextField.BorderStyle.none\n    self.textField.background = UIImage(named:\"fondo_textfield.png\")\n    self.textField.placeholder = \"Escribe aqu\u00ed\"\n}\n</code></pre> <p>Para que el c\u00f3digo funcione debemos descargarnos las im\u00e1genes desde aqu\u00ed y a\u00f1adirlas a los Assets del proyecto. Una vez hecho esto ya podemos ejecutarlo y ver c\u00f3mo ha cambiado. De esta forma tendremos nuestro componente ToolBar bastante personalizado, d\u00e1ndole a la aplicaci\u00f3n un aspecto visual diferenciado.</p> <p></p> <p>La metodolog\u00eda que acabamos de seguir tambi\u00e9n sirve para personalizar los componentes <code>UITabBar</code> y <code>UINavigationBar</code>, entre otros.</p>"},{"location":"sesion-2-controladores-avanzados.html","title":"2- Controladores avanzados","text":"<p>En esta sesi\u00f3n veremos algunos controladores bastante comunes en aplicaciones iOS: el controlador paginado (<code>UIPageViewController</code>), las colecciones (<code>UICollectionViewController</code>) y el controlador de b\u00fasqueda para tablas (<code>UISearchController</code>).</p>"},{"location":"sesion-2-controladores-avanzados.html#ejercicio-1-uipageviewcontroller","title":"Ejercicio 1 - UIPageViewController","text":"<p>El controlador paginado (UIPageViewController) sirve para poder cambiar entre varias p\u00e1ginas en pantalla que contienen informaci\u00f3n similar. Es una clase bastante configurable, ya que permite modificar:</p> <ul> <li>La orientaci\u00f3n de las vistas de las p\u00e1ginas (horizontal o vertical).</li> <li>El estilo de transici\u00f3n (page-curl o scrolling).</li> <li>Para la transici\u00f3n page-curl, la localizaci\u00f3n del eje.</li> <li>Para la transici\u00f3n scrolling, el espacio entre p\u00e1ginas.</li> </ul> <p>La clase <code>UIPageViewController</code> se considera un controlador contenedor (Container Controller). Los controladores contenedores pueden usarse para almacenar y gestionar m\u00faltiples View Controllers, y cambiar de uno a otro cuando sea necesario. Otros ejemplos de controladores contenedores son <code>UINavigationController</code>, <code>UITabBarController</code> y <code>UISplitViewController</code>.</p> <p>Vamos a hacer una aplicaci\u00f3n de ejemplo para ver las posibilidades del controlador paginado y c\u00f3mo se programa. Nuestra app tendr\u00e1 4 p\u00e1ginas que contienen informaci\u00f3n de ayuda. Los controladores paginados se suelen usar frecuentemente para esto. El ejercicio quedar\u00e1 del siguiente modo cuando lo terminemos:</p> <p></p> <p>Para empezar crearemos un proyecto con la plantilla iOS &gt; App y  storyboard. Lo llamaremos <code>ejercicio_pageview</code>.</p>"},{"location":"sesion-2-controladores-avanzados.html#creacion-de-las-vistas","title":"Creaci\u00f3n de las vistas","text":"<p>Primero vamos a arrastrar un <code>UIPageViewController</code> al storyboard (fuera de la primera vista). Haremos lo mismo con otro <code>UIViewController</code> gen\u00e9rico, que es el que contendr\u00e1 la informaci\u00f3n de las 4 pantallas. Usaremos la misma vista para las 4 pantallas porque en realidad su estructura es la misma. El controlador inicial del storyboard que viene por defecto tambi\u00e9n vamos a usarlo para superponer sobre \u00e9l el controlador paginado como veremos m\u00e1s adelante.</p> <p>Tenemos que asignar un identificador del storyboard para las dos vistas que hemos creado, de modo que podamos referenciarlas posteriormente desde nuestro c\u00f3digo. Asigna el nombre <code>PageViewController</code> al controlador Page View Controller, y <code>PageContentViewController</code> al  View Controller.</p> <p></p> <p>En <code>PageViewController</code> verifica que el valor de transici\u00f3n es <code>Scroll</code> en lugar de <code>Page Curl</code>, ya que el segundo se suele utilizar para libros pero no quedar\u00eda bien en nuestra aplicaci\u00f3n.</p> <p></p>"},{"location":"sesion-2-controladores-avanzados.html#implementacion-de-la-vista-de-contenido-pagecontentviewcontroller","title":"Implementaci\u00f3n de la vista de contenido (PageContentViewController)","text":"<p>Vamos a dise\u00f1ar la vista de contenido (<code>PageContentViewController</code>), que deber\u00eda quedar como la siguiente:</p> <p></p> <p>Tendremos un <code>UILabel</code> arriba y una imagen detr\u00e1s que ocupa toda la pantalla excepto la barra de estado superior.</p> <p>Ahora tenemos la vista de contenido, pero nos har\u00e1 falta un controlador para cambiarla din\u00e1micamente. Crea un nuevo fichero con File &gt; New File &gt; Cocoa Touch Class, ll\u00e1malo <code>PageContentViewController</code> y hazlo subclase de <code>UIViewController</code>, dejando desmarcado Also create Xib.</p> <p>Volvemos al storyboard, nos situamos en el PageContentViewController y asignamos el controlador a la vista:</p> <p></p> <p>Enlazamos los outlets de la imagen y la etiqueta al controlador. Ll\u00e1malos del siguiente modo:</p> <pre><code>@IBOutlet weak var titulo: UILabel!\n@IBOutlet weak var imageView: UIImageView!\n</code></pre> <p>A\u00f1ade tambi\u00e9n los siguientes atributos:</p> <pre><code>var pageIndex = 0\nvar titleText = \"\"\nvar imageFilename = \"\"\n</code></pre> <p>La variable <code>pageIndex</code> almacenar\u00e1 el \u00edndice de la p\u00e1gina actual. Cambiamos tambi\u00e9n el m\u00e9todo <code>viewDidLoad</code> para actualizar la imagen de fondo y el texto:</p> <pre><code>self.imageView.image = UIImage(named: self.imageFilename)\nself.titulo.text = self.titleText\n</code></pre>"},{"location":"sesion-2-controladores-avanzados.html#implementacion-del-primer-controlador-viewcontroller","title":"Implementaci\u00f3n del primer controlador (ViewController)","text":"<p>Ya tenemos la vista del contenido. Ahora Vamos a modificar la primera vista del storyboard, a\u00f1adiendo un bot\u00f3n Start again, abajo y centrado:</p> <p></p> <p>Crearemos una acci\u00f3n de este bot\u00f3n con <code>ViewController</code>. A este m\u00e9todo lo  llamaremos <code>restart</code>.</p>"},{"location":"sesion-2-controladores-avanzados.html#implementacion-del-controlador-paginado-pageviewcontroller","title":"Implementaci\u00f3n del controlador paginado (PageViewController)","text":"<p>La estructura que sigue el controlador paginado es la siguiente:</p> <p></p> <p>Por tanto, nuestro controlador paginado gestionar\u00e1 cuatro controladores de la misma clase.</p> <p>Para usar <code>UIPageViewController</code> lo primero que tenemos que hacer es adoptar el protocolo <code>UIPageViewControllerDataSource</code>. El data source es el responsable de gestionar los controladores de las vistas de contenido cuando se le pidan, por lo que en los m\u00e9todos de este protocolo indicaremos qu\u00e9 contenido mostrar para cada p\u00e1gina.</p> <p>En este ejemplo usaremos la clase <code>ViewController</code> como  data source para la instancia de <code>UIPageViewController</code> que hemos creado. Por esto es necesario indicar que la clase <code>ViewController</code> implementa el protocolo <code>UIPageViewControllerDataSource</code>. Esta clase <code>ViewController</code> tambi\u00e9n ser\u00e1 la responsable de proporcionar los datos de las p\u00e1ginas (im\u00e1genes y t\u00edtulos).</p> <p>Abre el fichero <code>ViewController.swift</code> y a\u00f1ade el delegado y estas tres propiedades (el modelo de datos):</p> <pre><code>class ViewController: UIViewController, UIPageViewControllerDataSource, UIPageViewControllerDelegate {\n\n    let pageTitles = [\"Over 200 Tips and Tricks\", \"Discover Hidden Features\", \"Bookmark Favorite Tip\", \"Free Regular Update\"]\n    let pageImages = [\"page1.png\", \"page2.png\", \"page3.png\", \"page4.png\"]\n\n    var pageViewController : UIPageViewController?\n</code></pre> <p>Puedes descargar las im\u00e1genes que vamos a usar desde aqu\u00ed, y a\u00f1adirlas a los Assets del proyecto.</p> <p>Ya hemos creado el modelo de datos pero nos falta implementar los m\u00e9todos del protocolo <code>UIPageViewControllerDataSource</code>, que deben ser al menos estos dos:</p> <ul> <li><code>viewControllerAfterViewController</code>: Aqu\u00ed debemos indicar qu\u00e9 controlador mostrar en la siguiente p\u00e1gina.</li> <li><code>viewControllerBeforeViewController</code>: Aqu\u00ed debemos indicar qu\u00e9 controlador mostrar en la p\u00e1gina anterior.</li> </ul> <p>A\u00f1ade las siguientes l\u00edneas a  <code>ViewController.swift</code>:</p> <pre><code>func viewControllerAtIndex(index : Int) -&gt; PageContentViewController? {\n      if self.pageTitles.count == 0 || index &gt;= self.pageTitles.count {\n              return nil;\n      }\n\n      // Crear un nuevo controlador de contenido y pasar los datos\n      let pageContentViewController = self.storyboard?.instantiateViewController(withIdentifier: \"PageContentViewController\") as! PageContentViewController\n\n      pageContentViewController.imageFilename = self.pageImages[index];\n      pageContentViewController.titleText = self.pageTitles[index];\n      pageContentViewController.pageIndex = index;\n\n      return pageContentViewController;\n  }\n\n  func pageViewController(_ pageViewController: UIPageViewController, viewControllerBefore viewController: UIViewController) -&gt; UIViewController? {\n\n      let pvc = viewController as! PageContentViewController\n      var index = pvc.pageIndex;\n\n      if index == 0 || index == Foundation.NSNotFound {\n          return nil\n      }\n\n      index -= 1\n      return self.viewControllerAtIndex(index: index)\n  }\n\n  func pageViewController(_ pageViewController: UIPageViewController, viewControllerAfter viewController: UIViewController) -&gt; UIViewController? {\n\n      let pvc = viewController as! PageContentViewController\n      var index = pvc.pageIndex;\n\n      if index == Foundation.NSNotFound {\n          return nil\n      }\n\n      index += 1\n      if index == self.pageTitles.count {\n          return nil\n      }\n      return self.viewControllerAtIndex(index: index)\n  }\n</code></pre> <p>Como puedes ver, los m\u00e9todos delegados de <code>pageViewController</code> son muy sencillos. Simplemente miramos el \u00edndice actual, lo incrementamos o decrementamos en funci\u00f3n del m\u00e9todo y devolvemos el controlador a mostrar.</p> <p>El m\u00e9todo <code>viewControllerAtIndex</code> es el que muestra el controlador indicado. Para ello, como puede verse, usamos la siguiente instrucci\u00f3n:</p> <pre><code>let pageContentViewController = self.storyboard?.instantiateViewController(withIdentifier: \"PageContentViewController\") as! PageContentViewController\n</code></pre> <p>Recuerda que hab\u00edamos asignado un storyboardID a los controladores. Este identificador lo hemos usado como referencia para crear las nuevas instancias, ya que si te fijas, <code>PageContentViewController</code> est\u00e1 suelto en el storyboard.</p> <p>Ya lo tenemos casi. Para mostrar un indicador de p\u00e1gina, tenemos que indicar el n\u00famero de p\u00e1ginas (la cantidad de puntos a mostrar) y qu\u00e9 n\u00famero de p\u00e1gina se selecciona inicialmente. A\u00f1ade los siguientes m\u00e9todos al final de <code>ViewController.swift</code>:</p> <pre><code>func presentationCount(for pageViewController: UIPageViewController) -&gt; Int {\n    return self.pageTitles.count\n}\n\nfunc presentationIndex(for pageViewController: UIPageViewController) -&gt; Int {\n    return 0\n}\n</code></pre> <p>Si no se implementan estos m\u00e9todos no se mostrar\u00e1 el indicador de p\u00e1gina.</p> <p>Por \u00faltimo, vamos a crear el controlador paginado. Lo haremos en el m\u00e9todo <code>viewDidLoad</code> de <code>ViewController.swift</code>. C\u00e1mbialo por el siguiente:</p> <pre><code>override func viewDidLoad() {\n    super.viewDidLoad()\n\n    // Creamos el controlador paginado\n    self.pageViewController = self.storyboard?.instantiateViewController(withIdentifier: \"PageViewController\") as! UIPageViewController?\n    self.pageViewController?.dataSource = self\n    self.pageViewController?.delegate = self;\n\n    // Creamos el primer controlador de contenido\n    let startingViewController = self.viewControllerAtIndex(index: 0)\n    let viewControllers = [startingViewController!]\n\n    self.pageViewController?.setViewControllers(viewControllers, direction: UIPageViewController.NavigationDirection.forward, animated: false, completion: nil)\n\n    // Cambiamos el tama\u00f1o para que quepa el bot\u00f3n de abajo\n    self.pageViewController?.view.frame = CGRect(x: 0, y: 0, width: self.view.frame.size.width, height: self.view.frame.size.height-30)\n\n    // A\u00f1adimos el primer controlador de contenido\n    self.addChild(self.pageViewController!)\n    self.view.addSubview((self.pageViewController?.view)!)\n    self.pageViewController?.didMove(toParent: self)\n}\n</code></pre> <p>En este m\u00e9todo hemos creado una instancia de <code>PageViewController</code>. Despu\u00e9s especificamos el data source (la fuente de datos), que es la clase actual. Creamos el primer controlador de contenido, lo a\u00f1adimos a un array de controladores, y lo asignamos al controlador de la p\u00e1gina para mostrarlo.</p> <p>Compilamos y ejecutamos. Deber\u00eda funcionar, pero la vista sale descolocada debido a que falta ajustar las constraints. Para arreglarlo, seleccionamos el <code>PageContentViewController</code> en el storyboard y marcamos Reset to suggested constraints. Ejecutamos de nuevo y podemos ver que el contenido ya se muestra bien, aunque todav\u00eda falta el bot\u00f3n de abajo. Seleccionamos nuestro <code>ViewController</code> y marcamos de nuevo Reset to suggested constraints. Ahora s\u00ed que vemos el bot\u00f3n. Lo \u00fanico que nos falta son los puntos de abajo, que est\u00e1n ah\u00ed pero que no se ven porque son del mismo color que el fondo. Vamos a cambiarles el color.</p> <p>Abre el fichero <code>AppDelegate.swift</code>, y a\u00f1ade las siguientes l\u00edneas en <code>didFinishLaunchingWithOptions</code>:</p> <pre><code>let pageControl = UIPageControl.appearance()\npageControl.pageIndicatorTintColor = UIColor.lightGray\npageControl.currentPageIndicatorTintColor = UIColor.black\npageControl.backgroundColor = UIColor.white\n</code></pre> <p>Si el bot\u00f3n de Start again se te queda debajo de los puntos, b\u00e1jalo un poco en la vista, resetea de nuevo las constraints y recompila.</p> <p>S\u00f3lo nos falta la implementaci\u00f3n de este bot\u00f3n para volver a la primera p\u00e1gina. El m\u00e9todo <code>restart</code> en <code>ViewController.swift</code> deber\u00eda quedar de la siguiente manera:</p> <p><pre><code>@IBAction func restart(_ sender: AnyObject) {    \n    let startingViewController = self.viewControllerAtIndex(index: 0)\n    let viewControllers = [startingViewController!]\n    self.pageViewController?.setViewControllers(viewControllers, direction: UIPageViewController.NavigationDirection.reverse, animated: false, completion: nil)\n}\n</code></pre> Si ejecutamos de nuevo la aplicaci\u00f3n veremos que el bot\u00f3n ya funciona.</p> <p>En este ejercicio hemos hecho la parte b\u00e1sica para usar un <code>UIPageViewController</code> con storyboards. Se ha implementado la transici\u00f3n en scroll, pero este controlador es muy configurable y como hemos visto podemos  usarlo tambi\u00e9n para implementar una app con navegaci\u00f3n de tipo libro.</p>"},{"location":"sesion-2-controladores-avanzados.html#ejercicio-2-uicollectionviewcontroller","title":"Ejercicio 2 - UICollectionViewController","text":"<p>Las colecciones pueden usarse como alternativa a las tablas cuando tenemos una distribuci\u00f3n de los elementos de tipo rejilla (grid), por ejemplo.</p> <p> </p> <p>Para implementar una colecci\u00f3n es necesario indicar el n\u00famero de secciones, el tama\u00f1o de las celdas, y especificar los contenidos de cada celda. El controlador de la colecci\u00f3n autom\u00e1ticamente reorganizar\u00e1 las posiciones de las celdas en funci\u00f3n de su tama\u00f1o y del tama\u00f1o de la pantalla.</p>"},{"location":"sesion-2-controladores-avanzados.html#ejemplo-uicollectionviewcontroller","title":"Ejemplo UICollectionViewController","text":"<p>Vamos a implementar un ejercicio sencillo para ver c\u00f3mo funciona <code>UICollectionViewController</code>. </p> <p>Creamos un proyecto llamado <code>ejercicio_collection</code>, de tipo iOS &gt; App con storyboard. Arrastramos al storyboard (fuera de la vista inicial) un nuevo <code>UICollectionViewController</code>, y movemos en el storyboard la flecha que apunta al controlador inicial para que ahora sea nuestro <code>UICollectionViewController</code>. Borramos el fichero <code>ViewController.swift</code> y tambi\u00e9n su controlador del storyboard, ya que no los necesitaremos. </p> <p>Creamos un nuevo controlador con New &gt; File &gt; Cocoa Touch. Lo llamaremos <code>CollectionViewController</code>, subclase de <code>UICollectionViewController</code>, dejando desmarcado Also create Xib. En el storyboard seleccionamos nuestra vista e indicamos cu\u00e1l va a ser el controlador:</p> <p></p>"},{"location":"sesion-2-controladores-avanzados.html#creacion-de-las-celdas","title":"Creaci\u00f3n de las celdas","text":"<p>En la vista de <code>UICollectionViewController</code> veremos un rect\u00e1ngulo en la parte superior izquierda, que se corresponde con una celda. Vamos a crear una clase propia para las celdas, de forma que podamos configurarlas para darles el aspecto que queramos. El procedimiento es similar al que hicimos para las celdas personalizadas.</p> <p>Creamos una nueva clase llamada <code>CollectionViewCell</code>, subclase de <code>UICollectionViewCell</code>, y desmarcando Also create XIB.</p> <p>En el storyboard seleccionamos la celda que hay dentro de nuestro controlador de colecciones, y cambiamos la clase <code>UICollectionViewCell</code> por la que hemos creado, <code>CollectionViewCell</code>.</p> <p></p> <p>En la pesta\u00f1a de Attributes Inspector escribimos el identificador idCelda para nuestras celdas.</p> <p></p> <p>Seleccionamos el objeto Collection View en el storyboard, y en el Size inspector cambiamos el tama\u00f1o de las celdas (Cell Size) a 100 x 100 puntos.</p> <p></p> <p>Como puede verse, hay m\u00e1s atributos que podr\u00edamos cambiar, como el tama\u00f1o de la cabecera y pie, el espaciado entre celdas, o los insets, que se pueden usar para crear bordes alrededor de las celdas.</p> <p>Tambi\u00e9n tenemos que cambiar el tama\u00f1o de la celda, seleccionando en el storyBoard nuestro idCelda:</p> <p></p> <p>En este ejercicio configuraremos las celdas para que muestren una imagen. Para ello, desde el Interface Builder arrastramos un <code>UIImageView</code> a la celda, de forma que ocupe todo su tama\u00f1o. Ahora creamos un outlet de la imagen en nuestra celda personalizada y lo llamamos <code>imageView</code>.</p> <p></p> <p>Ya tenemos la vista preparada, s\u00f3lo falta a\u00f1adir los datos.</p>"},{"location":"sesion-2-controladores-avanzados.html#configurar-los-datos","title":"Configurar los datos","text":"<p>Nos queda configurar el data source, es decir, implementar los m\u00e9todos delegados de <code>UICollectionViewDataSource</code> para mostrar los datos de las celdas. Abre el fichero <code>CollectionViewController.swift</code> y mira los m\u00e9todos de la secci\u00f3n <code>UICollectionViewDataSource</code>. Como puede verse, nuestra clase debe implementar:</p> <ul> <li><code>numberOfSections</code>. Como en una tabla, debemos indicar el n\u00famero de secciones. Este m\u00e9todo es opcional, y si no lo implementamos se asumir\u00e1 una s\u00f3la secci\u00f3n.</li> <li><code>numberOfItemsInSection</code>. Aqu\u00ed indicaremos la cantidad de items (celdas) para cada secci\u00f3n.</li> <li><code>cellForItemAt</code>: Como en una tabla, en este m\u00e9todo indicaremos el contenido de cada celda.</li> </ul> <p>Nota: Si quieres m\u00e1s informaci\u00f3n sobre los m\u00e9todos de un protocolo o de cualquier clase Cocoa, en la vista de c\u00f3digo de XCode puedes pinchar sobre el nombre del mismo con Option+click para ver la ayuda r\u00e1pida, o con Command+click para ver m\u00e1s opciones. </p> <p>Vamos a crear los datos de nuestra aplicaci\u00f3n. Descarga este fichero con im\u00e1genes, y a\u00f1\u00e1delas todas al proyecto. Declaramos un array en CollectionViewController para almacenarlas:</p> <pre><code>var foodImages = [String]()\n</code></pre> <p>Inicializamos el array al final del m\u00e9todo <code>viewDidLoad</code> de <code>CollectionViewController</code>.</p> <pre><code>for i in 1..&lt;17 {\n    let image = \"\\(i).jpg\"\n    self.foodImages.append(image)\n}\n</code></pre> <p>Nota: En un bucle for lo normal es usar fast enumeration, pero en casos como este (cuando tenemos rangos) podemos usar valores num\u00e9ricos.</p> <p>Modificamos los m\u00e9todos delegados desde <code>CollectionViewController</code>:</p> <pre><code>override func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int {\n    return self.foodImages.count\n}\n\noverride func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell {\n    let cell = collectionView.dequeueReusableCell(withReuseIdentifier: \"idCelda\", for: indexPath) as! CollectionViewCell\n\n    // Configure the cell\n    if let image = UIImage(named:self.foodImages[indexPath.row]) {\n        cell.imageView.image = image\n    }\n    return cell\n}\n</code></pre> <p>Podemos comentar el m\u00e9todo <code>numberOfSections</code>, ya que su implementaci\u00f3n es opcional.</p> <p>Si ejecutamos la aplicaci\u00f3n en el simulador veremos algo como esto:</p> <p></p> <p>Y en landscape puede verse c\u00f3mo se adapta:</p> <p></p> <p>Evidentemente, no queda muy bien que las im\u00e1genes est\u00e9n tan pegadas a los bordes. Vamos a cambiar esto con los insets, desde las propiedades de la colecci\u00f3n:</p> <p></p> <p>Como puedes ver, ahora queda algo mejor. Desde c\u00f3digo tambi\u00e9n podemos jugar con los tama\u00f1os de los bordes cambiando los atributos del controlador en funci\u00f3n del dispositivo, pero para este ejemplo no es necesario. Adem\u00e1s podr\u00edamos hacer que cuando se pulse una imagen se mostrara una vista de la misma a pantalla completa, aunque esto tampoco lo implementaremos en este ejercicio.</p>"},{"location":"sesion-2-controladores-avanzados.html#ejercicio-3-controlador-de-busqueda","title":"Ejercicio 3 - Controlador de b\u00fasqueda","text":"<p>En las aplicaciones iOS es com\u00fan encontrar una barra de b\u00fasqueda asociada a una tabla en la que se muestran los resultados. Hasta iOS7 esto se impleentaba con la clase <code>UISearchDisplayController</code>. Este controlador era bastante complejo, por lo que Apple decidi\u00f3 remplazarlo por <code>UISearchController</code>. Vamos a ver c\u00f3mo se implementa este \u00faltimo, ya que es bastante m\u00e1s sencillo, aunque aun as\u00ed no es trivial.</p>"},{"location":"sesion-2-controladores-avanzados.html#creacion-de-la-tabla","title":"Creaci\u00f3n de la tabla","text":"<p>Crea un proyecto llamado <code>ejercicio_search</code> usando la plantilla iOS &gt; App. Para empezar vamos a a\u00f1adir al storyboard un nuevo controlador de tipo <code>Table View Controller</code>.</p> <p>Hacemos que nuestra tabla sea lo primero que aparezca cuando se lance la app arrastrando la flecha horizontal que apunta al primer controlador (la vista vac\u00eda) hacia nuestro nuevo Table View Controller. Ya podemos borrar esta vista vac\u00eda del storyboard y tambi\u00e9n borramos el fichero <code>ViewController.swift</code> asociado a la vista que hemos eliminado.</p> <p>Ya hemos creado la vista de la tabla, pero vamos a usar tambi\u00e9n un fichero de c\u00f3digo como controlador para poder programar los elementos de la celda. Seleccionamos File &gt; New &gt; File &gt; Cocoa Touch Class, y le damos el nombre <code>TableViewController</code>, subclase de <code>UITableViewController</code>, dejando sin marcar Also create XIB file. </p> <p>A continuaci\u00f3n asignamos la vista al controlador. Para esto seleccionamos el controlador en el storyboard, y desde el Identity Inspector le asignamos la clase que hemos creado <code>TableViewController</code>, como se muestra en la imagen:</p> <p></p> <p>Tambi\u00e9n embebemos el controlador en una barra de navegaci\u00f3n, seleccion\u00e1ndolo en el storyboard e indicando desde el men\u00fa de XCode Editor &gt; Embed in &gt; Navigation Controller. Para ponerle un t\u00edtulo, a\u00f1adimos el siguiente c\u00f3digo en el m\u00e9todo <code>viewDidLoad</code> de <code>TableViewController</code>:</p> <pre><code>self.title = \"B\u00fasqueda\"\n</code></pre> <p>Ahora vamos a a\u00f1adir unos datos de ejemplo a la clase <code>TableViewController</code>:</p> <pre><code>let contenido = [\"En\",\"un\",\"lugar\",\"de\",\"la\",\"mancha\"]\n</code></pre> <p>Y completamos el c\u00f3digo de de esta clase para gestionar la tabla:</p> <pre><code>   override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {\n        // #warning Incomplete implementation, return the number of rows\n        return contenido.count\n    }\n\n\n    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {\n        let cell = tableView.dequeueReusableCell(withIdentifier: \"Cell\", for: indexPath)\n\n        // Configure the cell...\n        let c = contenido[indexPath.row]\n        cell.textLabel!.text = c\n\n        return cell\n    }\n</code></pre> <p>Por \u00faltimo, debemos enlazar la celda a nuestro controlador, indicando el nombre <code>Cell</code> que le hemos dado en el c\u00f3digo:</p> <p></p> <p>En este momento ya podemos ejecutar el c\u00f3digo y tendremos una tabla funcional, aunque sin la barra de b\u00fasqueda:</p> <p> </p>"},{"location":"sesion-2-controladores-avanzados.html#implementacion-del-controlador-de-busqueda","title":"Implementaci\u00f3n del controlador de b\u00fasqueda","text":"<p>Como se ha mencionado anteriormente, el controlador de b\u00fasqueda ha ido evolucionando con las distintas versiones de XCode.</p> <p>Antes de iOS7, se implementaba arrastrando un objeto de tipo Search Bar and Search Display Controller al principio de la tabla desde el Interface Builder. La gesti\u00f3n de esto era bastante complicada, ya que ten\u00edamos varias conexiones que deb\u00edamos gestionar manualmente.</p> <p>Ahora, Search Display Controller es un controlador deprecated (obsoleto), y Apple recomienda usar la clase UISearchController introducida en iOS7. Parad\u00f3jicamente, esta clase no est\u00e1 en el Interface Builder, y s\u00f3lo podemos usarla mediante c\u00f3digo, pero se simplifica bastante el procedimiento. Es as\u00ed como vamos a hacerlo en nuestro ejemplo.</p> <p>Para esto, primero debemos crear nuestro <code>searchController</code> y un array <code>searchResults</code> que contendr\u00e1 los resultados filtrados de la b\u00fasqueda. Al principio de la clase <code>TableViewController</code> declaramos las siguientes variables privadas (ya que no hace falta acceder a ellas desde fuera del controlador):</p> <pre><code>private var searchController : UISearchController?\nprivate var searchResults = [String]()\n</code></pre> <p>En el m\u00e9todo <code>viewDidLoad</code> de <code>TableViewController</code> creamos la barra de b\u00fasqueda y la inicializamos. A\u00f1adimos lo siguiente al final del m\u00e9todo:</p> <pre><code>// Creamos una tabla alternativa para visualizar los resultados cuando se seleccione la b\u00fasqueda\nlet searchResultsController = UITableViewController(style: .plain)\nsearchResultsController.tableView.dataSource = self\nsearchResultsController.tableView.delegate = self\n\n// Asignamos esta tabla a nuestro controlador de b\u00fasqueda\nself.searchController = UISearchController(searchResultsController: searchResultsController)\nself.searchController?.searchResultsUpdater = self        \n\n// Especificamos el tama\u00f1o de la barra de b\u00fasqueda\nif let frame = self.searchController?.searchBar.frame {\n    self.searchController?.searchBar.frame = CGRect(x: frame.origin.x, y: frame.origin.y, width: frame.size.width, height: 44.0)\n}\n\n// La a\u00f1adimos a la cabecera de la tabla\nself.tableView.tableHeaderView = self.searchController?.searchBar\n\n// Esto es para indicar que nuestra vista de tabla de b\u00fasqueda se superpondr\u00e1 a la ya existente\nself.definesPresentationContext = true\n</code></pre> <p>Ahora tendremos que cambiar los m\u00e9todos <code>numberOfRowsInSection</code> y <code>cellForRowAtIndexPath</code>. Esto lo haremos porque en funci\u00f3n de si est\u00e1 o no activa la barra de b\u00fasqueda tendremos que mostrar una informaci\u00f3n u otra. Si la vista de la tabla es la del controlador de b\u00fasqueda, tendremos que usar los elementos de la lista filtrada. En caso contrario, los de la lista principal.</p> <pre><code>override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {\n    let src = self.searchController?.searchResultsController as! UITableViewController\n\n    if tableView == src.tableView {\n        return self.searchResults.count\n    }\n    else {\n        return self.contenido.count\n    }\n}\n\noverride func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {\n    let cell = tableView.dequeueReusableCell(withIdentifier: \"Cell\", for: indexPath)\n\n    let src = self.searchController?.searchResultsController as! UITableViewController\n    let object : String?\n\n    if tableView == src.tableView {\n        object = self.searchResults[indexPath.row]\n    }\n    else {\n        object = contenido[indexPath.row]\n    }\n\n    cell.textLabel!.text = object\n    return cell\n}\n</code></pre> <p>A\u00f1ade el protocolo de la barra de b\u00fasqueda a la clase <code>TableViewController</code>. Este protocolo se llama  <code>UISearchResultsUpdating</code>. A continuaci\u00f3n tenemos que crear el m\u00e9todo delegado para actualizar los datos de la tabla cuando el usuario modifique el texto de b\u00fasqueda. A\u00f1ade el siguiente c\u00f3digo:</p> <pre><code>func updateSearchResults(for searchController: UISearchController) {\n    // Cogemos el texto introducido en la barra de b\u00fasqueda\n    let searchString = self.searchController?.searchBar.text\n\n\n    // Si la cadena de b\u00fasqueda es vac\u00eda, copiamos en searchResults todos los objetos\n    if searchString == nil || searchString == \"\" {\n        self.searchResults = self.contenido\n    }\n    // Si no, copiamos en searchResults s\u00f3lo los que coinciden con el texto de b\u00fasqueda\n    else {\n        let searchPredicate = NSPredicate(format: \"SELF BEGINSWITH[c] %@\", searchString!)\n        let array = (self.contenido as NSArray).filtered(using: searchPredicate)\n        self.searchResults = array as! [String]\n    }\n\n    // Recargamos los datos de la tabla\n    let tvc = self.searchController?.searchResultsController as! UITableViewController\n    tvc.tableView.reloadData()\n\n    // Deseleccionamos la celda de la tabla principal\n    if let selected = tableView.indexPathForSelectedRow {\n        tableView.deselectRow(at:selected, animated: false)\n    }\n}\n</code></pre> <p>Si ejecutamos el programa veremos que casi lo tenemos listo. Pero el (peque\u00f1o) problema es que cuando se pulse sobre la barra de b\u00fasqueda la app fallar\u00e1.</p> <p>Para arreglar este error debemos asignar el prototipo de la celda del storyboard. En <code>CellForRowAt IndexPath</code> sustituye la siguiente l\u00ednea:</p> <p><pre><code>let cell = tableView.dequeueReusableCell(withIdentifier: \"Cell\", for: indexPath)\n</code></pre> Por esta otra:</p> <pre><code>let cell = self.tableView.dequeueReusableCell(withIdentifier: \"Cell\", for: indexPath)\n</code></pre> <p>Si ejecutas de nuevo el programa ver\u00e1s como la barra de b\u00fasqueda ahora funciona (aparece un teclado y es funcional). Sin embargo, si queremos leer o usar el valor que el usuario ha introducido  todav\u00eda tenemos que a\u00f1adir lo siguiente:</p> <pre><code>override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n    let object : String\n\n    if let indexPath = self.tableView.indexPathForSelectedRow {\n        object = self.contenido[indexPath.row]\n    }\n    else {\n        let sc = self.searchController?.searchResultsController as! UITableViewController\n        object = self.searchResults[(sc.tableView.indexPathForSelectedRow?.row)!]\n    }\n    print (object)\n}\n</code></pre> <p>Como puede verse, este m\u00e9todo asigna una fuente de datos u otra dependiendo de si la barra de b\u00fasqueda est\u00e1 seleccionada o no.</p> <p></p> <p>Esto es lo b\u00e1sico para crear una barra de b\u00fasqueda asociada a una tabla. Como puedes ver, el dise\u00f1o podr\u00eda ser m\u00e1s sencillo pero tampoco es es demasiado complicado, sobre todo si lo comparamos con c\u00f3mo se hac\u00eda antes de iOS7.</p>"},{"location":"sesion-3-apps-universales.html","title":"3- Aplicaciones universales","text":"<p>En esta primera parte empezaremos explicando c\u00f3mo programar una app universal cuya interfaz se adapte a modelos y tama\u00f1os diferentes de iPhone y iPad teniendo en cuenta si las vistas son compactas o regulares. A continuaci\u00f3n haremos un ejercicio usando el componente Split View y adaptando las vistas a distintos dispositivos. </p>"},{"location":"sesion-3-apps-universales.html#diseno-de-apps-universales-en-xcode","title":"Dise\u00f1o de apps universales en XCode","text":"<p>En este apartado veremos qu\u00e9 son las aplicaciones universales, qu\u00e9 ventajas e inconvenientes podemos encontrar a la hora de dise\u00f1arlas, c\u00f3mo programarlas, y las recomendaciones de Apple para adaptar las vistas. </p>"},{"location":"sesion-3-apps-universales.html#introduccion","title":"Introducci\u00f3n","text":"<p>Normalmente se usa el t\u00e9rmino universal para denominar a todas aquellas aplicaciones adaptadas tanto al iPad como al iPhone. Los usuarios agradecen este tipo de aplicaciones ya que pueden usarlas en todos sus dispositivos. Adem\u00e1s, cuanto m\u00e1s dispositivos compatibles tengamos m\u00e1s clientes potenciales podremos captar.</p> <p>El desarrollo de una aplicaci\u00f3n universal ahorra tiempo   respecto a implementar apps independientes para cada dispositivo, ya que evidentemente programaremos el c\u00f3digo en un s\u00f3lo proyecto en lugar de varios. Tambi\u00e9n tiene ventajas para las actualizaciones, ya que tendremos que preocuparnos de implementar los cambios s\u00f3lo en una aplicaci\u00f3n.</p>"},{"location":"sesion-3-apps-universales.html#disenando-la-interfaz-de-una-aplicacion-universal","title":"Dise\u00f1ando la interfaz de una aplicaci\u00f3n universal","text":"<p>El primer paso para hacer una aplicaci\u00f3n universal es tener en cuenta el dise\u00f1o del interfaz para cada una de las vistas. En versiones anteriores de iOS se separaban las vistas de iPhone de las de iPad usando distintos ficheros .xib. Actualmente se debe hacer de forma conjunta usando los storyboards y autolayout en el caso de <code>UIKit</code> (que es la que estamos viendo en la asignatura), o bien directamente mediante <code>SwiftUI</code> en las \u00faltimas versiones.</p> <p>Estos son algunos de los aspectos principales que debemos tener en cuenta para dise\u00f1ar una interfaz universal:</p> <ul> <li>Orientaci\u00f3n. Con la informaci\u00f3n sobre la orientaci\u00f3n del dispositivo podremos adaptar la interfaz para acomodarla al mismo.  </li> <li>Estructura de las vistas. La pantalla del iPad es m\u00e1s grande que la del iPhone, permitiendo al usuario acceder a m\u00e1s informaci\u00f3n en pantalla.</li> <li>Comportamiento de las API. Componentes como los <code>UIPopover</code>, por ejemplo, se comportan de forma distinta en un iPhone y en un iPad.</li> <li>Caracter\u00edsticas Hardware. Los dispositivos iOS pueden tener distintas funcionalidades hardware, como el n\u00famero de c\u00e1maras, la capacidad de gestionar dynamic islands, soporte para Pencil, etc., que hay que tener en cuenta cuando se implementa una aplicaci\u00f3n universal.</li> <li>Gestos. En la pantalla del iPad a veces podemos realizar m\u00e1s gestos que en la del iPhone debido a su tama\u00f1o. Por ejemplo, se pueden usar cuatro dedos al mismo tiempo.</li> <li>Arte. Hay que tener en cuenta la resoluci\u00f3n de los distintos dispositivos, almacenando las im\u00e1genes en los Assets usando  varias resoluciones. Una alternativa recomendada por Apple es usar archivos PDF en los Assets. </li> </ul> <p>Como acabamos de ver, para programar una aplicaci\u00f3n universal en iOS debemos tener en cuenta las caracter\u00edsticas del dispositivo. Para esto podemos usar c\u00f3digo condicional. Por ejemplo, podemos detectar en cualquier momento si estamos ejecutando nuestra app con un iPhone o un iPad con la instrucci\u00f3n <code>UIDevice.currentDevice().userInterfaceIdiom</code> o su modelo con <code>UIDevice.currentDevice().model</code>.</p>"},{"location":"sesion-3-apps-universales.html#programando-una-aplicacion-universal","title":"Programando una aplicaci\u00f3n universal","text":"<p>Vamos a implementar un ejemplo de app universal paso a paso.</p> <p>Comenzamos abriendo XCode y creando un nuevo proyecto de tipo <code>iOS &gt; App</code> al que llamaremos <code>ejercicio_peliculas</code> Abrimos la vista principal del storyboard. </p> <ul> <li>Arrastra un <code>UILabel</code> a la vista principal del storyboard y su\u00e9ltala por el centro de la vista.</li> <li>Podemos ver c\u00f3mo quedar\u00eda en distintos dispositivos sin llegar a ejecutar el simulador. En el storyboard pincha en la parte inferior, donde aparece el modelo (por ejemplo, iPhone14) y elige otro modelo, por ejemplo un iPad. </li> <li>La etiqueta se desplazar\u00e1 a otro lugar. Si rotamos el dispositivo (en la parte inferior, con el icono de un cuadrado que tiene encima una flecha), es posible que hasta desaparezca de la pantalla. </li> <li>Ajusta las opciones de autolayout para la etiqueta. Si no controlas todav\u00eda autolayout, puedes seleccionar el tri\u00e1ngulo de la parte inferior  (Resolve autolayout issues) y elegir Reset to suggested constraints.</li> <li>Si mueves el <code>UILabel</code> a otra posici\u00f3n, ver\u00e1s que las l\u00edneas azules de gu\u00eda aparecen ahora de color naranja. Esto es porque todav\u00eda tenemos las constraints anteriores y son inconsistentes con la nueva posici\u00f3n. Para actualizar la vista pincha de nuevo en el tri\u00e1ngulo y selecciona Update constraint constants.</li> </ul> <p>Puedes ampliar o reducir los previews haciendo zoom con los dedos en el trackpad, o usando los controles de la parte inferior.</p> <p>En principio es sencillo, aunque a veces es complicado saber c\u00f3mo ajustar las constraints y manejar autolayout. Las opciones de autolayout pueden parecer f\u00e1ciles de interpretar, pero a la hora de la verdad no es f\u00e1cil dejar una vista como queremos.</p>"},{"location":"sesion-3-apps-universales.html#vistas-dependientes-del-dispositivo","title":"Vistas dependientes del dispositivo","text":"<p>A veces interesa tener vistas diferentes para distintos tama\u00f1os para aprovechar mejor la pantalla. Como se ha mencionado anteriormente, se recomienda usar interfaces diferenciados, ya que simplemente escalar el tama\u00f1o de los componentes para pantallas m\u00e1s grandes no suele quedar bien.</p> <p>Para el dise\u00f1o del interfaz, en lugar de distinguir entre iPhone e iPad, Apple introdujo en XCode 7 el concepto de size clases. La idea es que el desarrollador piense el dise\u00f1o s\u00f3lo para dos tama\u00f1os:</p> <ul> <li>Compact: Cuando tenemos un tama\u00f1o Compact debemos hacer un interfaz m\u00ednimo que muestre s\u00f3lo la informaci\u00f3n m\u00e1s relevante de forma compacta.</li> <li>Regular: En un tama\u00f1o Regular podemos a\u00f1adir m\u00e1s elementos y hacer un interfaz completo, ya que dispondremos de m\u00e1s espacio en la pantalla.</li> </ul> <p>Adem\u00e1s, estos tama\u00f1os pueden venir dados para la anchura (Width) o la altura (Height). Por tanto, debemos tener en cuenta tres factores:</p> <ul> <li>Dispositivo. iPhone o iPad.</li> <li>Orientaci\u00f3n. Horizontal o vertical.</li> <li>Tama\u00f1o. Compacto o regular.</li> </ul> <p>B\u00e1sicamente (aunque en realidad es algo m\u00e1s complicado), los dispositivos de Apple tienen los siguientes tama\u00f1os:</p> <p></p> <p>En la imagen, el iPhone que se ve en arriba en el centro es un iPhone 6s plus. Los modelos m\u00e1s grandes de iPhone tienen un tama\u00f1o regular cuando el m\u00f3vil est\u00e1 apaisado. </p> <p>Puedes ver un listado completo de los tama\u00f1os al final de este enlace.</p> <p></p> <p>En realidad es m\u00e1s complicado porque hay que tener en cuenta que no debemos asumir que los tama\u00f1os de vista son siempre constantes, ya que por ejemplo nuestra app en un iPad podr\u00eda mostrarse en una zona compacta de la pantalla en lugar de usar la pantalla completa. Por tanto, siempre debemos dise\u00f1ar todas las vistas tanto en modo compacto como regular. </p> <p>En la ventana inferior de XCode podemos cambiar el tipo de dispositivo, su orientaci\u00f3n, y en el caso del iPad, su adaptaci\u00f3n. Independientemente de lo que seleccionemos, los cambios que hagamos aqu\u00ed sobre la vista se aplicar\u00e1n a todos los tama\u00f1os.</p> <p>Es posible mostrar un componente (por ejemplo, un bot\u00f3n o una etiqueta) s\u00f3lo para un tama\u00f1o determinado. Para esto, puedes seleccionarlo y pinchar en el s\u00edmbolo <code>+</code> que aparece junto a <code>Installed</code> en las propiedades del  componente. </p> <p></p> <p>Si por ejemplo elegimos width Compact y height Regular (<code>wC hR</code>) y desmarcamos <code>Installed</code>, la etiqueta desaparecer\u00e1 para estos tama\u00f1os (pru\u00e9balo y ver\u00e1s que desaparece en un iPhone SE). </p> <p>Tambi\u00e9n se pueden cambiar las propiedades de los componentes en funci\u00f3n del tama\u00f1o actual. Por ejemplo: </p> <ul> <li>Selecciona en la barra de abajo un iPhone SE (1st generation) en orientaci\u00f3n apaisada (en este caso es <code>wC-hC</code>).</li> <li>Pulsa sobre el bot\u00f3n <code>+</code> a la izquierda de la propiedad Font de la etiqueta, en el Attributes Inspector, y luego en Add variation, dejando width=Compact y height=Compact.</li> <li>F\u00edjate en que aparece una nueva columna en la tabla de propiedades. Puedes cambiar la fuente a 15 puntos, y esto s\u00f3lo se aplicar\u00e1 en los dispositivos <code>wC-hC</code>.</li> <li>Como puedes ver, muchas propiedades tienen el bot\u00f3n <code>+</code> para hacer cambios s\u00f3lo con ciertos tama\u00f1os. Si quieres eliminar la configuraci\u00f3n de una propiedad, puedes pulsar sobre el bot\u00f3n <code>x</code> que aparece a su lado.</li> </ul>"},{"location":"sesion-3-apps-universales.html#split-view","title":"Split View","text":"<p>Un Split View o Vista Divida es una combinaci\u00f3n de dos vistas, una maestra y una detalle.</p> <p>En modo horizontal (landscape), la primera vista (maestra) es equivalente en anchura a una vista de iPhone en orientaci\u00f3n vertical. La vista maestra se suele usar para la navegaci\u00f3n principal dentro de un listado de opciones de la aplicaci\u00f3n. </p> <p>Por otro lado, la vista de la derecha (detalle), que corresponde a la porci\u00f3n m\u00e1s grande de la pantalla, mostrar\u00e1 la informaci\u00f3n en detalle del elemento que hayamos seleccionado en la vista de maestra. </p> <p></p> <p>Por defecto, en modo vertical (portrait mode) un Split View cambia y puede verse como la vista detalle con un icono que muestra la vista maestra. Por tanto, s\u00f3lo una de las vistas ocupar\u00e1 toda la pantalla de un iPad, como podemos ver en la siguiente imagen:</p> <p></p> <ul> <li>Es muy recomendable que los Split View Controllers  sean s\u00f3lo root controllers, por lo que s\u00f3lo debemos usarlos en la primera pantalla.</li> <li>No podemos a\u00f1adir un Split View Controller dentro de un Navigation Controller. Esto implica que si lo programamos nosotros en lugar de usar la plantilla perderemos los botones de navegaci\u00f3n. </li> </ul> <p>Incorporar un controlador Split View a nuestra aplicaci\u00f3n es bastante sencillo aunque no es trivial. Vamos a explicarlo con una app de ejemplo que mostrar\u00e1 informaci\u00f3n sobre pel\u00edculas. En modo horizontal (landscape) tendremos un listado en forma de tabla con todas las pel\u00edculas en la parte izquierda del Split View y cuando seleccionemos una de ellas nos aparecer\u00e1n sus detalles en la parte derecha. </p>"},{"location":"sesion-3-apps-universales.html#ejercicio-app-universal-con-uisplitviewcontroller","title":"Ejercicio: App universal con UISplitViewController","text":"<p>Para empezar vamos a programar una app b\u00e1sica con UISplitViewController adaptada a distintos modelos y tama\u00f1os de dispositivo.</p> <p>Crea un nuevo proyecto llamado <code>ejercicio_peliculas</code> con iOS &gt; App y storyboard. Selecciona un iPad en la barra de abajo para ir haciendo el dise\u00f1o del storyboard en este dispositivo, y el mismo modelo en el simulador (en la barra superior) para ejecutar el programa. </p> <p>Arrastra un UISplitViewController al storyboard. </p> <p>Mueve la flecha de inicio de la aplicaci\u00f3n para que el nuevo controlador sea el primero cuando arranque la app y borra el controlador antiguo del storyboard y su fichero <code>ViewController.swift</code>. El storyboard deber\u00eda quedar as\u00ed:</p> <p></p> <p>Como puedes ver, de nuestro splitViewController salen dos vistas: Una maestra (la tabla) que est\u00e1 controlada por un navigation controller, y una secundaria (detalle) enlazada al splitViewController. Si pinchas en los atributos de este controlador podr\u00e1s ver algo como esto:</p> <p></p> <p>Un atributo muy importante es el estilo (style). Los splitview pueden tener dos o tres columnas. Lo m\u00e1s com\u00fan es dos, pero puedes hacer una app de tres columnas y que por tanto estar\u00e1 asociada a tres vistas para mostrar informaci\u00f3n de detalle de segundo nivel. </p> <p>Puedes encontrar m\u00e1s informaci\u00f3n sobre splitView en este enlace.</p> <p>Ya tenemos una tabla y una vista detalle, pero nos faltan los ficheros de c\u00f3digo de los controladores. Para controlar la tabla crea un nuevo archivo con <code>File &gt; New &gt; File &gt; Cocoa touch &gt; UITableViewController</code> y ll\u00e1malo <code>TableViewController</code>. Asigna el controlador a la vista:</p> <p></p> <p>Creamos otro controlador para la vista detalle, al que llamaremos <code>DetailViewController</code>, subclase de <code>UIViewController</code>, y al igual que el anterior lo asignamos en el storyboard.</p> <p>Podemos ejecutar la aplicaci\u00f3n. En un iPad veremos que en modo Portrait s\u00f3lo se muetra la vista detalle. Pinchando en el icono superior se muestra tambi\u00e9n la maestra. Si rotamos se muestran ambas, aunque todav\u00eda est\u00e1n vac\u00edas. </p> <p>Ahora a\u00f1adimos los datos a la tabla. Para esto, inicializa  el siguiente array en <code>TableViewController</code>:</p> <pre><code>    let contenido = [\"Uno\",\"dos\",\"tres\"]\n</code></pre> <p>Borra el m\u00e9todo <code>numberOfSections</code> y modifica los siguientes m\u00e9todos:</p> <pre><code>    override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {\n        return contenido.count\n    }\n\n    override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {\n        let cell = tableView.dequeueReusableCell(withIdentifier: \"Cell\", for: indexPath)\n\n        // Configure the cell...\n        cell.textLabel!.text = contenido[indexPath.row]\n\n        return cell\n    }\n</code></pre> <p>Recuerda que, al igual que en el ejercicio de la barra de b\u00fasqueda, debemos registrar el identificador de la celda en nuestro <code>TableViewCell</code>:</p> <p></p> <p>De momento la vista detalle no tiene nada. Vamos a a\u00f1adirle una etiqueta en el centro, ajust\u00e1ndola horizontalmente y verticalmente:</p> <p></p> <p>Conectamos la etiqueta con <code>IBOutlet</code> a nuestro controlador <code>DetailViewController</code>. Lo llamamos <code>etiqueta</code>:</p> <pre><code>    @IBOutlet weak var etiqueta: UILabel!\n</code></pre> <p>Si ejecutamos la app veremos que se muestran ya elementos en la tabla y la vista detalle, aunque la idea es que esta  cambie cuando se seleccione una celda de la vista maestra. </p> <p>Para esto tenemos que comunicar el controlador maestro con el detalle. Una forma sencilla de implementar esto es en el m\u00e9todo <code>didSelectRowAt</code>:</p> <pre><code>    override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {\n\n        if let indexPath = self.tableView.indexPathForSelectedRow {\n            let object = self.contenido[indexPath.row]\n\n            // Conexi\u00f3n con el controlador detalle\n            let detailViewController = splitViewController!.viewController(for: .secondary) as? DetailViewController\n            detailViewController?.etiqueta.text = object\n        }\n    }\n</code></pre> <p>Como puedes ver, hemos accedido al controlador <code>splitViewController</code>, y dentro de este al secundario (la vista detalle) que es de la clase <code>DetailViewController</code>. Ahora podemos acceder al <code>Outlet</code> que hab\u00edamos enlazado y ejecutar la app:</p> <p></p> <p>Como puedes ver, si rotas el dispositivo las dos vistas aparecen lado a lado. Ahora ejecuta el programa en un iPhone 14. Ver\u00e1s que el aspecto es distinto:</p> <p></p> <p>S\u00f3lo se muestra la vista maestra, y si pulsamos sobre una celda no se pasa a la vista detalle. El problema es que, aunque hemos cambiado la segunda vista internamente, esta no se ve.</p> <p>Para que aparezca a\u00f1adimos lo siguiente tras la conexi\u00f3n con el controlador detalle (en <code>didSelectRowAt</code>):</p> <pre><code>// Si el controlador detalle no est\u00e1 presentado lo mostramos\nif !detailViewController!.isBeingPresented {\n    splitViewController!.showDetailViewController(detailViewController!, sender: self)\n}\n</code></pre> <p>Ejecuta ahora la app en iPhone e iPad, deber\u00eda funcionar correctamente con ambos y en cualquier orientaci\u00f3n y tama\u00f1o.</p>"},{"location":"sesion-3-apps-universales.html#ejercicio-peliculas","title":"Ejercicio Pel\u00edculas","text":"<p>Vamos a programar un ejemplo de aplicaci\u00f3n completa usando  SplitViewController con algunas vistas comunes y otras diferenciadas en funci\u00f3n del tama\u00f1o. Cuando tengamos la versi\u00f3n final del programa, en la vista maestra aparecer\u00e1 un listado de t\u00edtulos de pel\u00edculas y la vista detalle mostrar\u00e1 los detalles de la pel\u00edcula seleccionada, con el t\u00edtulo, un texto descriptivo, el a\u00f1o y una imagen.</p>"},{"location":"sesion-3-apps-universales.html#anadir-el-modelo-de-datos","title":"A\u00f1adir el modelo de datos","text":"<p>Partimos el proyecto anterior <code>ejercicio_peliculas</code> modific\u00e1ndolo para  guardar pel\u00edculas, por lo que vamos a implementar un modelo de datos. Para esto creamos una nueva clase <code>Pelicula</code> mediante File &gt; New &gt; File &gt; Swift file. A\u00f1adimos estos contenidos:</p> <pre><code>import UIKit\n\nclass Pelicula {\n    var titulo : String\n    var caratula : String\n    var fecha : String\n    var descripcion : String?\n\n    init(titulo: String, caratula: String, fecha: String, descripcion: String?) {\n        self.titulo = titulo\n        self.fecha = fecha\n        self.caratula = caratula\n        self.descripcion = descripcion\n    }\n}\n</code></pre> <p>En <code>MasterViewController</code> sustituimos el array <code>contenido</code> que ten\u00edamos en el ejercicio de prueba por un array de Pel\u00edculas:</p> <pre><code>var peliculas = [Pelicula]()\n</code></pre> <p>Reemplazamos en este fichero todas las apariciones de <code>contenido</code> por <code>peliculas</code>, y de <code>object</code> por <code>pelicula</code>. </p> <p>Vamos a a\u00f1adir a la tabla una pel\u00edcula de ejemplo. Para ello creamos el m\u00e9todo <code>crearListaPeliculas</code> en la clase <code>MasterViewController</code>:</p> <pre><code>func crearPeliculas() {\n    let sentidoDeLaVida = Pelicula(titulo: \"El sentido de la vida\", caratula: \"sentido.jpg\", fecha: \"1983\", descripcion: \"Conjunto de episodios que muestran de forma disparatada los momentos m\u00e1s importantes del ciclo de la vida. Desde el nacimiento a la muerte, pasando por asuntos como la filosof\u00eda, la historia o la medicina, todo tratado con el inconfundible humor de los populares c\u00f3micos ingleses. El pr\u00f3logo es un cortometraje independiente rodado por Terry Gilliam: Seguros permanentes Crimson.\")\n\n    self.peliculas.append(sentidoDeLaVida)\n}\n</code></pre> <p>A\u00f1adimos una llamada a este m\u00e9todo al final de <code>viewDidLoad</code> para inicializar las pel\u00edculas.</p> <p>Cambiamos tambi\u00e9n las siguientes lineas en el m\u00e9todo <code>cellForRowAt</code> para mostrar en las celdas el t\u00edtulo de la pel\u00edcula:</p> <pre><code>cell.textLabel!.text = peliculas[indexPath.row].titulo\n</code></pre> <p>A continuaci\u00f3n modifica <code>didSelectRowAt</code> para usar los datos de las pel\u00edculas, de forma que la etiqueta de la vista detalle contenga siempre el t\u00edtulo.</p> <p>Ejecutamos el programa en un iPad, deber\u00eda mostrar una pel\u00edcula (s\u00f3lo el t\u00edtulo, ya que no hemos a\u00f1adido la imagen ni otros datos) y funcionar correctamente.</p>"},{"location":"sesion-3-apps-universales.html#diseno-de-vista-y-controlador-detalle","title":"Dise\u00f1o de vista y controlador detalle","text":"<p>Vamos a dise\u00f1ar la vista detalle de manera independiente en funci\u00f3n del tama\u00f1o del dispositivo, pero antes vamos a hacer un peque\u00f1o cambio. En el c\u00f3digo que hemos visto anteriormente, cuando se selecciona una celda de la vista maestra se modifica directamente el contenido de la etiqueta de la vista detalle. Sin embargo, no es una buena pol\u00edtica de dise\u00f1o controlar una vista (en este caso, detalle) mediante el controlador de otra (maestra). </p> <p>Para mejorar el dise\u00f1o del c\u00f3digo, en <code>DetailViewController</code> crea un m\u00e9todo llamado <code>didChangePelicula</code> que reciba como par\u00e1metro una pel\u00edcula y actualice la vista en funci\u00f3n de los datos que tenga esta variable. De esta forma, desde  <code>TableViewController</code> podremos reemplazar la l\u00ednea que asigna directamente la etiqueta por la llamada al m\u00e9todo para que se haga dentro del controlador detalle:</p> <pre><code>//  detailViewController?.etiqueta.text = pelicula\ndetailViewController?.didChangePelicula(with: pelicula)\n</code></pre> <p>Selecciona la vista detalle en el storyboard y haz que sea como la que se muetra a continuaci\u00f3n. Borra el <code>UILabel</code> que ten\u00edamos en el ejercicio de prueba (<code>etiqueta</code>) tanto de la vista como de las conexiones.</p> <p>Nota: Cuando borres alg\u00fan elemento del interfaz que est\u00e9 ya enlazado con el c\u00f3digo con un <code>Outlet</code>, debes  eliminarlo tambi\u00e9n en el inspector de conexiones: </p> <p>Crea dos <code>UILabel</code> para el t\u00edtulo y la fecha, y tambi\u00e9n a\u00f1ade un <code>UIImageView</code> y un <code>UITextView</code>:</p> <p></p> <p>Tras colocar los elementos, usa Reset to suggested constraints para que los constraints se ajusten de forma autom\u00e1tica. Prueba tambi\u00e9n a visualizar la vista con otros dispositivos y orientaciones seleccion\u00e1ndolos en la barra inferior para ver que se adapten bien. </p> <p>Ponemos el <code>UITextView</code> s\u00f3lo como lectura para impedir que el usuario lo edite y salga un teclado cuando pulse sobre \u00e9l. Para esto, desmarca <code>Editable</code> y <code>Selectable</code> en sus propiedades. </p> <p></p> <p>Conecta todos los elementos de la vista (<code>titulo</code>, <code>fecha</code>, <code>imagen</code> y <code>descripcion</code>) al controlador <code>DetailViewController</code> con <code>IBOutlets</code>. </p> <p>Por \u00faltimo, descarga esta imagen y arr\u00e1strala a los Assets. Modifica el m\u00e9todo <code>didChangePelicula</code> para actualizar todos los outlets. En el caso de la imagen ser\u00eda:</p> <pre><code>self.imagen.image = UIImage(named: pelicula.caratula)\n</code></pre> <p>Ejecuta el programa simulando distintos iPhone y iPad para ver los resultados. </p> <p></p> <p>Seguro que en algunos casos no queda demasiado bien visualmente, pero de momento no es un problema. Vamos a ajustar mejor la vista en funci\u00f3n del dispositivo. </p>"},{"location":"sesion-3-apps-universales.html#vista-compacta-y-stacks","title":"Vista compacta y stacks","text":"<p>Empezaremos con el dise\u00f1o para tama\u00f1os compactos. Si ejecutamos el programa en un iPhone SE en landscape, veremos que la imagen ocupa casi toda la pantalla y deja poco espacio para el texto. En apaisado y con tama\u00f1os compactos, lo ideal ser\u00eda que la imagen estuviera a la izquierda y el texto a la derecha.</p> <p>Existe una soluci\u00f3n muy limpia para esto: usar stacks para agrupar las vistas y gestionar los giros.</p> <p>Selecciona el <code>UIImageView</code> y el <code>UITextView</code>.  Ahora pulsa sobre el elemento Stack, el icono de la flecha hacia abajo en esta imagen, y selecciona <code>Stack View</code>:</p> <p></p> <p>Ver\u00e1s que las vistas se unen porque hemos creado un grupo con dos elementos. Como ves, un stack se usa para agrupar vistas y nos permite realizar ciertas acciones con ellas. Vamos a reajustar las constraints con este nuevo Stack, seleccionando Reset to suggested constraints para toda la vista detalle.  </p> <p>Si ejecutamos el programa, el aspecto ser\u00e1 m\u00e1s o menos como el que ten\u00edamos antes. Vamos a arreglar los problemas del giro, ya que cuando ponemos un iPhone en landscape la pel\u00edculano se visualiza bien. Para esto necesitamos conectar nuestro Stack View a <code>DetailViewController</code>. Ll\u00e1malo <code>stackView</code>:</p> <pre><code>@IBOutlet weak var stackView: UIStackView!\n</code></pre> <p>Ahora vamos a a\u00f1adir el siguiente m\u00e9todo en <code>DetailViewController</code>:</p> <pre><code>override func viewWillLayoutSubviews() {\n    if view.bounds.size.width &gt;= view.bounds.size.height {\n        self.stackView.axis = .horizontal\n    }\n    else {\n        self.stackView.axis = .vertical\n    }\n}\n</code></pre> <p>Este m\u00e9todo se invoca cuando iOS detecta que hay que reajustar las vistas (por ejemplo cuando se realiza un giro). En el c\u00f3digo indicamos que cuando tengamos m\u00e1s espacio horizontal que vertical nuestras vistas del stack deben reposicionarse. Adem\u00e1s, lo har\u00e1n con una animaci\u00f3n. Prueba a ejecutar de nuevo el programa en un iPhone, debe verse as\u00ed en portrait:</p> <p></p> <p>Y as\u00ed en landscape:</p> <p></p> <p>Para saber m\u00e1s sobre lo que podemos hacer con la clase <code>UIStackView</code>, puedes consultar su referencia  en este enlace.</p>"},{"location":"sesion-3-apps-universales.html#vista-regular","title":"Vista regular","text":"<p>Vamos a ajustar el constraint de la altura de la imagen para hacerla m\u00e1s grande en tama\u00f1os <code>wR-hR</code>, ya que en estos casos tenemos m\u00e1s espacio. Selecciona el constraint en la escena:</p> <p></p> <p>Ahora pulsamos sobre el bot\u00f3n <code>+</code> de la altura, a\u00f1adiendo una variaci\u00f3n para <code>wR-hR</code>:</p> <p></p> <p>Y finalmente indicamos un valor m\u00e1s alto:</p> <p></p> <p>Ejecutamos el programa y vemos que funciona correctamente en iPad, en cualquier orientaci\u00f3n. </p> <p>Ahora vamos a cambiar el tipo de letra para <code>wR-hR</code>, de forma que se vea m\u00e1s grande en un iPad. Cambia s\u00f3lo para tama\u00f1os <code>wR-hR</code> la fuente del texto a System-20, y la del t\u00edtulo a System-30 y en negrita:</p> <p></p> <p>Finalmente vamos a dejar la fecha s\u00f3lo en aquellos casos en los que tengamos suficiente espacio en anchura. Esto asumimos que ocurre en orientaciones regular width (<code>wR</code>), por lo que tenemos que desmarcarla para compact widht (<code>wC</code>) y cualquier altura (<code>h Any</code>):</p> <p></p> <p>Esta etiqueta s\u00f3lo se mostrar\u00e1 en los iPad cuando nuestra app est\u00e9 a pantalla completa en cualquier orientaci\u00f3n, o en en los iPhone grandes a pantalla completa y landscape.</p> <p>Ejecutamos el c\u00f3digo en el simulador de iPad para ver los resultados. Deber\u00edamos obtener algo parecido a esto:</p> <p> </p> <p>El aspecto no est\u00e1 mal, pero s\u00f3lo es una primera aproximaci\u00f3n. Vamos a mejorar un poco el programa con los siguientes cambios: </p> <ul> <li> <p>Completa el modelo a\u00f1adiendo dos pel\u00edculas m\u00e1s (con sus im\u00e1genes) al proyecto, las que prefieras.</p> </li> <li> <p>Vamos a mejorar la presentaci\u00f3n visual. Para ello cambia el t\u00edtulo de la barra de la vista detalle, de Pel\u00edcula al t\u00edtulo de la pel\u00edcula seleccionada en la vista con el a\u00f1o entre par\u00e9ntesis. Por ejemplo, en la barra superior deber\u00eda salir El sentido de la vida (1983). </p> </li> <li> <p>Cambia el aspecto gr\u00e1fico de las vistas para que queden lo mejor posible. Puedes mover los objetos, redimensionarlos o modificar sus propiedades, por ejemplo. </p> </li> <li> <p>La primera vez que aparece la aplicaci\u00f3n en portrait (sin llegar a seleccionar una pel\u00edcula) sale la vista detalle con informaci\u00f3n vac\u00eda. Haz que en este caso se muestre s\u00f3lo <code>Pel\u00edcula</code> en el t\u00edtulo, y que la descripci\u00f3n sea el mensaje Selecciona una pel\u00edcula.</p> </li> </ul>"},{"location":"sesion-4-multitouch.html","title":"4- Gestos","text":"<p>En esta sesi\u00f3n veremos c\u00f3mo capturar y gestionar los gestos del usuario sobre la pantalla.</p>"},{"location":"sesion-4-multitouch.html#pantalla-tactil","title":"Pantalla t\u00e1ctil","text":"<p>El sensor de pantalla es, obviamente, el m\u00e1s usado y com\u00fan de todos. En una aplicaci\u00f3n iOS que utilice los componentes b\u00e1sicos de <code>UIKit</code> como tablas, botones, campos de texto, etc. problamente no tendremos que preocuparnos por gestionar los eventos producidos por el sensor de la pantalla. En aplicaciones como juegos, o m\u00e1s elaboradas, es muy habitual que tengamos que hacer uso de los eventos que detallaremos a continuaci\u00f3n.</p> <p>La gesti\u00f3n de eventos de entrada (Touch Events) se realiza a trav\u00e9s de los siguientes m\u00e9todos, que m\u00e1s adelante detallaremos mediante un ejemplo:</p> <ul> <li><code>func touchesBegan(Set&lt;UITouch&gt;, with: UIEvent?)</code>: Captura las pulsaciones sobre la pantalla. El m\u00e9todo recibe la lista de pulsaciones que se detectan.</li> <li><code>func touchesMoved(Set&lt;UITouch&gt;, with: UIEvent?)</code>: Captura los movimientos de las pulsaciones sobre la pantalla</li> <li><code>func touchesEnded(Set&lt;UITouch&gt;, with: UIEvent?)</code>: Captura las \u00faltimas pulsaciones sobre la pantalla</li> <li><code>func touchesCancelled(Set&lt;UITouch&gt;, with: UIEvent?)</code>: Evento que se ejecuta cuando cerramos la aplicaci\u00f3n o la vista mientras se est\u00e1 detectando pulsaciones en la pantalla, o cuando se interrumpe por un evento externo como una llamada.</li> </ul> <p>En general, estos eventos pertenecen a la clase <code>UIResponder</code>. Puedes obtener m\u00e1s informaci\u00f3n sobre esta clase aqu\u00ed. Adem\u00e1s de los eventos de pulsaci\u00f3n sobre la pantalla, controla los de movimiento (por ejemplo cuando se agita el dispositivo) y los de control remoto (cuando se dispone de un dispositivo externo de control).</p> <p>Los dispositivos iOS tambi\u00e9n admiten varias pulsaciones al mismo tiempo, lo que se le conoce con el nombre de multitouch. Esta caracter\u00edstica hay que tenerla en cuenta a la hora de implementar los m\u00e9todos anteriores. Para entrar m\u00e1s en profundidad en el uso de las funciones de pulsaciones en iOS, vamos a realizar una aplicaci\u00f3n de ejemplo en la que arrastraremos una imagen por la pantalla de nuestro dispositivo.</p>"},{"location":"sesion-4-multitouch.html#ejercicio-1-gestos","title":"Ejercicio 1 - Gestos","text":"<p>Comenzamos creando un proyecto en XCode de tipo App con storyboard que guardaremos con el nombre <code>ejercicio_touch</code>. Creamos un objeto de tipo UIImageView, lo arrastramos a la vista coloc\u00e1ndolo en la parte superior izquierda de la pantalla, y lo enlazamos a nuestro <code>ViewController</code> para crear la propiedad, a la que llamaremos imageView. </p> <p>Arrastra la imagen logo-master.png al proyecto y as\u00edgnala a la vista como se indica a continuaci\u00f3n (aunque tambi\u00e9n se podr\u00eda hacer por c\u00f3digo):</p> <p></p> <p>Ahora editamos el archivo <code>ViewController.swift</code>, y a\u00f1adimos un Outlet que enlazamos con nuestro UIImageView y un booleano llamado <code>tocaImagen</code>. Debe quedar de la siguiente forma:</p> <pre><code>@IBOutlet weak var imageView: UIImageView!\nvar tocaImagen = false\n</code></pre> <p>Como se puede ver tenemos dos propiedades: una imagen que podremos mover por la pantalla, y un booleano que utilizaremos para indicar si la estamos moviendo o no. Ahora a\u00f1adimos al fichero <code>ViewController.swift</code> los cuatro m\u00e9todos que gestionan los gestos:</p> <pre><code>override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) {\n    if let touch = touches.first {\n        print(\"Touches began\")\n        let loc = touch.location(in: self.view)\n        if self.imageView.frame.contains(loc) {\n            print(\"Detectado toque sobre la imagen\")\n            self.tocaImagen = true\n        }\n    }\n    super.touchesBegan(touches, with: event)\n}\n\noverride func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) {\n    if let touch = touches.first {\n        print(\"Touches moved\")\n        let loc = touch.location(in: self.view)\n        if self.tocaImagen == true {\n            self.imageView.center = loc\n        }\n    }\n    super.touchesMoved(touches, with: event)\n}\n\noverride func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) {\n        print(\"Touches ended\")\n        self.tocaImagen = false\n        super.touchesEnded(touches, with: event)\n}\n\noverride func touchesCancelled(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) {\n        print(\"Touches cancelled\")\n        self.tocaImagen = false\n        super.touchesCancelled(touches, with: event)\n}\n</code></pre> <p>Como podemos observar en el c\u00f3digo anterior, hemos utilizado la clase de UIKit <code>UITouch</code>. Esta clase representa el evento de toque. Al mismo tiempo que el usuario interact\u00faa con la pantalla, iOS env\u00eda continuamente mensajes al evento correspondiente (uno de los cuatro comentados anteriormente). Cada evento incluye informaci\u00f3n sobre los distintos toques en la secuencia producida por el usuario y cada toque en particular corresponde a una instancia de la clase <code>UITouch</code>.</p> <p>Con esto \u00faltimo ya podemos ejecutar la aplicaci\u00f3n y veremos que podemos pulsar sobre la imagen y arrastrarla.</p> <p></p> <p>El funcionamiento de estos m\u00e9todos es muy simple. Primero se ejecuta <code>touchesBegan</code> que detecta el primer toque sobre la pantalla, en el comprobamos si la posici\u00f3n del toque est\u00e1 dentro del cuadro (frame) del <code>UIImageView</code>. Si es as\u00ed actualizamos la variable booleana a <code>true</code>, y en caso contrario no hacemos nada. En el momento en que arrastremos el dedo sobre la pantalla se ejecutar\u00e1 continuamente el m\u00e9todo <code>touchesMoved</code>. En este, si la variable booleana <code>tocaImagen</code> est\u00e1 a <code>true</code> actualizamos la posici\u00f3n de la imagen a la posici\u00f3n detectada, y en caso contrario no hacemos nada. Por \u00faltimo, cuando dejamos de pulsar la pantalla se ejecutar\u00e1 el m\u00e9todo <code>touchesEnded</code> el cual simplemente volver\u00e1 a actualizar la variable booleana a <code>false</code>.</p> <p>Si queremos detectar varios toques al mismo tiempo, primero deberemos activarlo, por ejemplo en <code>viewDidLoad</code>:</p> <pre><code>   self.imageView.isMultipleTouchEnabled = true\n</code></pre> <p>Tambi\u00e9n podr\u00edamos haberlo hecho desde el Storyboard, pinchando sobre el <code>UIImageView</code>:</p> <p></p> <p>Y luego podemos gestionar los toques simult\u00e1neos como en el siguiente ejemplo, en el que vamos a modificar el m\u00e9todo <code>touchesBegan</code>:</p> <pre><code>override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) {\n    if let touch = touches.first {  // S\u00f3lo nos centramos en el primer toque\n        print(\"Touches began\")\n\n        let touchCount = event!.allTouches!.count // N\u00famero de dedos pulsando\n        let tapCount = touch.tapCount  // N\u00faero de pulsaciones r\u00e1pidas\n\n        print(\"Finger count= \\(touchCount)\")\n        print(\"Tap count= \\(tapCount)\")\n\n        let loc = touch.location(in: self.view)\n        if self.imageView.frame.contains(loc) {\n            print(\"Detectado toque sobre la imagen\")\n            self.tocaImagen = true\n        }\n    }\n    super.touchesBegan(touches, with: event)\n}\n</code></pre> <p>En el fragmento de c\u00f3digo anterior, si se ha hecho alguna pulsaci\u00f3n distinguimos primero el n\u00famero de dedos y luego comprobamos el n\u00famero de pulsaciones r\u00e1pidas (equivalente a un doble click del rat\u00f3n). Esto es un claro ejemplo de gesti\u00f3n de la funci\u00f3n multitouch de iOS y, como se puede ver, es bastante simple de implementar.</p> <p>Para simular dos pulsaciones al mismo tiempo en el simulador de iPhone/iPad de XCode, podemos pulsar la tecla <code>alt</code> (opci\u00f3n) mientras movemos el cursor.</p> <p>Desde XCode 7 existe la opci\u00f3n de usar 3D touch, que b\u00e1sicamente consiste en un sensor de presi\u00f3n para la pantalla de forma que se puedan ejecutar distintas acciones en funci\u00f3n del grado de presi\u00f3n. Desde XCode 7.3 podemos usar el simulador para esto (antes estaba limitado a dispositivos reales). No vamos a entrar en detalles sobre el 3D Touch, pero si quieres saber m\u00e1s la clase <code>UITouch</code> tiene una propiedad adicional llamada <code>force</code> que se usa para medir la fuerza de la pulsaci\u00f3n del usuario con respecto a una fuerza m\u00e1xima cuyo valor es <code>maximumPossibleForce</code>.</p> <pre><code>if self.traitCollection.forceTouchCapability == UIForceTouchCapability.available {\n    print(\"Force= \\(touch.force) from \\(touch.maximumPossibleForce)\")\n}\n</code></pre> <p>En algunos modelos de iPad tambi\u00e9n se puede usar un l\u00e1piz digital (Apple Pencil). Podemos distinguir un trazo del l\u00e1piz de una pulsaci\u00f3n del dedo mediante la siguiente condici\u00f3n:</p> <pre><code>if touch.type == .stylus {\n   print(\"Stylus detected\")\n}\n</code></pre> <p>Adem\u00e1s, desde el iPhone 7 Apple ha introducido Haptic Feedback, que permite responder f\u00edsicamente a las interacciones del usuario con la pantalla. Para m\u00e1s informaci\u00f3n, se puede consultar la  referencia de la clase <code>UIFeedbackGenerator</code>.</p>"},{"location":"sesion-4-multitouch.html#reconocimiento-de-gestos-multitactiles-con-uigesturerecognizer","title":"Reconocimiento de gestos multit\u00e1ctiles con UIGestureRecognizer","text":"<p>En el apartado anterior hemos visto como mover un objeto por la pantalla usando los m\u00e9todos de detecci\u00f3n de pulsaciones en la pantalla y programando todo el c\u00f3digo nosotros.</p> <p>Esto est\u00e1 bien para gestos simples, pero el problema de lo que hemos implementado anteriormente es que si queremos detectar un gesto como un swipe, tendremos que registrar las notificaciones para cada toque de las vistas (usando <code>touchesBegan</code>, <code>touchesMoved</code> y <code>touchesEnded</code>). En las primeras versiones de iOS cada programador escrib\u00eda c\u00f3digo distinto para detectar los toques en la pantalla, provocando bugs e incosistencias entre apps.</p> <p>Para evitar esto, hace mucho tiempo (iOS 3) Apple a\u00f1adi\u00f3 la clase <code>UIGestureRecognizer</code> para los gestos comunes en iOS. Esta clase nos permite gestionar los toques, el efecto \"pellizco\" (por ejemplo para hacer zoom), rotaciones, swipes, pans, y pulsaciones largas, entre otras. Usando esta clase no s\u00f3lo ahorramos mucho c\u00f3digo sino que tambi\u00e9n hacemos que nuestras apps sean consistentes. Los gestos que podemos gestionar en iOS son los siguientes:</p> <ul> <li>Toque (tap): Consiste en presionar o hacer \"click\" sobre un bot\u00f3n o cualquier objeto que est\u00e9 en pantalla.</li> <li>Arrastre (drag): Mover el dedo sobre la pantalla en una direcci\u00f3n, puede usarse para navegar sobre los elementos de una tabla, por ejemplo.</li> <li>Arrastre r\u00e1pido (flick): Como el anterior, pero m\u00e1s r\u00e1pido. Sirve para moverse por la pantalla de forma r\u00e1pida.</li> <li>Arrastre lateral (swipe): Mover el dedo en direcci\u00f3n horizontal, sirve para mostrar el bot\u00f3n de \"Eliminar\" en una fila de una tabla.</li> <li>Doble toque (double tap): Presionar dos veces seguidas y de forma r\u00e1pida la pantalla. Sirve para aumentar una imagen o un mapa, por ejemplo.</li> <li>Pellizco exterior (pinch open): Gesto de pellizco sobre la pantalla que sirve para aumentar una imagen o un mapa.</li> <li>Pellizco interior (pinch close): El inverso del anterior.</li> <li>Toque continuo (touch and hold): Como el toque b\u00e1sico, pero manteniendo el dedo sobre la pantalla. Sirve para mostrar un menu contextual sobre la zona que se pulsa.</li> <li>Agitar (shake): Para inicializar una acci\u00f3n de deshacer (undo) o rehacer (redo).</li> <li>3D touch (hard press): Los modelos posteriores a iPhone 6S a\u00f1aden un gesto 3D que se activa cuando pulsamos la pantallas con una presi\u00f3n mayor. Se usa para mostrar informaci\u00f3n como un peek (una vista flotante) o pop (men\u00fa contextual).</li> </ul> <p>Puedes ver los movimientos en detalle en la gu\u00eda de estilo, secci\u00f3n Inputs &gt; Touchscreen gestures. </p> <p>Usar la clase <code>UIGestureRecognizer</code> es muy sencillo, simplemente hay que: * Crear un Gesture Recognizer. Cuando se crea un elemento de esta clase debemos especificar una funci\u00f3n callback. Esta funci\u00f3n se llamar\u00e1 cuando los gestos empiecen, cambien o terminen. * A\u00f1adir un Gesture Recognizer a la vista. Cada gesture recognizer se asocia con una (y s\u00f3lo una) vista. Cuando se produce un gesto dentro de los l\u00edmites de esa vista, el recognizer mirar\u00e1 si coincide con el tipo de gesto buscado, y si es as\u00ed se notificar\u00e1 mediante la funci\u00f3n callback.</p> <p>Podemos a\u00f1adir un Gesture Recognizer mediante c\u00f3digo o usando el storyboard. Veremos como hacerlo de las dos formas mediante un ejercicio sencillo similar al anterior.</p>"},{"location":"sesion-4-multitouch.html#ejercicio-2-multitouch","title":"Ejercicio 2 - Multitouch","text":"<p>Crea un nuevo proyecto y ll\u00e1malo <code>ejercicio_multitouch</code>. Como en el anterior, a\u00f1ade una UIImageView en la parte superior izquierda de la vista, as\u00edgnale la imagen logo-master y enl\u00e1zala con el controlador. Recuerda marcar para el <code>UIImageView</code> desde el Storyboard las casillas <code>User Interaction Enabled</code> y  seleccionar <code>Multiple Touch</code>. Alternativamente puedes hacerlo mediante c\u00f3digo en viewDidLoad:</p> <pre><code>self.imageView.isUserInteractionEnabled = true\nself.imageView.isMultipleTouchEnabled = true\n</code></pre> <p>Vamos a definir un gesto que realice la funci\u00f3n de pulsaci\u00f3n, similar a lo realizado en el primer ejemplo, pero con <code>UIGestureRecognizer</code>. Para ello, en <code>ViewController.swift</code>  asignamos el protocolo:</p> <pre><code>class ViewController : UIViewController, UIGestureRecognizerDelegate\n</code></pre> <p>Y en el fichero <code>ViewController.swift</code> a\u00f1adimos lo siguiente al final del m\u00e9todo <code>viewDidLoad</code>:</p> <pre><code>let tap = UITapGestureRecognizer(target: self, action:#selector(handleTap))\ntap.delegate = self\nself.imageView.addGestureRecognizer(tap)\n</code></pre> <p>En el c\u00f3digo anterior nos hemos definido un objeto de la clase <code>UITapGestureRecognizer</code>, al cual le hemos asignado una acci\u00f3n llamada <code>handleTap</code> que se ejecutar\u00e1 cuando se detecte una pulsaci\u00f3n. Tambi\u00e9n hemos asignado el objeto creado a la imagen para que los gestos est\u00e9n \u00fanicamente asociados a esa vista.</p> <p>Ahora implementamos el m\u00e9todo <code>handleTap</code>:</p> <pre><code>@objc func handleTap(sender: UITapGestureRecognizer) {\n    print(\"Tap\");\n}\n</code></pre> <p>Si volvemos a ejecutar la aplicaci\u00f3n veremos que aparece el mensaje \"Tap\" cuando pulsamos sobre la imagen.</p> <p>A continuaci\u00f3n vamos a a\u00f1adir los gestos de arrastre, rotaci\u00f3n y pellizco de la misma manera que hemos implementado el de pulsaci\u00f3n:</p> <pre><code>  // Gesto de pulsar y arrastrar\n  let pan = UIPanGestureRecognizer(target: self, action:#selector(handlePan))\n  pan.delegate = self\n  self.imageView.addGestureRecognizer(pan)\n\n  // Gesto de rotaci\u00f3n\n  let rotation = UIRotationGestureRecognizer(target: self, action:#selector(handleRotation))\n  rotation.delegate = self\n  self.imageView.addGestureRecognizer(rotation)\n\n  // Gesto de pellizcar\n  let pinch = UIPinchGestureRecognizer(target: self, action:#selector(handlePinch))\n  pinch.delegate = self\n  self.imageView.addGestureRecognizer(pinch)\n</code></pre> <p>Implementamos los m\u00e9todos de las acciones:</p> <pre><code>@objc func handlePan(sender: UIPanGestureRecognizer) {\n    print(\"Pan\")\n    let translation = sender.translation(in: self.view)\n    if let view = sender.view {\n        view.center = CGPoint(x: view.center.x + translation.x, y: view.center.y + translation.y)\n    }\n    sender.setTranslation(CGPoint.zero, in: self.view)\n}\n\n@objc func handleRotation(sender: UIRotationGestureRecognizer) {\n    print(\"Rotation\")\n    if let view = sender.view {\n        view.transform = view.transform.rotated(by: sender.rotation)\n        sender.rotation = 0\n    }\n}\n\n@objc func handlePinch(sender: UIPinchGestureRecognizer) {\n    print(\"Pinch\")\n    if let view = sender.view {\n        view.transform = view.transform.scaledBy(x: sender.scale, y: sender.scale)\n        sender.scale = 1;\n    }\n}\n</code></pre> <p>Si ejecutamos la aplicaci\u00f3n veremos que funciona todo correctamente pero al intentar realizar dos gestos al mismo tiempo estos no funcionan de manera simult\u00e1nea por ejemplo, ampliar y rotar). Para que dos o m\u00e1s gestos se puedan usar al mismo tiempo, en el fichero <code>ViewController.swift</code> tenemos que implementar el m\u00e9todo <code>shouldRecognizeSimultaneouslyWithGestureRecognizer</code>:</p> <pre><code>func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -&gt; Bool {\n    return true\n}\n</code></pre> <p>Si volvemos a ejecutar la aplicaci\u00f3n de nuevo, veremos que ya podemos realizar dos o m\u00e1s gestos al mismo tiempo.</p> <p>En total podemos usar los siguientes gestos en nuestras aplicaciones, adem\u00e1s de crear los nuestros propios creando subclases de <code>UIGestureRecognizer</code>:</p> <ul> <li><code>UITapGestureRecognizer</code></li> <li><code>UIPinchGestureRecognizer</code></li> <li><code>UIRotationGestureRecognizer</code></li> <li><code>UISwipeGestureRecognizer</code></li> <li><code>UIPanGestureRecognizer</code></li> <li><code>UIScreenEdgePanGestureRecognizer</code></li> <li><code>UILongPressGestureRecognizer</code></li> </ul> <p>Y esto es lo b\u00e1sico para poder implementar reconocimiento de gestos en nuestra aplicaci\u00f3n.</p> <p>Para finalizar vamos a implementar un gesto adicional, pero en lugar de hacerlo mediante c\u00f3digo lo haremos desde el storyboard para verlo de una forma alternativa. Para a\u00f1adirlo desde el storyboard (aunque probablemente es m\u00e1s r\u00e1pido desde c\u00f3digo), selecciona el gesto Long press Gesture Recognizer de la Librer\u00eda (con el bot\u00f3n <code>+</code>) y arr\u00e1stralo sobre la imagen.</p> <p>Puedes cambiar desde el interfaz sus par\u00e1metros, como por ejemplo la duraci\u00f3n m\u00ednima. Finalmente asigna un m\u00e9todo al gesto, arrastrando el objeto al c\u00f3digo de la clase y seleccionando Action, y conecta el delegado con el <code>ViewController</code>. El m\u00e9todo debe imprimir el mensaje <code>print(\"long press\")</code> cuando se realice una pulsaci\u00f3n larga sobre la imagen. Con el bot\u00f3n derecho sobre el gesto puedes ver con qu\u00e9 objeto se relaciona y cambiarlo si es necesario.</p>"}]}